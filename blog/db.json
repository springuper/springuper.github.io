{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/DIY.jpg","path":"images/DIY.jpg","modified":0,"renderable":0},{"_id":"source/images/banner-top1.jpg","path":"images/banner-top1.jpg","modified":0,"renderable":0},{"_id":"source/images/bubble-girl.jpg","path":"images/bubble-girl.jpg","modified":0,"renderable":0},{"_id":"source/images/delegate.jpg","path":"images/delegate.jpg","modified":0,"renderable":0},{"_id":"source/images/error-flow.png","path":"images/error-flow.png","modified":0,"renderable":0},{"_id":"source/images/event-default-action.png","path":"images/event-default-action.png","modified":0,"renderable":0},{"_id":"source/images/logo.fw.png","path":"images/logo.fw.png","modified":0,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"source/images/meituan-fe-job.png","path":"images/meituan-fe-job.png","modified":0,"renderable":0},{"_id":"source/images/metro.png","path":"images/metro.png","modified":0,"renderable":0},{"_id":"source/images/mouse.png","path":"images/mouse.png","modified":0,"renderable":0},{"_id":"source/images/mt-fe-architecture.png","path":"images/mt-fe-architecture.png","modified":0,"renderable":0},{"_id":"source/images/notSevenDay1.png","path":"images/notSevenDay1.png","modified":0,"renderable":0},{"_id":"source/images/office-1.jpg","path":"images/office-1.jpg","modified":0,"renderable":0},{"_id":"source/images/office-2.jpg","path":"images/office-2.jpg","modified":0,"renderable":0},{"_id":"source/images/panweizeng.jpeg","path":"images/panweizeng.jpeg","modified":0,"renderable":0},{"_id":"source/images/promise-series-flow.png","path":"images/promise-series-flow.png","modified":0,"renderable":0},{"_id":"source/images/promise-series-simple-flow.png","path":"images/promise-series-simple-flow.png","modified":0,"renderable":0},{"_id":"source/images/promise-states-flow.png","path":"images/promise-states-flow.png","modified":0,"renderable":0},{"_id":"source/images/w3ctech-meituan.jpg","path":"images/w3ctech-meituan.jpg","modified":0,"renderable":0},{"_id":"source/images/zhangmengxuan.jpg","path":"images/zhangmengxuan.jpg","modified":0,"renderable":0},{"_id":"source/images/zhiyelee.png","path":"images/zhiyelee.png","modified":0,"renderable":0},{"_id":"source/images/frontend-component-practice/component-flow.png","path":"images/frontend-component-practice/component-flow.png","modified":0,"renderable":0},{"_id":"source/images/frontend-component-practice/component-flux.png","path":"images/frontend-component-practice/component-flux.png","modified":0,"renderable":0},{"_id":"source/images/frontend-component-practice/component-lifecycle.png","path":"images/frontend-component-practice/component-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/frontend-component-practice/legacy-flow.png","path":"images/frontend-component-practice/legacy-flow.png","modified":0,"renderable":0},{"_id":"source/images/frontend-component-practice/smart-box.png","path":"images/frontend-component-practice/smart-box.png","modified":0,"renderable":0},{"_id":"themes/even/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/even/source/robots.txt","path":"robots.txt","modified":0,"renderable":1},{"_id":"themes/even/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","path":"fonts/chancery/apple-chancery-webfont.svg","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","path":"fonts/chancery/apple-chancery-webfont.eot","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","path":"fonts/chancery/apple-chancery-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","path":"fonts/chancery/apple-chancery-webfont.woff","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","path":"fonts/chancery/apple-chancery-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/even.js","path":"js/src/even.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.js","path":"lib/slideout/slideout.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.min.js","path":"lib/slideout/slideout.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/change-theme.md","hash":"c9675e659b0e1f1913acf36d7fd3755a13713761","modified":1633426487222},{"_id":"source/_posts/bitwise-not-and-logical-not.md","hash":"f66c8ea8318e728dde7ac81ff7e2e7fa2c852539","modified":1637838085485},{"_id":"source/_posts/birth.md","hash":"4aad0dac77599349a7bb413d9ca843e8046c67d6","modified":1633352236035},{"_id":"source/_posts/diff-great-software-engineer-from-a-good.md","hash":"e9f1b7f4df6a4f9e12f1e5df2d24c8a662264875","modified":1633352236045},{"_id":"source/_posts/continuation.md","hash":"4fc04f12ddeb5e1d13265b9b89b1a3b8a407dd42","modified":1633439605154},{"_id":"source/_posts/event-custom.md","hash":"b62c5ea2791f010463fd2362c018c55322ce8c82","modified":1633425743355},{"_id":"source/_posts/event-delegate.md","hash":"c4b5ac2a80d82b3d83dd5cb49babbc6635323813","modified":1633425770791},{"_id":"source/_posts/event-do.md","hash":"a1f65ae9b9267351d8fd8643b2bce7200cc7ac7a","modified":1633352236035},{"_id":"source/_posts/event-note.md","hash":"8d4f392fa98e4244a707b59781afffe7e9bafd21","modified":1633352236033},{"_id":"source/_posts/event.md","hash":"58b88557e328a20ff32974c39e2e3780c9b1d490","modified":1633425701238},{"_id":"source/_posts/event-target.md","hash":"866707229672738727bb3d417ad2593c3b163769","modified":1633426256356},{"_id":"source/_posts/extend-and-augment.md","hash":"857cbef75a2a92f591a984bc0320ebe86fccb06c","modified":1633352236038},{"_id":"source/_posts/fe-pipeline.md","hash":"47efbe88c37457ea4e4fd0e9ac3bd37deae236e3","modified":1633439990200},{"_id":"source/_posts/frontend-component-practice.md","hash":"0e5d47da6886d023daf806f76782628dc1199382","modified":1637838014648},{"_id":"source/_posts/frontend-frp.md","hash":"e5e4ab7395be048a512a85fb70f47d482a7b4983","modified":1642598596603},{"_id":"source/_posts/javascript-the-core.md","hash":"97e6ef5441ed4ef42af39cb982ca910aa3937324","modified":1633352236037},{"_id":"source/_posts/frontend-frp-2nd.md","hash":"72aa4af448f42d01b7cbd0dcaf3a661c0bbe0829","modified":1648265593290},{"_id":"source/_posts/hire-slow.md","hash":"4835ae2086b9b5b611a206548a80900e0af591fe","modified":1649069187654},{"_id":"source/_posts/js-linter-history.md","hash":"e8b06b239ed35e518abc0187259056d1dcf7edad","modified":1633439774125},{"_id":"source/_posts/monad.md","hash":"c13a05cf9538b59d9ff3dc17441a90ae47a61c03","modified":1633439690562},{"_id":"source/_posts/js-error-catch.md","hash":"424a7e796ec834d639f0cee45e5f8d197fe43bff","modified":1633426414983},{"_id":"source/_posts/react-design-highlights.md","hash":"37bf8077fde850e460b8ed9df090480bff6ffb89","modified":1633439855246},{"_id":"source/_posts/promise-insight.md","hash":"a6f3a333b7a7e86c9d4f0531f336e71e0bee7476","modified":1633425621060},{"_id":"source/_posts/interview-is-bidirectional.md","hash":"5076379afff5946352efec35f3d06797d00903fd","modified":1643620594468},{"_id":"source/_posts/recruitment-driven-organization.md","hash":"2d2f210dd49937d89db02d49223d2524bca334f7","modified":1637825744261},{"_id":"source/_posts/react-hooks.md","hash":"a09948699efe1a5ec73172d2fbd7765f5b39eafb","modified":1633439142377},{"_id":"source/_posts/typescript-101.md","hash":"9f2cf9c0be0674f5aaff7d1d2f8633ba79bb3e2c","modified":1633439522099},{"_id":"source/_posts/scope-safe-constructor.md","hash":"45bc3066051f08e7043038bc9c4aad26f0162548","modified":1633426609474},{"_id":"source/_posts/the-awakeing-age.md","hash":"06a510d1e952439a870fd2f2debd2e501e264812","modified":1633439322280},{"_id":"source/_posts/typescript-advanced.md","hash":"a0431e699af50d7152113141286d313f4895eaf1","modified":1633439425932},{"_id":"source/_posts/understanding-this-keyword.md","hash":"c572a0327e65f01122c83eb274ecc68a4bdd917b","modified":1633352236037},{"_id":"source/_posts/w3ctech-meituan.md","hash":"4868cd2fa10df97b6c4d9cc7f348941e4d6358c3","modified":1633426439162},{"_id":"source/_posts/yui-domready-after-load.md","hash":"7b27bd6daa917849f469fffe2a3eccdab7a8f180","modified":1633352236038},{"_id":"source/_posts/yui3-event-default-action.md","hash":"72cb81e51188dd1267f03e681c7659b2bd6a510c","modified":1633426068617},{"_id":"source/_posts/yui3-intro.md","hash":"e8d7965ddc19010077620fdf54e34935b8e84b9c","modified":1633352236046},{"_id":"source/_posts/yui3-in-meituan.md","hash":"17794b0cab58cec3709319841fff14cd7f90ac1f","modified":1633352236034},{"_id":"source/_posts/yui3-practice.md","hash":"70012159fb36d251377c7833f334e70b25e8813e","modified":1633426180997},{"_id":"source/tags/index.md","hash":"4e7ed46a5d65df75867d3133d40395852d40a806","modified":1637826335976},{"_id":"source/images/delegate.jpg","hash":"9d20c5d0d13198f6a740def2929307d21661d2a1","modified":1633352291889},{"_id":"source/images/banner-top1.jpg","hash":"4b46871a95c8d3b39be80d2ffccc580e4ff7a9ad","modified":1633352291884},{"_id":"source/images/error-flow.png","hash":"52eb57177722fb807ae7e9ef4ded99ba71a34488","modified":1633352291888},{"_id":"source/images/logo.png","hash":"231f5c3497e309892a05ebd464323958daa9aedb","modified":1633352291888},{"_id":"source/images/event-default-action.png","hash":"845446ba8a406949526fdb39287514f6c2e45c23","modified":1633352291889},{"_id":"source/images/mt-fe-architecture.png","hash":"f89aeec23af2771d693575b96d0f5453ad08e94b","modified":1633352291888},{"_id":"source/images/notSevenDay1.png","hash":"8888259d6a71b648a7100e498229f828a34c42b8","modified":1633352291877},{"_id":"source/images/panweizeng.jpeg","hash":"433ee71fca427066c527a85499ded84b5a691f1f","modified":1633352291885},{"_id":"source/images/promise-series-flow.png","hash":"8213fdcaab3ca6a3b30a4c9e21d6a8ae56df8d4d","modified":1633352291881},{"_id":"source/images/promise-states-flow.png","hash":"b2e160b9ab569149b887d458f329bce9a49c0d42","modified":1633352291882},{"_id":"source/images/promise-series-simple-flow.png","hash":"6c3d0af641e2928c232d3ac7d11f4554bcdf1a64","modified":1633352291883},{"_id":"source/images/zhiyelee.png","hash":"2c2fd9e9fad2314a027c37dff1ecfeb7c90cc037","modified":1633352291881},{"_id":"source/images/zhangmengxuan.jpg","hash":"63b74f005c01cb72c17e00e0c5a65d433ac62730","modified":1633352291882},{"_id":"source/images/frontend-component-practice/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1633352291877},{"_id":"source/images/frontend-component-practice/legacy-flow.png","hash":"c220c2158875c6787aa2f7d37e59d0387c227107","modified":1633352291880},{"_id":"source/images/frontend-component-practice/smart-box.png","hash":"47ed9b93e71012e7ca06ed9602bc395fd0dd4d24","modified":1633352291880},{"_id":"source/images/DIY.jpg","hash":"9fce1ac994accf1dae0ef4aaa403099bc55e4a15","modified":1633352291886},{"_id":"source/images/bubble-girl.jpg","hash":"29d758d430822567c110adf56623b8af881c181e","modified":1633352291884},{"_id":"source/images/logo.fw.png","hash":"98f9b3a60c09e26e25f77702ce1049113b4b9a59","modified":1633352291883},{"_id":"source/images/meituan-fe-job.png","hash":"b971bdb4baad297044854c9bd22ed4b9d68f284e","modified":1633352291887},{"_id":"source/images/mouse.png","hash":"c8713d425fa472a85c79d38de0ab5e7362df2819","modified":1633352291886},{"_id":"source/images/office-2.jpg","hash":"c6ee8382028c023981c22cd32b67009b9c827cbd","modified":1633352291885},{"_id":"source/images/w3ctech-meituan.jpg","hash":"32d807ac8cde835985bba75a27fd8786eb426caf","modified":1633352291887},{"_id":"source/images/frontend-component-practice/component-flow.png","hash":"e1be377d2d93a39e5fe9ca393d1a3b04e08bff51","modified":1633352291878},{"_id":"source/images/frontend-component-practice/component-lifecycle.png","hash":"5e0705e3b2f663d4a9bf370868f196276798a185","modified":1633352291879},{"_id":"source/images/office-1.jpg","hash":"a41271ca57cb78c4344eed1f7c2814b4bc8d027c","modified":1633352291887},{"_id":"source/images/metro.png","hash":"da8f39f2122fbe1a3a3f5db128dd29988969fb09","modified":1633352291882},{"_id":"themes/even/.eslintrc","hash":"0fcde446104e73d7159f8574f28fe661acdb384e","modified":1633424575182},{"_id":"themes/even/.gitignore","hash":"32753aa9232f2d5dbf10b3fb8de8f1426f264ac1","modified":1633424575182},{"_id":"themes/even/.eslintignore","hash":"de3f06c672357f312d670c9fd9cc58c2b1a0864c","modified":1633424575181},{"_id":"themes/even/LICENSE","hash":"187fc7598698ac70c7ab9dffaa08883fd8b91958","modified":1633424575182},{"_id":"themes/even/.all-contributorsrc","hash":"5e55677518a2d881c8a27821381da925365a8efa","modified":1633424575181},{"_id":"themes/even/README.md","hash":"18d6bbd43b5bdf8875a2328a3ef5834e92e9cd96","modified":1633424575182},{"_id":"themes/even/_config.yml.example","hash":"a480a7e2a2750a2d83cb8cd443dafe3d37dda711","modified":1685458219023},{"_id":"themes/even/package.json","hash":"5906a7d9489a93b63dffe902b851118c80b84013","modified":1685458219027},{"_id":"themes/even/package-lock.json","hash":"e331b6c669a12ecbc89c6f3442698a71cdf1e478","modified":1649069555838},{"_id":"themes/even/_config.yml","hash":"ba6ec1f9abd7edf19a148f6a1329243c9b402236","modified":1649069475765},{"_id":"themes/even/languages/default.yml","hash":"42df6a0f6f21778f20779f6b0336df65a59c890d","modified":1633424575182},{"_id":"themes/even/languages/zh-CN.yml","hash":"f7da3fc6252df9d19abd1321b3c5a8c2ad13cca7","modified":1633424575182},{"_id":"themes/even/languages/zh-TW.yml","hash":"c275550aded8b4173f9965a627eedf1d727f3da3","modified":1633424575182},{"_id":"themes/even/layout/_layout.swig","hash":"00dc81c1d5751144a59de05db415c51954973230","modified":1633424575182},{"_id":"themes/even/layout/categories.swig","hash":"a14078a46bc45e1e02c1bc450dc894d693975707","modified":1633424575184},{"_id":"themes/even/layout/archive.swig","hash":"fde460d3c38ad132ef5effbdbaf66c48c8296c3b","modified":1633424575184},{"_id":"themes/even/layout/page.swig","hash":"a6cf4e5bc3cb9a9ea6a6ed3b074cff6d69073f14","modified":1633424575184},{"_id":"themes/even/layout/post.swig","hash":"88f3f7538c75271133d00f3b1a0d0a40ec953c8d","modified":1633424575184},{"_id":"themes/even/layout/tags.swig","hash":"ce15107017d6e1663f2b0be92d7758622e17861f","modified":1633424575184},{"_id":"themes/even/layout/index.swig","hash":"4bc20e7616ace7cf12c17328cb84b8203b763b09","modified":1633424575184},{"_id":"themes/even/.github/workflows/deploy.yml","hash":"c3451c1d908b860d071f670cde130ea4d0ba8e83","modified":1633424575182},{"_id":"themes/even/layout/_macro/archive.swig","hash":"641f02ccabc1cc59ecc73f2a40516088495e9ff9","modified":1633424575182},{"_id":"themes/even/layout/_macro/post.swig","hash":"671faa8fc3374ce900f57487d9e53bc8a5f2f592","modified":1633424575182},{"_id":"themes/even/layout/_script/analytics.swig","hash":"b1fe6eb7e42594383dba5e5a6a9ed655158e1f25","modified":1633424575184},{"_id":"themes/even/layout/_script/comments.swig","hash":"76b88bca6080243ee1054a98053b04db57d423d7","modified":1633424575184},{"_id":"themes/even/languages/en.yml","hash":"42df6a0f6f21778f20779f6b0336df65a59c890d","modified":1633424575182},{"_id":"themes/even/source/robots.txt","hash":"eed1ebad39b24e7942fcaf8f27da7487eb9f956e","modified":1633424575189},{"_id":"themes/even/layout/_script/theme.swig","hash":"ef8207e22d10ba11821749e1dc0041cf0104d7e3","modified":1633424575184},{"_id":"themes/even/layout/_partial/comments.swig","hash":"f60c042be03c113377900f6fd46635f50c1a3c80","modified":1633424575183},{"_id":"themes/even/layout/_script/counter.swig","hash":"fbd7b08c88440a5c174ec6c6be91a0236d63a3f0","modified":1685458219026},{"_id":"themes/even/layout/_script/push.swig","hash":"494cabb33f057de618e71eb163420d98320d4ed3","modified":1685458219026},{"_id":"themes/even/layout/_partial/footer.swig","hash":"418855b4ace54609431c52e091506e7a6180d433","modified":1633424575183},{"_id":"themes/even/layout/_partial/head.swig","hash":"b18d4f4b5ce4ea3c3ba5c3d4a1300f9fc3a5b15e","modified":1633424575183},{"_id":"themes/even/layout/_partial/pagination.swig","hash":"caab675c3c1df76d5c047d5c4dc42ffcb79caa9a","modified":1633424575183},{"_id":"themes/even/layout/_partial/header.swig","hash":"2c3a0fba88605a98b56528437e1c2160942cdba4","modified":1633424575183},{"_id":"themes/even/layout/_partial/slideout.swig","hash":"ecfaa8a922eef7d0c6eb05592d390ae36d6da9e3","modified":1633424575183},{"_id":"themes/even/source/css/_base.scss","hash":"ffd8c02b4e1dde0433458b0fef02f01a1fd0f1dd","modified":1633424575184},{"_id":"themes/even/layout/_script/_analytics/baidu-analytics.swig","hash":"707864f34f7750a438817acef927f1e4075c5cf8","modified":1633424575183},{"_id":"themes/even/layout/_script/_analytics/google-analytics.swig","hash":"5143d9e510bfd98723a009780ba23aebade21b29","modified":1633424575183},{"_id":"themes/even/layout/_script/_comments/changyan.swig","hash":"a14f06c0ab2eff5c1039cbf199328a62fdc3def8","modified":1633424575183},{"_id":"themes/even/layout/_script/_comments/cusdis.swig","hash":"8bc1430e52c7ba6700430628df1fc7d8b7c6b0c3","modified":1633424575183},{"_id":"themes/even/layout/_script/_comments/disqus.swig","hash":"52009d5092377937af79ea9e391262d34df6d36f","modified":1633424575183},{"_id":"themes/even/source/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1633424575186},{"_id":"themes/even/layout/_script/_comments/livere.swig","hash":"dfc42123f637b775cf85967476cb8439d19dbe4c","modified":1633424575183},{"_id":"themes/even/layout/_script/libs.swig","hash":"668e0939e5c22bcf5437afdd398a7fd16c0059a0","modified":1633424575184},{"_id":"themes/even/layout/_script/_comments/utterances.swig","hash":"5772689ec4c0a772d0e51311535080544fcb2bdd","modified":1633424575184},{"_id":"themes/even/layout/_script/_comments/gitalk.swig","hash":"869e4e4bca23ccd9be61fa671dd2b327b5b6e86c","modified":1633424575183},{"_id":"themes/even/layout/_partial/_footer/social.swig","hash":"45159378a4abd916367a5a10cf39eabb0d460c70","modified":1633424575182},{"_id":"themes/even/layout/_partial/_head/meta.swig","hash":"067665118c38c2f579f801ff53bab0d32b28109c","modified":1633424575183},{"_id":"themes/even/layout/_partial/_post/copyright.swig","hash":"517533bf6cb5292a55be11036ef72d699acc33ef","modified":1633424575183},{"_id":"themes/even/layout/_partial/_post/reward.swig","hash":"2a026a5252082c5cc9fbbb5aedf29770d1d56e62","modified":1633424575183},{"_id":"themes/even/source/css/_variables.scss","hash":"a32d1aa88bf6c81af01a0ad87d0cdc9beb17bfa1","modified":1633424575186},{"_id":"themes/even/source/css/style.scss","hash":"814c81baf2d6fe1acdaf5319c3fa796c260a2d3c","modified":1633424575186},{"_id":"themes/even/layout/_partial/_post/toc.swig","hash":"3eb2de1ad24607af9497663149730292227022cf","modified":1633424575183},{"_id":"themes/even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1633424575184},{"_id":"themes/even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1633424575184},{"_id":"themes/even/source/css/_common/_utils.scss","hash":"9ec5b1f6cf47260eba2729ff4931111b808644f0","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_archive.scss","hash":"c0cd7dc3462f7726428a30f5852fcf5577df5961","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_back-to-top.scss","hash":"de94a4546dad90f588e902c9641d94b31fd6625b","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_header.scss","hash":"4a3e92feef33bed0021f1a65a801c24ee7d5946f","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_iconfont.scss","hash":"6effdc886469ee76f3c66451ef4b04baaecd48ef","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_mathjax.scss","hash":"4005390d40cfc457e4d07dbaf78b718e01b651f4","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_mobile.scss","hash":"0d1c60bd92f8e5db01e7843934251152ec4d6d44","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_post.scss","hash":"655e8f56328a220b64d54c400990165a015fecd9","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_slideout.scss","hash":"e4820a42698f647a824575b234835b9ce4ac4797","modified":1633424575186},{"_id":"themes/even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1633424575186},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1633424575186},{"_id":"themes/even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1649069402126},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1633424575187},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1633424575187},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1633424575187},{"_id":"themes/even/source/js/src/even.js","hash":"e15f39b54da71226e8dca3fa2fa9be8dda1f5e75","modified":1633424575187},{"_id":"themes/even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1633424575187},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1633424575187},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1633424575187},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1633424575188},{"_id":"themes/even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_header/_logo.scss","hash":"109073dde15146d835bf06faa2f256d1ac658315","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_header/_menu.scss","hash":"454214ab2b5a0ca17d6872068c52bfd01ac02fdc","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_post/_code.scss","hash":"4accdb9fdda9818c700ce309f28575de18e04228","modified":1633424575185},{"_id":"themes/even/source/css/_partial/_post/_copyright.scss","hash":"3a53f708b9dec34426460e3ad7cb29c335e1f7b8","modified":1633424575186},{"_id":"themes/even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1633424575186},{"_id":"themes/even/source/css/_partial/_post/_reward.scss","hash":"66ec9faa27ed879dc9a2ca59c73ed6bfd5e61dcd","modified":1633424575186},{"_id":"themes/even/source/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1633424575189},{"_id":"themes/even/source/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1633424575189},{"_id":"themes/even/source/css/_partial/_post/_header.scss","hash":"f655fc254804e59d1426471f41127f26d06432b6","modified":1633424575186},{"_id":"themes/even/source/css/_partial/_post/_toc.scss","hash":"5806ce8d5c4e2d70e12e03ab48327bdebc68c67b","modified":1633424575186},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1633424575188},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1633424575188},{"_id":"themes/even/source/css/_partial/_post/_content.scss","hash":"7cf29c7af82c31d82f09dedfca09ea2d863b92ff","modified":1637675681286},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1633424575187},{"_id":"themes/even/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1633424575189},{"_id":"source/images/frontend-component-practice/component-flux.png","hash":"7cb86d2125e668a9c434ef0d31b62105bf13601e","modified":1633352291879},{"_id":"public/atom.xml","hash":"33e5b0b5e7c713637999535f451186e59fceab52","modified":1685457651666},{"_id":"public/tags/index.html","hash":"d4ca22ab9e4bc4e436e328aaade6b7bc9ef1f260","modified":1685458231537},{"_id":"public/hire-slow/index.html","hash":"5a1534b280d2aa5b9d6984c6477213dabb170036","modified":1685458231537},{"_id":"public/frontend-frp-2nd/index.html","hash":"96f510395a330a39bac1c411cfadc5fa1726878a","modified":1685458231537},{"_id":"public/frontend-frp/index.html","hash":"42e4e36d6d57385e8b379819156287868a406820","modified":1685458231537},{"_id":"public/recruitment-driven-organization/index.html","hash":"af029a6c0b26abe2154ff32fc5dec64e34884541","modified":1685458231537},{"_id":"public/react-hooks/index.html","hash":"a1a0927465a93674d20812f084701841afa97075","modified":1685458231537},{"_id":"public/typescript-advanced/index.html","hash":"fe0474b0954d560709d1501677e60a4a6b313acd","modified":1685458231537},{"_id":"public/the-awakeing-age/index.html","hash":"15830e73228b70500d8716ead576b671a6b75ddc","modified":1685458231537},{"_id":"public/typescript-101/index.html","hash":"41dd066fb106f5f46a88050a9b694f78df338239","modified":1685458231537},{"_id":"public/monad/index.html","hash":"8dd98d9b0009e3ed703b8e6128b5ceabcb8e01c9","modified":1685458231537},{"_id":"public/js-linter-history/index.html","hash":"17d91a5e7e594785195484ea9966add09d2562a5","modified":1685458231537},{"_id":"public/continuation/index.html","hash":"fe4c6de54b32f2d067a6c292a7529df433fd92ee","modified":1685458231537},{"_id":"public/react-design-highlights/index.html","hash":"c9494a9a9e43ff94487025e99cb23fa58e8822dd","modified":1685458231537},{"_id":"public/fe-pipeline/index.html","hash":"991ab22216517e5866e03bc55901bed298820772","modified":1685458231537},{"_id":"public/diff-great-software-engineer-from-a-good/index.html","hash":"5eb75b8a7cb2c5b12b28c6272f9236c6504403f4","modified":1685458231537},{"_id":"public/yui3-in-meituan/index.html","hash":"7ab3dab8425fee40f7a716596c6a34ee160aced8","modified":1685458231537},{"_id":"public/change-theme/index.html","hash":"135cf85cf2208ba684cd442493f8ccc1aaf3f93e","modified":1685458231537},{"_id":"public/w3ctech-meituan/index.html","hash":"de891d9bb9971d99e57658272b7ba027bedcb4d4","modified":1685458231537},{"_id":"public/yui-domready-after-load/index.html","hash":"32e251a66ad52b1dbc3eb72a209c8924c3629a6d","modified":1685458231537},{"_id":"public/event-note/index.html","hash":"8ae92f1f035a9cbba3b1f2d4999c42aea15ae17e","modified":1685458231537},{"_id":"public/birth/index.html","hash":"b2f3b02a7583ffbea8dc9d7139d0d2d6a4c33a8f","modified":1685458231537},{"_id":"public/archives/index.html","hash":"e660b2a58b9c6091f3e4027c6390a66241717f85","modified":1685458231537},{"_id":"public/archives/page/2/index.html","hash":"3d39b37b5d32c857b881075668949f04c7a71318","modified":1685458231537},{"_id":"public/scope-safe-constructor/index.html","hash":"d367861f6b819f3425dc92d9a37e966528e6fc8d","modified":1685458231537},{"_id":"public/archives/page/3/index.html","hash":"34e2780b8690ff5258f0222e48f2e7f9842632b6","modified":1685458231537},{"_id":"public/archives/page/4/index.html","hash":"a6373446c64b6221c117d9a18c3f1558a50bb388","modified":1685458231537},{"_id":"public/archives/2011/index.html","hash":"abec504dfa8c5b56adecee97ff2a8c6ad07e0bce","modified":1685458231537},{"_id":"public/archives/2011/page/2/index.html","hash":"7e4b2132d199920d51d24ee7a83c5346cc095fc2","modified":1685458231537},{"_id":"public/archives/2011/03/index.html","hash":"4cca8c3e8256789e9ad930cfc42b0fdaf9a5bef7","modified":1685458231537},{"_id":"public/archives/2011/08/index.html","hash":"246caf83be901282662416691c6e8dd93e1e9e80","modified":1685458231537},{"_id":"public/archives/2011/05/index.html","hash":"e03621026f8956c35a816e1f67f984516006491e","modified":1685458231537},{"_id":"public/archives/2011/06/index.html","hash":"062060067f204b3a707ee7696e1d085a0029a17b","modified":1685458231537},{"_id":"public/archives/2011/12/index.html","hash":"623ede9b3c0efa1d76e25b76ce99ee3b8b758073","modified":1685458231537},{"_id":"public/archives/2012/index.html","hash":"fccf027a2c209b1d5e596de46aaecaf0e1df01c2","modified":1685458231537},{"_id":"public/archives/2012/02/index.html","hash":"5fdd53646eb3b5fe9137d868f87b19c4b6ac9f38","modified":1685458231537},{"_id":"public/archives/2012/07/index.html","hash":"8b12387d104293bdf2515cda755c483b32cc3f41","modified":1685458231537},{"_id":"public/archives/2011/11/index.html","hash":"84bee001ab67cf501c1bf98c353d2abfc3b11b83","modified":1685458231537},{"_id":"public/archives/2012/11/index.html","hash":"251524fb0500da333339f51113c62e5a8aa5d1b7","modified":1685458231537},{"_id":"public/archives/2013/01/index.html","hash":"ee4a8690ea75cb31cc1f53b5cc9521d5939a3b0b","modified":1685458231537},{"_id":"public/archives/2013/index.html","hash":"6acf3c2c947179e80a53c536b01bff83882d8699","modified":1685458231537},{"_id":"public/archives/2012/09/index.html","hash":"f5dac38c8291b47a40b510e29954a49910a300bd","modified":1685458231537},{"_id":"public/archives/2013/04/index.html","hash":"bb6052c5ff5a570863e10efa26ad90afaece766b","modified":1685458231537},{"_id":"public/archives/2014/index.html","hash":"627e0b54b840f4249786d9af642f50e8844430f7","modified":1685458231537},{"_id":"public/archives/2014/02/index.html","hash":"461fc8ba73750740ad841c581f3bbe729e5b11bd","modified":1685458231537},{"_id":"public/archives/2013/10/index.html","hash":"77740f55287fc024780bc4d45efa517ac299af73","modified":1685458231537},{"_id":"public/archives/2013/05/index.html","hash":"a4e42997dff88ea3d5c12a65ae07cac3c2a50d49","modified":1685458231537},{"_id":"public/archives/2014/05/index.html","hash":"0ee7000d5f79d4e1e05309d6184e61cfbb4985d8","modified":1685458231537},{"_id":"public/archives/2015/index.html","hash":"ac5280f57bae5656d2e9a56a8203cba551d85727","modified":1685458231537},{"_id":"public/archives/2015/06/index.html","hash":"3d420c8e2983c1c22021be63619f1f27f77b00fd","modified":1685458231537},{"_id":"public/archives/2015/10/index.html","hash":"1742dc07e2e71ac40928ad49d2db2e30197fa13e","modified":1685458231537},{"_id":"public/archives/2017/index.html","hash":"3d79b40ad265be9c010d9f98ab2554ae4dae2785","modified":1685458231537},{"_id":"public/archives/2017/10/index.html","hash":"aae274193f428a63e8a955c7a95e9bd01a3a3608","modified":1685458231537},{"_id":"public/archives/2018/index.html","hash":"6841e9a9f5dfdc6ac9dfca994c62d2da87c20c9e","modified":1685458231537},{"_id":"public/archives/2018/05/index.html","hash":"f6e30439f244ba18c7d762919f1b048b65b85012","modified":1685458231537},{"_id":"public/archives/2018/01/index.html","hash":"4a2e6b788617447f99a732231d351c697a4e466f","modified":1685458231537},{"_id":"public/archives/2018/10/index.html","hash":"e87f19357eed4cd9f82fec5c27e547eb81fc4b86","modified":1685458231537},{"_id":"public/archives/2019/index.html","hash":"cd0b8b0e365a25a36b80dcad479d4ef1355c5c83","modified":1685458231537},{"_id":"public/archives/2019/06/index.html","hash":"ca116ca5e41c44919f6c3564241846a6961f9c3b","modified":1685458231537},{"_id":"public/archives/2020/05/index.html","hash":"efde2a405a8a1418e5b464b02bee9016676eb3a8","modified":1685458231537},{"_id":"public/archives/2021/index.html","hash":"3a380f7ff5cc8fff53d8395f9738d080fc4c452b","modified":1685458231537},{"_id":"public/archives/2020/index.html","hash":"a27893c4f88cdc288364c128877399b2a65a9b0f","modified":1685458231537},{"_id":"public/archives/2021/05/index.html","hash":"4fb978ad585ef6d132a40120d9185e5354aff59d","modified":1685458231537},{"_id":"public/archives/2021/08/index.html","hash":"8a9ae9866ab816bf51398f8d0d42e7b3a3f2e69d","modified":1685458231537},{"_id":"public/archives/2021/11/index.html","hash":"7de9203ef354238414322a7846513286aeb07323","modified":1685458231537},{"_id":"public/archives/2022/index.html","hash":"0b544f9a77b4e71fcba9a34fe89b92fcd12c25b5","modified":1685458231537},{"_id":"public/archives/2022/01/index.html","hash":"4f627a88efe8be8aa0679f1f9a9234f09f4cd4f2","modified":1685458231537},{"_id":"public/archives/2022/03/index.html","hash":"d3bdc96e133d90b0f98bc0293fe631e7e1d300db","modified":1685458231537},{"_id":"public/archives/2022/04/index.html","hash":"e97dec8f9e8038c46abf3f16b51a9282586d78c4","modified":1685458231537},{"_id":"public/index.html","hash":"71810765fb2a5f073ab2856e859293a6289b0ec9","modified":1685458231537},{"_id":"public/tags/Self/index.html","hash":"8f1221f215930c14e0a30d2805779b50d7f75ca4","modified":1685458231537},{"_id":"public/tags/Life/index.html","hash":"2bd319d293f963b25b4025350d1d5db84d609749","modified":1685458231537},{"_id":"public/tags/Metro/index.html","hash":"6dd0d1ef07016c4d3302c08ed4ff598cd4985740","modified":1685458231537},{"_id":"public/tags/BitwiseNOT/index.html","hash":"99081f32f5a7d387b28b2f01e062112e9535756f","modified":1685458231537},{"_id":"public/tags/LogicalNOT/index.html","hash":"231ecde6e7e02474ad2ccf1453d08aa666638006","modified":1685458231537},{"_id":"public/tags/JavaScript/index.html","hash":"234c8a0974eb8c78d6c70500292a7216de12eaf2","modified":1685458231537},{"_id":"public/tags/Functional-Programming/index.html","hash":"1f4d70e163ed86cbf97a09c0aaa37dd60d7f34d4","modified":1685458231537},{"_id":"public/tags/Continuation/index.html","hash":"bbc53b2ede785d366cd7d25ace56adb8d2e91e24","modified":1685458231537},{"_id":"public/tags/Promise/index.html","hash":"f82718dc0d25a5033859597c373476009a8299bd","modified":1685458231537},{"_id":"public/tags/Y-delegate/index.html","hash":"4f96e9db8d6c2f946f8834ce5873afff80cc9436","modified":1685458231537},{"_id":"public/tags/YUI/index.html","hash":"73ba37dafc9f657ce5775be5031c3515ba129e4b","modified":1685458231537},{"_id":"public/tags/Programming/index.html","hash":"4bb43d848e30d08c1f320e53370eac53af587358","modified":1685458231537},{"_id":"public/tags/YUI/page/2/index.html","hash":"afd665df19f156938d49cc61804fdc0629aa3765","modified":1685458231537},{"_id":"public/tags/Event/index.html","hash":"94f5d0d9125020a4dcece6d4fae266ec7a891638","modified":1685458231537},{"_id":"public/tags/Y-Event/index.html","hash":"c17d8ca5fac351d226dba64ab72380618aabbe10","modified":1685458231537},{"_id":"public/tags/OOP/index.html","hash":"31a5b5bb8023450081cddb948f8fd8d979f50a02","modified":1685458231537},{"_id":"public/tags/Middleware/index.html","hash":"f03d0cfaed305e1d3321db97818bc0fa8ce8002d","modified":1685458231537},{"_id":"public/tags/Pipeline/index.html","hash":"77094e94cd989e2afdd9cab65b25ca0803c25731","modified":1685458231537},{"_id":"public/tags/Stream/index.html","hash":"591bb876fd2fe815e101af0f0b9e6d4ff403e831","modified":1685458231537},{"_id":"public/tags/FrontEnd/index.html","hash":"539d926872276e9b4c8b7bc96cf7324665fe301c","modified":1685458231537},{"_id":"public/tags/front-end/index.html","hash":"abce4d46ac84f848d92da13188435f52db9158c3","modified":1685458231537},{"_id":"public/tags/component/index.html","hash":"a2fb437e7155161387824f2e8179e2a08be9f8b9","modified":1685458231537},{"_id":"public/tags/reduce/index.html","hash":"de5ee4129e749d6a19f352a6bf26bd62a39c4073","modified":1685458231537},{"_id":"public/tags/Recruitment/index.html","hash":"72277a90f43c7aa87518cc73d3c709afb4f9538d","modified":1685458231537},{"_id":"public/tags/Functional-Reactive-Programming/index.html","hash":"c839e73fe155fa811c734c36eca12422d7acdd6f","modified":1685458231537},{"_id":"public/tags/RxJS/index.html","hash":"af26ba5b3b79987d6a1ec25e04fc58be9c1947df","modified":1685458231537},{"_id":"public/tags/Organization/index.html","hash":"ff7a7913396073346038ef062d0967fb957b4b01","modified":1685458231537},{"_id":"public/tags/Closure/index.html","hash":"d58dd4e41cf157f59f160a250d583223ca9a1397","modified":1685458231537},{"_id":"public/tags/Execution-Context/index.html","hash":"4794a422a1b21247b99b23b81b1fa64ae2010d9a","modified":1685458231537},{"_id":"public/tags/turbo/index.html","hash":"48b5e0eb291b827adc20a7a86e7b12fe6ee83602","modified":1685458231537},{"_id":"public/tags/Interview/index.html","hash":"3f3e677a43c9446ba88fd40bd324a4a1d3f9509e","modified":1685458231537},{"_id":"public/tags/Prototype-Chain/index.html","hash":"8836abb86cc8a4555b670ddbc9157e3f1c9d06c9","modified":1685458231537},{"_id":"public/tags/Linter/index.html","hash":"2fa95cd0eeef76fe7eac09f8e754e26f6744075e","modified":1685458231537},{"_id":"public/tags/ESLint/index.html","hash":"de56e60171fe959e8638f59083fa03b0337c1365","modified":1685458231537},{"_id":"public/tags/JSLint/index.html","hash":"d6a9ba0a7a4f1c0a874f4fda0934d20dcdb66fbe","modified":1685458231537},{"_id":"public/tags/React/index.html","hash":"ec7ce17fb25b17a186684f931c95aa060926da60","modified":1685458231537},{"_id":"public/tags/Virtual-DOM/index.html","hash":"828bbd877315fb67ffebbcb6babd2acac6e4c676","modified":1685458231537},{"_id":"public/tags/Fiber/index.html","hash":"4fe7ccc35a58f34ee95cc650c6d7fc73ccb2dc2b","modified":1685458231537},{"_id":"public/tags/Monad/index.html","hash":"cca72868dd060953c11ac2d2c0991125c18e994c","modified":1685458231537},{"_id":"public/tags/Hooks/index.html","hash":"fb38d0067234b568a20d9d3e48c248c20213062f","modified":1685458231537},{"_id":"public/tags/try-cacth/index.html","hash":"50d7fa41e1b8c3f39255491d0637b508a2958953","modified":1685458231537},{"_id":"public/tags/onerror/index.html","hash":"ac5f1a1afc19753667ab68cfa89dc8a8cead49a9","modified":1685458231537},{"_id":"public/tags/Web/index.html","hash":"c9f0b89972b986b40c981764c0522ff4195deb90","modified":1685458231537},{"_id":"public/tags/Series/index.html","hash":"c94b81311300a1fc7593177c2c2c2b6a8e7b3ce5","modified":1685458231537},{"_id":"public/tags/Review/index.html","hash":"a6f6497bdd284df5e320c01fba2ca59ff22dd723","modified":1685458231537},{"_id":"public/tags/TypeScript/index.html","hash":"1d874cf057b22a74f6aa17759fd3b84593f4fc74","modified":1685458231537},{"_id":"public/tags/W3CTech/index.html","hash":"54f5373e91dccc30e4575b1535905f276cbc643b","modified":1685458231537},{"_id":"public/tags/Type-System/index.html","hash":"6e65eeec96c035930c7c320377e57cc90fc3fbdd","modified":1685458231537},{"_id":"public/tags/Meituan/index.html","hash":"f04140c547edf8656dfcdff5f67608427ced5870","modified":1685458231537},{"_id":"public/tags/YUI2/index.html","hash":"683ab440bd3c5bd71b0d756006f295d609415281","modified":1685458231537},{"_id":"public/tags/This/index.html","hash":"40bfd18826523d2ae0a3192e8a0be894069135a6","modified":1685458231537},{"_id":"public/tags/domready/index.html","hash":"cde3d37828b10f589d98f72ddd408ec2507003e3","modified":1685458231537},{"_id":"public/tags/Scope-safe-Constructor/index.html","hash":"38991814f89678a733e0d8da09bd65cf39817465","modified":1685458231537},{"_id":"public/tags/load/index.html","hash":"2aad3b94abf0cfef7254da3fe29b8c740009ca97","modified":1685458231537},{"_id":"public/tags/Framework/index.html","hash":"eb52ce4a1733b4922117353bf828807fd1948245","modified":1685458231537},{"_id":"public/tags/Instanceof/index.html","hash":"62ab4c40189c1eda42e9bf4852bab46012c4989b","modified":1685458231537},{"_id":"public/interview-is-bidirectional/index.html","hash":"06e13a9261b1dada8c6000ff3409e29d2a8c341e","modified":1685458231537},{"_id":"public/promise-insight/index.html","hash":"6e98bf32a5a759093161c95ec0409d75d8049055","modified":1685458231537},{"_id":"public/frontend-component-practice/index.html","hash":"10aefdc2b39c3887f09a3f6697991d5c7b67db4f","modified":1685458231537},{"_id":"public/bitwise-not-and-logical-not/index.html","hash":"51d1d6dffffbf6aa52fc200193464a7515169239","modified":1685458231537},{"_id":"public/yui3-event-default-action/index.html","hash":"62d679120620b3eddc11f09f0dcb75d1c7d20fa1","modified":1685458231537},{"_id":"public/event-delegate/index.html","hash":"5f6b29a46f0c40c72ff7035bd088f1881544427f","modified":1685458231537},{"_id":"public/yui3-practice/index.html","hash":"9b2d83cf379554d84cace9d19d9fe51bf2713ddd","modified":1685458231537},{"_id":"public/event/index.html","hash":"f08b420b0cee6ec191f565c34c9492aece08c7e8","modified":1685458231537},{"_id":"public/event-do/index.html","hash":"977c0ed36e90718c7843a9ca21b0e20aa4af40d2","modified":1685458231537},{"_id":"public/event-custom/index.html","hash":"34ce5ae9ac5fa32bbfac593b8a0f33fa668b2381","modified":1685458231537},{"_id":"public/event-target/index.html","hash":"618bdd0b41fc38ae85e0348a332ff8afc6732022","modified":1685458231537},{"_id":"public/extend-and-augment/index.html","hash":"e5fa6923e94ad5a203d3eb6ff084b79322ba8c55","modified":1685458231537},{"_id":"public/javascript-the-core/index.html","hash":"8009df5b45485e86937498a46b84dfa38e51cb6d","modified":1685458231537},{"_id":"public/js-error-catch/index.html","hash":"ed6b46620dc7f13e3f8e74181b90cc532a68a3a9","modified":1685458231537},{"_id":"public/understanding-this-keyword/index.html","hash":"d943b3f2a20a1faabaad83a4ddc332b74eaba28c","modified":1685458231537},{"_id":"public/yui3-intro/index.html","hash":"32cffd198fe0fd32de8067cb537a8818acbb4218","modified":1685458231537},{"_id":"public/page/3/index.html","hash":"3736fb9057f953a8039fb17262d807f8ca943dd6","modified":1685458231537},{"_id":"public/page/4/index.html","hash":"f21b305b84d6279c707ada0c09697fa43fb83f84","modified":1685458231537},{"_id":"public/page/2/index.html","hash":"34fbdd4fceed91cbc91051b1375597a1316080b5","modified":1685458231537},{"_id":"public/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1685458231537},{"_id":"public/robots.txt","hash":"eed1ebad39b24e7942fcaf8f27da7487eb9f956e","modified":1685458231537},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1685458231537},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1685458231537},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1685458231537},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1685458231537},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1685458231537},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1685458231537},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1685458231537},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1685458231537},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1685458231537},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1685458231537},{"_id":"public/images/banner-top1.jpg","hash":"4b46871a95c8d3b39be80d2ffccc580e4ff7a9ad","modified":1685455148264},{"_id":"public/images/error-flow.png","hash":"52eb57177722fb807ae7e9ef4ded99ba71a34488","modified":1685455148264},{"_id":"public/images/delegate.jpg","hash":"9d20c5d0d13198f6a740def2929307d21661d2a1","modified":1685455148264},{"_id":"public/images/logo.png","hash":"231f5c3497e309892a05ebd464323958daa9aedb","modified":1685455148264},{"_id":"public/images/event-default-action.png","hash":"845446ba8a406949526fdb39287514f6c2e45c23","modified":1685455148264},{"_id":"public/images/notSevenDay1.png","hash":"8888259d6a71b648a7100e498229f828a34c42b8","modified":1685455148264},{"_id":"public/images/panweizeng.jpeg","hash":"433ee71fca427066c527a85499ded84b5a691f1f","modified":1685455148264},{"_id":"public/images/mt-fe-architecture.png","hash":"f89aeec23af2771d693575b96d0f5453ad08e94b","modified":1685455148264},{"_id":"public/images/promise-series-simple-flow.png","hash":"6c3d0af641e2928c232d3ac7d11f4554bcdf1a64","modified":1685455148264},{"_id":"public/images/promise-states-flow.png","hash":"b2e160b9ab569149b887d458f329bce9a49c0d42","modified":1685455148264},{"_id":"public/images/promise-series-flow.png","hash":"8213fdcaab3ca6a3b30a4c9e21d6a8ae56df8d4d","modified":1685455148264},{"_id":"public/images/zhangmengxuan.jpg","hash":"63b74f005c01cb72c17e00e0c5a65d433ac62730","modified":1685455148264},{"_id":"public/images/zhiyelee.png","hash":"2c2fd9e9fad2314a027c37dff1ecfeb7c90cc037","modified":1685455148264},{"_id":"public/images/frontend-component-practice/smart-box.png","hash":"47ed9b93e71012e7ca06ed9602bc395fd0dd4d24","modified":1685455148264},{"_id":"public/images/frontend-component-practice/legacy-flow.png","hash":"c220c2158875c6787aa2f7d37e59d0387c227107","modified":1685455148264},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1685458231537},{"_id":"public/images/DIY.jpg","hash":"9fce1ac994accf1dae0ef4aaa403099bc55e4a15","modified":1685455148264},{"_id":"public/images/bubble-girl.jpg","hash":"29d758d430822567c110adf56623b8af881c181e","modified":1685455148264},{"_id":"public/images/meituan-fe-job.png","hash":"b971bdb4baad297044854c9bd22ed4b9d68f284e","modified":1685455148264},{"_id":"public/images/logo.fw.png","hash":"98f9b3a60c09e26e25f77702ce1049113b4b9a59","modified":1685455148264},{"_id":"public/images/office-2.jpg","hash":"c6ee8382028c023981c22cd32b67009b9c827cbd","modified":1685455148264},{"_id":"public/images/mouse.png","hash":"c8713d425fa472a85c79d38de0ab5e7362df2819","modified":1685455148264},{"_id":"public/images/w3ctech-meituan.jpg","hash":"32d807ac8cde835985bba75a27fd8786eb426caf","modified":1685455148264},{"_id":"public/images/frontend-component-practice/component-lifecycle.png","hash":"5e0705e3b2f663d4a9bf370868f196276798a185","modified":1685455148264},{"_id":"public/images/frontend-component-practice/component-flow.png","hash":"e1be377d2d93a39e5fe9ca393d1a3b04e08bff51","modified":1685455148264},{"_id":"public/js/src/even.js","hash":"e15f39b54da71226e8dca3fa2fa9be8dda1f5e75","modified":1685458231537},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1685458231537},{"_id":"public/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1685458231537},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1685458231537},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1685458231537},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1685458231537},{"_id":"public/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1685458231537},{"_id":"public/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1685458231537},{"_id":"public/images/office-1.jpg","hash":"a41271ca57cb78c4344eed1f7c2814b4bc8d027c","modified":1685455148264},{"_id":"public/images/metro.png","hash":"da8f39f2122fbe1a3a3f5db128dd29988969fb09","modified":1685455148264},{"_id":"public/images/frontend-component-practice/component-flux.png","hash":"7cb86d2125e668a9c434ef0d31b62105bf13601e","modified":1685455148264},{"_id":"public/css/style.css","hash":"8c9a5aa3a059fad95125f5f6a7a03bb9ca61f041","modified":1685458231537},{"_id":"source/_posts/fire-fast.md","hash":"c5b7861408c0214aa6e63e22680aa5a895e86329","modified":1651550389290},{"_id":"source/_posts/react-query.md","hash":"a33092dbde1cddbe319e50640b984f4f6e4d58a0","modified":1656291280679},{"_id":"public/react-query/index.html","hash":"39f8d03974132069b450cb4859c3a673cde5c79b","modified":1685458231537},{"_id":"public/fire-fast/index.html","hash":"a077ef947a6bcc5e6fdc643d0f165550d9c86217","modified":1685458231537},{"_id":"public/archives/2022/06/index.html","hash":"407da62e2fd0f3beae574c282fab90807fde1fc0","modified":1685458231537},{"_id":"public/archives/2022/05/index.html","hash":"8f79d3400bc92797c0058c7bd7510eb6d0e09ebf","modified":1685458231537},{"_id":"public/tags/React-Query/index.html","hash":"77cb334533978caa812e36730873dc7fcb17bf0f","modified":1685458231537},{"_id":"source/_posts/management-leverage.md","hash":"af47223f28d0324c4981cdc8fcb4a7834d5eb0dd","modified":1660354270199},{"_id":"themes/even/yarn.lock","hash":"ff5d63b50f76b4b6f36661c012ffca2af7ba9dff","modified":1637675681299},{"_id":"public/management-leverage/index.html","hash":"f20076b8347e3d982f2c1f1996337bbbd282f5c5","modified":1660354302598},{"_id":"public/archives/2022/07/index.html","hash":"646969df5652633393a330a910cbd43b5311bcec","modified":1685458231537},{"_id":"source/_posts/management-lever.md","hash":"e8e89daec83bbec7b4c68df7d2d1fc675ec60df8","modified":1660355537954},{"_id":"public/tags/Management/index.html","hash":"8781e28eecf47adef8869f6ebad18ba7af753b6e","modified":1685458231537},{"_id":"public/tags/Lever/index.html","hash":"2c604dbd17c3ce9c40fe10b364ddddfd9b4975cd","modified":1685458231537},{"_id":"public/management-lever/index.html","hash":"17fab1dc2dedf62b076b63ecc995afd37f4505aa","modified":1685458231537},{"_id":"source/_posts/ask-with-answers.md","hash":"0d837d034ea94ec731131471c1bb5722849f4342","modified":1685456217616},{"_id":"public/ask-with-answers/index.html","hash":"eaa1b5c036dac32a95f3d1bd78986d04e879403f","modified":1685458231537},{"_id":"public/archives/page/5/index.html","hash":"c9d8999f003930542bfe72236930105e6b0a8235","modified":1685458231537},{"_id":"public/archives/2023/index.html","hash":"927aefe0901cd48a70dfea9c606b177c397cf3d6","modified":1685458231537},{"_id":"public/archives/2023/05/index.html","hash":"51ef78ba77deec1ff4ddff50e7cfc92fe90fafad","modified":1685458231537},{"_id":"public/page/5/index.html","hash":"0ff96d9507d64933335e784e7d66ab4d20b1af6c","modified":1685458231537},{"_id":"public/tags/Communication/index.html","hash":"0be7614b6f30cac2b34d3ac797efd9561c77592c","modified":1685458231537},{"_id":"public/tags/Asking/index.html","hash":"e18a7d0ff322fd37ebeb6c0aead2a6e89a945742","modified":1685458231537},{"_id":"source/_posts/react-context.md","hash":"0e5ac5033c331730a858200d7b103d4554935c7d","modified":1685457642936},{"_id":"public/react-context/index.html","hash":"a42f5ee97b016fbd41acd0ba51bf9e26b8ea9774","modified":1685458231537},{"_id":"public/archives/2023/03/index.html","hash":"496e6a7f3a6a7f003bca4829f03ecd594b4c1c68","modified":1685458231537},{"_id":"public/tags/Context/index.html","hash":"03adb39c8cc8fb258cbdb4e265d59e19be845b6d","modified":1685458231537},{"_id":"public/tags/useContextSelector/index.html","hash":"5bfc1e42975f0d02e4eb3b41f8a7a6c395f58f1b","modified":1685458231537}],"Category":[],"Data":[],"Page":[{"title":"Tags","date":"2021-11-25T04:12:45.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2021-11-25 12:12:45\nlayout: \"tags\"\ncomments: false\n---\n","updated":"2021-11-25T07:45:35.976Z","path":"tags/index.html","_id":"cl1klguoy00008e85e86oea6a","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"创世纪","date":"2011-03-10T05:35:00.000Z","status":"publish","_content":"\n至此，自己的blog终于搭了起来。\n\n过程并不算复杂，不过还是需要一定的热情。\n\n建站的初衷源于个人积累的一些诉求，希望能够将一些日常的idea或problem经过思维的处理沉淀成一直留守的文字，无论何时何地何人，看到它们时都会有一些收获或感想。\n\n不追求能有很多人来看，我把这里当成自己的自留地，肆意非常。\n\n持续的写作需要极大热忱，希望我能保持。\n","source":"_posts/birth.md","raw":"---\nlayout: post\ntitle: \"创世纪\"\ndate: 2011-03-10 13:35\nstatus: publish\ntags: [Self, Life]\n---\n\n至此，自己的blog终于搭了起来。\n\n过程并不算复杂，不过还是需要一定的热情。\n\n建站的初衷源于个人积累的一些诉求，希望能够将一些日常的idea或problem经过思维的处理沉淀成一直留守的文字，无论何时何地何人，看到它们时都会有一些收获或感想。\n\n不追求能有很多人来看，我把这里当成自己的自留地，肆意非常。\n\n持续的写作需要极大热忱，希望我能保持。\n","slug":"birth","published":1,"updated":"2021-10-04T12:57:16.035Z","comments":1,"photos":[],"link":"","_id":"cl1klgup100018e853wvtdzqz","content":"<p>至此，自己的blog终于搭了起来。</p>\n<p>过程并不算复杂，不过还是需要一定的热情。</p>\n<p>建站的初衷源于个人积累的一些诉求，希望能够将一些日常的idea或problem经过思维的处理沉淀成一直留守的文字，无论何时何地何人，看到它们时都会有一些收获或感想。</p>\n<p>不追求能有很多人来看，我把这里当成自己的自留地，肆意非常。</p>\n<p>持续的写作需要极大热忱，希望我能保持。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>至此，自己的blog终于搭了起来。</p>\n<p>过程并不算复杂，不过还是需要一定的热情。</p>\n<p>建站的初衷源于个人积累的一些诉求，希望能够将一些日常的idea或problem经过思维的处理沉淀成一直留守的文字，无论何时何地何人，看到它们时都会有一些收获或感想。</p>\n<p>不追求能有很多人来看，我把这里当成自己的自留地，肆意非常。</p>\n<p>持续的写作需要极大热忱，希望我能保持。</p>\n"},{"layout":"post","title":"新外观，更优雅，更直接","date":"2011-06-05T12:20:00.000Z","status":"publish","_content":"\n![Metro](/images/metro.png)\n\n我叫尚春，来自美团网\n\n如你所看\n\n我的blog彻底重建\n\n引入了很多[Metro](http://ubelly.com/2011/01/metro-windows-phone-7-design-language/)的设计理念\n\n因为我欣赏更加凸显内容的表达方式\n\n而不再认为高光、阴影是现代风格所必须\n\n这，是一种真正意义上的返璞归真\n\n在这里\n\n所有的图标都是用[Raphaël](http://raphaeljs.com)绘制\n\n我写的一个小型通用库Spring也崭露头角\n\n并将茁壮成长\n\n一切都远未完善\n\n我会有节奏的进行\n\n这一切都值得期待\n","source":"_posts/change-theme.md","raw":"---\nlayout: post\ntitle: \"新外观，更优雅，更直接\"\ndate: 2011-06-05 20:20\nstatus: publish\ntags: [Self, Metro]\n---\n\n![Metro](/images/metro.png)\n\n我叫尚春，来自美团网\n\n如你所看\n\n我的blog彻底重建\n\n引入了很多[Metro](http://ubelly.com/2011/01/metro-windows-phone-7-design-language/)的设计理念\n\n因为我欣赏更加凸显内容的表达方式\n\n而不再认为高光、阴影是现代风格所必须\n\n这，是一种真正意义上的返璞归真\n\n在这里\n\n所有的图标都是用[Raphaël](http://raphaeljs.com)绘制\n\n我写的一个小型通用库Spring也崭露头角\n\n并将茁壮成长\n\n一切都远未完善\n\n我会有节奏的进行\n\n这一切都值得期待\n","slug":"change-theme","published":1,"updated":"2021-10-05T09:34:47.222Z","comments":1,"photos":[],"link":"","_id":"cl1klgup400028e85bpac6xtr","content":"<p><img src=\"/images/metro.png\" alt=\"Metro\"></p>\n<p>我叫尚春，来自美团网</p>\n<p>如你所看</p>\n<p>我的blog彻底重建</p>\n<p>引入了很多<a href=\"http://ubelly.com/2011/01/metro-windows-phone-7-design-language/\">Metro</a>的设计理念</p>\n<p>因为我欣赏更加凸显内容的表达方式</p>\n<p>而不再认为高光、阴影是现代风格所必须</p>\n<p>这，是一种真正意义上的返璞归真</p>\n<p>在这里</p>\n<p>所有的图标都是用<a href=\"http://raphaeljs.com/\">Raphaël</a>绘制</p>\n<p>我写的一个小型通用库Spring也崭露头角</p>\n<p>并将茁壮成长</p>\n<p>一切都远未完善</p>\n<p>我会有节奏的进行</p>\n<p>这一切都值得期待</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/metro.png\" alt=\"Metro\"></p>\n<p>我叫尚春，来自美团网</p>\n<p>如你所看</p>\n<p>我的blog彻底重建</p>\n<p>引入了很多<a href=\"http://ubelly.com/2011/01/metro-windows-phone-7-design-language/\">Metro</a>的设计理念</p>\n<p>因为我欣赏更加凸显内容的表达方式</p>\n<p>而不再认为高光、阴影是现代风格所必须</p>\n<p>这，是一种真正意义上的返璞归真</p>\n<p>在这里</p>\n<p>所有的图标都是用<a href=\"http://raphaeljs.com/\">Raphaël</a>绘制</p>\n<p>我写的一个小型通用库Spring也崭露头角</p>\n<p>并将茁壮成长</p>\n<p>一切都远未完善</p>\n<p>我会有节奏的进行</p>\n<p>这一切都值得期待</p>\n"},{"layout":"post","title":"js 中的 !! 与 ~~","date":"2015-10-17T13:01:00.000Z","status":"publish","_content":"\n在各大 js 的开源项目中，时常见到 !! 和 ~~，偶有猜对，却总不得要领。本文旨在深入剖析下这两个运算符的原理，以及使用时的利弊。\n\n## !\n\n为了简化问题，我们首先了解下常见的逻辑非运算符 !，EcmaScript 中的定义是：\n\n> 产生式 `UnaryExpression : ! UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 令 `oldValue` 为 ToBoolean(GetValue(`expr`))\n> - 如果 `oldValue` 为 true, 返回 false\n> - 返回 true\n\nGetValue 处理取值的细节，例如依附于对象的属性、执行 getter 等，不再深究。重点看下 ToBoolean，它能够将各种类型的值最终转化为布尔类型。具体的规则可参考 [ES5#9.2 ToBoolean](http://es5.github.io/#x9.2) 一节。\n\n接下来的处理很简单，如果 ToBoolen 得到的结果 `oldValue` 是 true，那就返回 false，否则返回 true。\n\n<!--more-->\n\n## !!\n\n了解了 ! 之后，!! 就很好解释了，简单来说就是：\n\n> 产生式 `UnaryExpression : !! UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 返回 ToBoolean(GetValue(`expr`))\n\n是的，比 ! 的运算过程减少了两步，执行完 ToBoolean 后就直接返回了。这也是 !! 最主要的用途：**将操作数转化为布尔类型**。例如：\n\n```js\n!! null // false\n!! undefined // false\n\n!! '' // false\n!! 'hello' // true\n\n!! 5 // true\n!! 0 // false\n\n!! {} // true\n```\n\n值得提示的一点是，!! 实际上等效于 `Boolean` 被当做函数调用的效果：\n\n```js\n!!(value) === Boolean(value)\n```\n\n## ~\n\n按位非操作符 ~ 比逻辑非操作符 ! 复杂一些，作用是将数值比特位中的 1 变成 0，0 变成 1。EcmaScript 中的定义为：\n\n> 产生式 `UnaryExpression : ~ UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 令 `oldValue` 为 ToInt32(GetValue(`expr`))\n> - 返回 `oldValue` 按位取反的结果\n\n与逻辑非执行过程第二步不同，按位非调用的是 ToInt32 而不是 ToBoolean。ToInt32 的处理过程比较复杂，简化为以下四步：\n\n- 令 `number` 为调用 ToNumber 将输入参数转化为数值类型的结果\n- 如果 `number` 是 NaN，+0，-0，+∞ 或者 -∞，返回 +0\n- 令 `posInt` 为 sign(`number`) * floor(abs(`number`))\n- 将 `posInt` 进行取模处理，转化为在 −2^31 到 2^31−1 之间的 32 位有符号整数并返回\n\n从效果上看，ToInt32 依次做了这样几件事：\n\n- 类型转换，非数值类型的需要转化为数值类型\n- 特殊值处理，NaN 和 ∞ 都被转化为 0\n- 取整，如果是浮点数，会损失小数点后面的精度\n- 取模，将整数调整到 32 位有符号整数区间内，如果整数原本不在这个区间，会丧失精度\n\n执行完 ToInt32 之后，将得到的 32 位有符号整数进行按位取反，并将结果返回。\n\n需要注意的是，所有的位操作都会先将操作数转化为 32 位有符号整数。\n\n## ~~\n\n和 !! 与 ! 的关系类似，~~ 实际上是 ~ 的简化版：\n\n> 产生式 `UnaryExpression : ~~ UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 返回 ToInt32(GetValue(`expr`))\n\n因为第一次执行 ~ 时已经将操作数转化为 32 位有符号整数，第二次执行 ~ 时实际只是将按位取反的结果再次按位取反，相当于取消掉 ~ 处理过程中的第三步。那么 ~~ 的用途也就很明确了：**将操作数转化为 32 位有符号整数**。\n\n下面来看一些具体例子：\n\n```js\n~~ null // 0\n~~ undefined // 0\n~~ NaN // 0\n~~ {} // 0\n~~ true // 1\n~~ '' // 0\n~~ 'string' // 0\n~~ '1' // 1\n~~ Number.POSITIVE_INFINITY // 0\n\n~~ 1.2 // 1\n~~ -1.2 // -1\n~~ 1.6 // 1\n~~ -1.6 // -1\n~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 32)) // 0\n```\n\n如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。\n\n## 参考\n\n- [按位操作符-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)\n- [ToBoolean - ES5](http://es5.github.io/#x9.2)\n- [ToInt32 - ES5](http://es5.github.io/#x9.5)\n- [Bitwise NOT Operator - ES5](http://es5.github.io/#x11.4.8)\n- [Logical NOT Operator - ES5](http://es5.github.io/#x11.4.9)\n","source":"_posts/bitwise-not-and-logical-not.md","raw":"---\nlayout: post\ntitle: \"js 中的 !! 与 ~~\"\ndate: 2015-10-17 21:01\nstatus: publish\ntags: [BitwiseNOT, LogicalNOT, JavaScript]\n---\n\n在各大 js 的开源项目中，时常见到 !! 和 ~~，偶有猜对，却总不得要领。本文旨在深入剖析下这两个运算符的原理，以及使用时的利弊。\n\n## !\n\n为了简化问题，我们首先了解下常见的逻辑非运算符 !，EcmaScript 中的定义是：\n\n> 产生式 `UnaryExpression : ! UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 令 `oldValue` 为 ToBoolean(GetValue(`expr`))\n> - 如果 `oldValue` 为 true, 返回 false\n> - 返回 true\n\nGetValue 处理取值的细节，例如依附于对象的属性、执行 getter 等，不再深究。重点看下 ToBoolean，它能够将各种类型的值最终转化为布尔类型。具体的规则可参考 [ES5#9.2 ToBoolean](http://es5.github.io/#x9.2) 一节。\n\n接下来的处理很简单，如果 ToBoolen 得到的结果 `oldValue` 是 true，那就返回 false，否则返回 true。\n\n<!--more-->\n\n## !!\n\n了解了 ! 之后，!! 就很好解释了，简单来说就是：\n\n> 产生式 `UnaryExpression : !! UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 返回 ToBoolean(GetValue(`expr`))\n\n是的，比 ! 的运算过程减少了两步，执行完 ToBoolean 后就直接返回了。这也是 !! 最主要的用途：**将操作数转化为布尔类型**。例如：\n\n```js\n!! null // false\n!! undefined // false\n\n!! '' // false\n!! 'hello' // true\n\n!! 5 // true\n!! 0 // false\n\n!! {} // true\n```\n\n值得提示的一点是，!! 实际上等效于 `Boolean` 被当做函数调用的效果：\n\n```js\n!!(value) === Boolean(value)\n```\n\n## ~\n\n按位非操作符 ~ 比逻辑非操作符 ! 复杂一些，作用是将数值比特位中的 1 变成 0，0 变成 1。EcmaScript 中的定义为：\n\n> 产生式 `UnaryExpression : ~ UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 令 `oldValue` 为 ToInt32(GetValue(`expr`))\n> - 返回 `oldValue` 按位取反的结果\n\n与逻辑非执行过程第二步不同，按位非调用的是 ToInt32 而不是 ToBoolean。ToInt32 的处理过程比较复杂，简化为以下四步：\n\n- 令 `number` 为调用 ToNumber 将输入参数转化为数值类型的结果\n- 如果 `number` 是 NaN，+0，-0，+∞ 或者 -∞，返回 +0\n- 令 `posInt` 为 sign(`number`) * floor(abs(`number`))\n- 将 `posInt` 进行取模处理，转化为在 −2^31 到 2^31−1 之间的 32 位有符号整数并返回\n\n从效果上看，ToInt32 依次做了这样几件事：\n\n- 类型转换，非数值类型的需要转化为数值类型\n- 特殊值处理，NaN 和 ∞ 都被转化为 0\n- 取整，如果是浮点数，会损失小数点后面的精度\n- 取模，将整数调整到 32 位有符号整数区间内，如果整数原本不在这个区间，会丧失精度\n\n执行完 ToInt32 之后，将得到的 32 位有符号整数进行按位取反，并将结果返回。\n\n需要注意的是，所有的位操作都会先将操作数转化为 32 位有符号整数。\n\n## ~~\n\n和 !! 与 ! 的关系类似，~~ 实际上是 ~ 的简化版：\n\n> 产生式 `UnaryExpression : ~~ UnaryExpression` 按照下面的过程执行：\n> \n> - 令 `expr` 为解析执行 `UnaryExpression` 的结果\n> - 返回 ToInt32(GetValue(`expr`))\n\n因为第一次执行 ~ 时已经将操作数转化为 32 位有符号整数，第二次执行 ~ 时实际只是将按位取反的结果再次按位取反，相当于取消掉 ~ 处理过程中的第三步。那么 ~~ 的用途也就很明确了：**将操作数转化为 32 位有符号整数**。\n\n下面来看一些具体例子：\n\n```js\n~~ null // 0\n~~ undefined // 0\n~~ NaN // 0\n~~ {} // 0\n~~ true // 1\n~~ '' // 0\n~~ 'string' // 0\n~~ '1' // 1\n~~ Number.POSITIVE_INFINITY // 0\n\n~~ 1.2 // 1\n~~ -1.2 // -1\n~~ 1.6 // 1\n~~ -1.6 // -1\n~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 32)) // 0\n```\n\n如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。\n\n## 参考\n\n- [按位操作符-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)\n- [ToBoolean - ES5](http://es5.github.io/#x9.2)\n- [ToInt32 - ES5](http://es5.github.io/#x9.5)\n- [Bitwise NOT Operator - ES5](http://es5.github.io/#x11.4.8)\n- [Logical NOT Operator - ES5](http://es5.github.io/#x11.4.9)\n","slug":"bitwise-not-and-logical-not","published":1,"updated":"2021-11-25T11:01:25.485Z","comments":1,"photos":[],"link":"","_id":"cl1klgup700048e854aa60cuj","content":"<p>在各大 js 的开源项目中，时常见到 !! 和 ~~，偶有猜对，却总不得要领。本文旨在深入剖析下这两个运算符的原理，以及使用时的利弊。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"!\"></a>!</h2><p>为了简化问题，我们首先了解下常见的逻辑非运算符 !，EcmaScript 中的定义是：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ! UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>令 <code>oldValue</code> 为 ToBoolean(GetValue(<code>expr</code>))</li>\n<li>如果 <code>oldValue</code> 为 true, 返回 false</li>\n<li>返回 true</li>\n</ul>\n</blockquote>\n<p>GetValue 处理取值的细节，例如依附于对象的属性、执行 getter 等，不再深究。重点看下 ToBoolean，它能够将各种类型的值最终转化为布尔类型。具体的规则可参考 <a href=\"http://es5.github.io/#x9.2\">ES5#9.2 ToBoolean</a> 一节。</p>\n<p>接下来的处理很简单，如果 ToBoolen 得到的结果 <code>oldValue</code> 是 true，那就返回 false，否则返回 true。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"!!\"></a>!!</h2><p>了解了 ! 之后，!! 就很好解释了，简单来说就是：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : !! UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>返回 ToBoolean(GetValue(<code>expr</code>))</li>\n</ul>\n</blockquote>\n<p>是的，比 ! 的运算过程减少了两步，执行完 ToBoolean 后就直接返回了。这也是 !! 最主要的用途：<strong>将操作数转化为布尔类型</strong>。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!! <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">!! <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">!! <span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">!! <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! &#123;&#125; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>值得提示的一点是，!! 实际上等效于 <code>Boolean</code> 被当做函数调用的效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!!(value) === <span class=\"built_in\">Boolean</span>(value)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"~\"></a>~</h2><p>按位非操作符 ~ 比逻辑非操作符 ! 复杂一些，作用是将数值比特位中的 1 变成 0，0 变成 1。EcmaScript 中的定义为：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ~ UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>令 <code>oldValue</code> 为 ToInt32(GetValue(<code>expr</code>))</li>\n<li>返回 <code>oldValue</code> 按位取反的结果</li>\n</ul>\n</blockquote>\n<p>与逻辑非执行过程第二步不同，按位非调用的是 ToInt32 而不是 ToBoolean。ToInt32 的处理过程比较复杂，简化为以下四步：</p>\n<ul>\n<li>令 <code>number</code> 为调用 ToNumber 将输入参数转化为数值类型的结果</li>\n<li>如果 <code>number</code> 是 NaN，+0，-0，+∞ 或者 -∞，返回 +0</li>\n<li>令 <code>posInt</code> 为 sign(<code>number</code>) * floor(abs(<code>number</code>))</li>\n<li>将 <code>posInt</code> 进行取模处理，转化为在 −2^31 到 2^31−1 之间的 32 位有符号整数并返回</li>\n</ul>\n<p>从效果上看，ToInt32 依次做了这样几件事：</p>\n<ul>\n<li>类型转换，非数值类型的需要转化为数值类型</li>\n<li>特殊值处理，NaN 和 ∞ 都被转化为 0</li>\n<li>取整，如果是浮点数，会损失小数点后面的精度</li>\n<li>取模，将整数调整到 32 位有符号整数区间内，如果整数原本不在这个区间，会丧失精度</li>\n</ul>\n<p>执行完 ToInt32 之后，将得到的 32 位有符号整数进行按位取反，并将结果返回。</p>\n<p>需要注意的是，所有的位操作都会先将操作数转化为 32 位有符号整数。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"~~\"></a>~~</h2><p>和 !! 与 ! 的关系类似，~~ 实际上是 ~ 的简化版：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ~~ UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>返回 ToInt32(GetValue(<code>expr</code>))</li>\n</ul>\n</blockquote>\n<p>因为第一次执行 ~ 时已经将操作数转化为 32 位有符号整数，第二次执行 ~ 时实际只是将按位取反的结果再次按位取反，相当于取消掉 ~ 处理过程中的第三步。那么 ~~ 的用途也就很明确了：<strong>将操作数转化为 32 位有符号整数</strong>。</p>\n<p>下面来看一些具体例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~ <span class=\"literal\">null</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">undefined</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">NaN</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ &#123;&#125; <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">true</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;string&#x27;</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ <span class=\"built_in\">Number</span>.POSITIVE_INFINITY <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">~~ <span class=\"number\">1.2</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ -<span class=\"number\">1.2</span> <span class=\"comment\">// -1</span></span><br><span class=\"line\">~~ <span class=\"number\">1.6</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ -<span class=\"number\">1.6</span> <span class=\"comment\">// -1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"comment\">// 2147483647 = 2^31-1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)) <span class=\"comment\">// -2147483648 = -2^31</span></span><br><span class=\"line\">~~ (-<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)) <span class=\"comment\">// -2147483648 = -2^31</span></span><br><span class=\"line\">~~ (-<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"comment\">// 2147483647 = 2^31-1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\">按位操作符-MDN</a></li>\n<li><a href=\"http://es5.github.io/#x9.2\">ToBoolean - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x9.5\">ToInt32 - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x11.4.8\">Bitwise NOT Operator - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x11.4.9\">Logical NOT Operator - ES5</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在各大 js 的开源项目中，时常见到 !! 和 ~~，偶有猜对，却总不得要领。本文旨在深入剖析下这两个运算符的原理，以及使用时的利弊。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"!\"></a>!</h2><p>为了简化问题，我们首先了解下常见的逻辑非运算符 !，EcmaScript 中的定义是：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ! UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>令 <code>oldValue</code> 为 ToBoolean(GetValue(<code>expr</code>))</li>\n<li>如果 <code>oldValue</code> 为 true, 返回 false</li>\n<li>返回 true</li>\n</ul>\n</blockquote>\n<p>GetValue 处理取值的细节，例如依附于对象的属性、执行 getter 等，不再深究。重点看下 ToBoolean，它能够将各种类型的值最终转化为布尔类型。具体的规则可参考 <a href=\"http://es5.github.io/#x9.2\">ES5#9.2 ToBoolean</a> 一节。</p>\n<p>接下来的处理很简单，如果 ToBoolen 得到的结果 <code>oldValue</code> 是 true，那就返回 false，否则返回 true。</p>","more":"<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"!!\"></a>!!</h2><p>了解了 ! 之后，!! 就很好解释了，简单来说就是：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : !! UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>返回 ToBoolean(GetValue(<code>expr</code>))</li>\n</ul>\n</blockquote>\n<p>是的，比 ! 的运算过程减少了两步，执行完 ToBoolean 后就直接返回了。这也是 !! 最主要的用途：<strong>将操作数转化为布尔类型</strong>。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!! <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">!! <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">!! <span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">!! <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">!! &#123;&#125; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>值得提示的一点是，!! 实际上等效于 <code>Boolean</code> 被当做函数调用的效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!!(value) === <span class=\"built_in\">Boolean</span>(value)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"~\"></a>~</h2><p>按位非操作符 ~ 比逻辑非操作符 ! 复杂一些，作用是将数值比特位中的 1 变成 0，0 变成 1。EcmaScript 中的定义为：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ~ UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>令 <code>oldValue</code> 为 ToInt32(GetValue(<code>expr</code>))</li>\n<li>返回 <code>oldValue</code> 按位取反的结果</li>\n</ul>\n</blockquote>\n<p>与逻辑非执行过程第二步不同，按位非调用的是 ToInt32 而不是 ToBoolean。ToInt32 的处理过程比较复杂，简化为以下四步：</p>\n<ul>\n<li>令 <code>number</code> 为调用 ToNumber 将输入参数转化为数值类型的结果</li>\n<li>如果 <code>number</code> 是 NaN，+0，-0，+∞ 或者 -∞，返回 +0</li>\n<li>令 <code>posInt</code> 为 sign(<code>number</code>) * floor(abs(<code>number</code>))</li>\n<li>将 <code>posInt</code> 进行取模处理，转化为在 −2^31 到 2^31−1 之间的 32 位有符号整数并返回</li>\n</ul>\n<p>从效果上看，ToInt32 依次做了这样几件事：</p>\n<ul>\n<li>类型转换，非数值类型的需要转化为数值类型</li>\n<li>特殊值处理，NaN 和 ∞ 都被转化为 0</li>\n<li>取整，如果是浮点数，会损失小数点后面的精度</li>\n<li>取模，将整数调整到 32 位有符号整数区间内，如果整数原本不在这个区间，会丧失精度</li>\n</ul>\n<p>执行完 ToInt32 之后，将得到的 32 位有符号整数进行按位取反，并将结果返回。</p>\n<p>需要注意的是，所有的位操作都会先将操作数转化为 32 位有符号整数。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"~~\"></a>~~</h2><p>和 !! 与 ! 的关系类似，~~ 实际上是 ~ 的简化版：</p>\n<blockquote>\n<p>产生式 <code>UnaryExpression : ~~ UnaryExpression</code> 按照下面的过程执行：</p>\n<ul>\n<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>\n<li>返回 ToInt32(GetValue(<code>expr</code>))</li>\n</ul>\n</blockquote>\n<p>因为第一次执行 ~ 时已经将操作数转化为 32 位有符号整数，第二次执行 ~ 时实际只是将按位取反的结果再次按位取反，相当于取消掉 ~ 处理过程中的第三步。那么 ~~ 的用途也就很明确了：<strong>将操作数转化为 32 位有符号整数</strong>。</p>\n<p>下面来看一些具体例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~ <span class=\"literal\">null</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">undefined</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">NaN</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ &#123;&#125; <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"literal\">true</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;string&#x27;</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">~~ <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ <span class=\"built_in\">Number</span>.POSITIVE_INFINITY <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">~~ <span class=\"number\">1.2</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ -<span class=\"number\">1.2</span> <span class=\"comment\">// -1</span></span><br><span class=\"line\">~~ <span class=\"number\">1.6</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">~~ -<span class=\"number\">1.6</span> <span class=\"comment\">// -1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"comment\">// 2147483647 = 2^31-1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)) <span class=\"comment\">// -2147483648 = -2^31</span></span><br><span class=\"line\">~~ (-<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)) <span class=\"comment\">// -2147483648 = -2^31</span></span><br><span class=\"line\">~~ (-<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"comment\">// 2147483647 = 2^31-1</span></span><br><span class=\"line\">~~ (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\">按位操作符-MDN</a></li>\n<li><a href=\"http://es5.github.io/#x9.2\">ToBoolean - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x9.5\">ToInt32 - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x11.4.8\">Bitwise NOT Operator - ES5</a></li>\n<li><a href=\"http://es5.github.io/#x11.4.9\">Logical NOT Operator - ES5</a></li>\n</ul>"},{"layout":"post","title":"Continuation 在 JS 中的应用","date":"2020-05-05T12:05:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [Continuation 在 JS 中的应用](https://zhuanlan.zhihu.com/p/94611888) 查看全文。\n","source":"_posts/continuation.md","raw":"---\nlayout: post\ntitle: \"Continuation 在 JS 中的应用\"\ndate: 2020-05-05 20:05\nstatus: publish\ntags: [Functional Programming, Continuation, Promise]\n---\n\n请移步知乎“前端之美”专栏 [Continuation 在 JS 中的应用](https://zhuanlan.zhihu.com/p/94611888) 查看全文。\n","slug":"continuation","published":1,"updated":"2021-10-05T13:13:25.154Z","comments":1,"photos":[],"link":"","_id":"cl1klgup800058e8527pzb6at","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/94611888\">Continuation 在 JS 中的应用</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/94611888\">Continuation 在 JS 中的应用</a> 查看全文。</p>\n"},{"layout":"post","title":"[译]优秀与伟大程序员的区别","date":"2013-10-19T12:39:00.000Z","status":"publish","_content":"\n<div class=\"preface\">\n    <p>在程序员的职业生涯中，总有一些理念让你眼前一亮，犹如夜空中一颗颗明亮的星，指引你不断前行。Quora上Russel Simmons的这个答案就是曾让我深受触动的三个理念，翻译出来给E文一般的童鞋。E文好的童鞋请移步，原著更加准确生动些。</p>\n    <em>原文链接：<a href=\"http://www.quora.com/Software-Engineering/What-distinguishes-a-good-software-engineer-from-a-great-one/answer/Russel-Simmons?srid=mo0\" target=\"_blank\">Software Engineering: What distinguishes a good software engineer from a great one?</a></em>\n</div>\n\n我并不打算给出一个全面的答案，不过我已注意到几个伟大程序员具备却不常被提及的特质：\n\n- **能够平衡实效与完美**。伟大工程师具备进行娴熟、快速而粗略的hack，和设计优雅、精炼、健壮的解决方案的两种能力，以及，根据给定问题选择恰当方式的智慧。一些稍普通的程序员们看起来缺乏对问题关键细节的极致关注，另一些人则太过坚持完美主义。\n- **不排斥调试代码和修复bug**。平庸的程序员害怕、厌恶调试，甚至对自己的代码也是如此。伟大程序员会以丘吉尔般顽强的精神潜心钻研。如果问题被证明不在他们的代码中，伟大程序员会有些不愉快，他们会最终找出问题所在。\n- **合理质疑**。优秀程序员会找到看似可行的解决办法并一直沿用。伟大程序员则倾向于质疑自己的代码，直到测试完备。而这一过程往往需要大量的数据分析和系统管理。一般程序员可能看到一个似乎没什么危害的细微异常，然后忽略掉了它。如果换作伟大程序员，他们会怀疑这可能是一个更大问题的线索，并投入精力研究透彻。伟大程序员乐于做更多的交叉校验和完备性检查，通过这种方式发现隐含的问题。\n","source":"_posts/diff-great-software-engineer-from-a-good.md","raw":"---\nlayout: post\ntitle: \"[译]优秀与伟大程序员的区别\"\ndate: 2013-10-19 20:39\nstatus: publish\ntags: [Programming]\n---\n\n<div class=\"preface\">\n    <p>在程序员的职业生涯中，总有一些理念让你眼前一亮，犹如夜空中一颗颗明亮的星，指引你不断前行。Quora上Russel Simmons的这个答案就是曾让我深受触动的三个理念，翻译出来给E文一般的童鞋。E文好的童鞋请移步，原著更加准确生动些。</p>\n    <em>原文链接：<a href=\"http://www.quora.com/Software-Engineering/What-distinguishes-a-good-software-engineer-from-a-great-one/answer/Russel-Simmons?srid=mo0\" target=\"_blank\">Software Engineering: What distinguishes a good software engineer from a great one?</a></em>\n</div>\n\n我并不打算给出一个全面的答案，不过我已注意到几个伟大程序员具备却不常被提及的特质：\n\n- **能够平衡实效与完美**。伟大工程师具备进行娴熟、快速而粗略的hack，和设计优雅、精炼、健壮的解决方案的两种能力，以及，根据给定问题选择恰当方式的智慧。一些稍普通的程序员们看起来缺乏对问题关键细节的极致关注，另一些人则太过坚持完美主义。\n- **不排斥调试代码和修复bug**。平庸的程序员害怕、厌恶调试，甚至对自己的代码也是如此。伟大程序员会以丘吉尔般顽强的精神潜心钻研。如果问题被证明不在他们的代码中，伟大程序员会有些不愉快，他们会最终找出问题所在。\n- **合理质疑**。优秀程序员会找到看似可行的解决办法并一直沿用。伟大程序员则倾向于质疑自己的代码，直到测试完备。而这一过程往往需要大量的数据分析和系统管理。一般程序员可能看到一个似乎没什么危害的细微异常，然后忽略掉了它。如果换作伟大程序员，他们会怀疑这可能是一个更大问题的线索，并投入精力研究透彻。伟大程序员乐于做更多的交叉校验和完备性检查，通过这种方式发现隐含的问题。\n","slug":"diff-great-software-engineer-from-a-good","published":1,"updated":"2021-10-04T12:57:16.045Z","comments":1,"photos":[],"link":"","_id":"cl1klgup900068e852o73d2x5","content":"<div class=\"preface\">\n    <p>在程序员的职业生涯中，总有一些理念让你眼前一亮，犹如夜空中一颗颗明亮的星，指引你不断前行。Quora上Russel Simmons的这个答案就是曾让我深受触动的三个理念，翻译出来给E文一般的童鞋。E文好的童鞋请移步，原著更加准确生动些。</p>\n    <em>原文链接：<a href=\"http://www.quora.com/Software-Engineering/What-distinguishes-a-good-software-engineer-from-a-great-one/answer/Russel-Simmons?srid=mo0\" target=\"_blank\">Software Engineering: What distinguishes a good software engineer from a great one?</a></em>\n</div>\n\n<p>我并不打算给出一个全面的答案，不过我已注意到几个伟大程序员具备却不常被提及的特质：</p>\n<ul>\n<li><strong>能够平衡实效与完美</strong>。伟大工程师具备进行娴熟、快速而粗略的hack，和设计优雅、精炼、健壮的解决方案的两种能力，以及，根据给定问题选择恰当方式的智慧。一些稍普通的程序员们看起来缺乏对问题关键细节的极致关注，另一些人则太过坚持完美主义。</li>\n<li><strong>不排斥调试代码和修复bug</strong>。平庸的程序员害怕、厌恶调试，甚至对自己的代码也是如此。伟大程序员会以丘吉尔般顽强的精神潜心钻研。如果问题被证明不在他们的代码中，伟大程序员会有些不愉快，他们会最终找出问题所在。</li>\n<li><strong>合理质疑</strong>。优秀程序员会找到看似可行的解决办法并一直沿用。伟大程序员则倾向于质疑自己的代码，直到测试完备。而这一过程往往需要大量的数据分析和系统管理。一般程序员可能看到一个似乎没什么危害的细微异常，然后忽略掉了它。如果换作伟大程序员，他们会怀疑这可能是一个更大问题的线索，并投入精力研究透彻。伟大程序员乐于做更多的交叉校验和完备性检查，通过这种方式发现隐含的问题。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"preface\">\n    <p>在程序员的职业生涯中，总有一些理念让你眼前一亮，犹如夜空中一颗颗明亮的星，指引你不断前行。Quora上Russel Simmons的这个答案就是曾让我深受触动的三个理念，翻译出来给E文一般的童鞋。E文好的童鞋请移步，原著更加准确生动些。</p>\n    <em>原文链接：<a href=\"http://www.quora.com/Software-Engineering/What-distinguishes-a-good-software-engineer-from-a-great-one/answer/Russel-Simmons?srid=mo0\" target=\"_blank\">Software Engineering: What distinguishes a good software engineer from a great one?</a></em>\n</div>\n\n<p>我并不打算给出一个全面的答案，不过我已注意到几个伟大程序员具备却不常被提及的特质：</p>\n<ul>\n<li><strong>能够平衡实效与完美</strong>。伟大工程师具备进行娴熟、快速而粗略的hack，和设计优雅、精炼、健壮的解决方案的两种能力，以及，根据给定问题选择恰当方式的智慧。一些稍普通的程序员们看起来缺乏对问题关键细节的极致关注，另一些人则太过坚持完美主义。</li>\n<li><strong>不排斥调试代码和修复bug</strong>。平庸的程序员害怕、厌恶调试，甚至对自己的代码也是如此。伟大程序员会以丘吉尔般顽强的精神潜心钻研。如果问题被证明不在他们的代码中，伟大程序员会有些不愉快，他们会最终找出问题所在。</li>\n<li><strong>合理质疑</strong>。优秀程序员会找到看似可行的解决办法并一直沿用。伟大程序员则倾向于质疑自己的代码，直到测试完备。而这一过程往往需要大量的数据分析和系统管理。一般程序员可能看到一个似乎没什么危害的细微异常，然后忽略掉了它。如果换作伟大程序员，他们会怀疑这可能是一个更大问题的线索，并投入精力研究透彻。伟大程序员乐于做更多的交叉校验和完备性检查，通过这种方式发现隐含的问题。</li>\n</ul>\n"},{"layout":"post","title":"YUI事件体系之Y.delegate","date":"2013-04-05T15:23:00.000Z","status":"publish","_content":"\n![relay baton](/images/delegate.jpg)\n\n在介绍了YUI自定义事件体系和对DOM事件的封装后，本篇文章重点阐述事件方面的一种常用技术——事件代理。事件代理（Event Delegation，又称事件委托）充分运用事件传播模型，用一种十分优雅的方式实现了批量节点事件监听。具体的原理和优点请移步zakas比较古老的一篇文章[Event delegation in JavaScript](http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/)。事件代理在YUI中的实现为`Y.delegate`。\n\n## 基本用法\n\n为方便讨论，约定以下名称：\n\n- 代理节点：实际监听事件的节点。在事件传播到此节点时判断是否符合代理条件，符合则执行回调函数。\n- 被代理节点：希望监听事件的节点。如果不采用事件代理，那么应该直接监听这些节点的事件。\n- 目标节点：事件发生的目标节点，即`event.target`。\n\n三者的层次关系从内到外依次为：目标节点 &lt;= 被代理节点 &lt;= 代理节点。\n\n<!-- more -->\n\n假设html为：\n\n```html\n<ul>\n    <li>\n        <a href=\"http://google.com\">google</a>\n    </li>\n    <li>\n        <a name=\"facebook\" href=\"http://facebook.com\">facebook</a>\n    </li>\n    <li>\n        <a name=\"twitter\" href=\"http://twitter.com\">twitter</a>\n    </li>\n</ul>\n```\n\n先来看下`Y.delegate`的简单用法：\n\n```js\n// 例1\n// API: Y.delegate(type, fn, el, filter)\nYUI().use('event-delegate', function(Y) {\n    var handle = Y.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'ul', 'a');\n\n    Y.delegate('click', function (e) {\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'ul', 'li');\n\n    // click first anchor\n    // output 'A is clicked'\n    // output 'LI is clicked'\n\n    handle.detach();\n\n    // click first anchor again\n    // output 'LI is clicked'\n});\n```\n\n可以看出，回调函数中的this指向的是使用`Y.Node`包装的被代理节点。\n\nYUI3新加入的`Y.Node`对象也封装了delegate，例1更常见的实现如下：\n\n```js\n// 例2\n// API: Y.Node.prototype.delegate(type, fn, filter)\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul'),\n        handle;\n\n    handle = ndList.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'a');\n\n    ndList.delegate('click', function (e) {\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'li');\n\n    // click first anchor\n    // output 'A is clicked'\n    // output 'LI is clicked'\n\n    handle.detach();\n\n    // click first anchor again\n    // output 'LI is clicked'\n});\n```\n\n筛选条件除了例1中使用的selector外，还支持函数：\n\n```js\n// 例3\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul');\n\n    ndList.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, function (nd, e) {\n        return nd.get('name') &&\n               e.target.get('tagName').toLowerCase() === 'a';\n    });\n\n    // click the first anchor\n    // no output\n\n    // click the second anchor\n    // output 'LI is clicked'\n});\n```\n\n## 源码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js)。\n\n```js\nvar toArray = Y.Array,\n    isString = Y.Lang.isString;\n\nfunction delegate(type, fn, el, filter) {\n    var container = isString(el) ? Y.Selector.query(el, null, true) : el,\n        handle;\n\n    // 监听代理节点的type事件\n    handle = Y.Event._attach([type, fn, container], { facade: false });\n    handle.sub.filter  = filter;\n    // 改写事件触发回调函数\n    handle.sub._notify = delegate.notifySub;\n\n    return handle;\n}\n    \n// 代理节点触发事件时的回调函数\ndelegate.notifySub = function (thisObj, args, ce) {\n    // 计算符合filter的被代理节点集合\n    var currentTarget = delegate._applyFilter(this.filter, args, ce),\n        e, i, len, ret;\n    if (!currentTarget) return;\n\n    currentTarget = toArray(currentTarget);\n\n    // 生成事件对象\n    e = args[0] = new Y.DOMEventFacade(args[0], ce.el, ce);\n    // 将代理节点保存在事件对象container属性上，方便回调函数调用\n    e.container = Y.one(ce.el);\n\n    for (i = 0, len = currentTarget.length; i < len && !e.stopped; ++i) {\n        // 将被代理节点保存在事件对象currentTarget属性上\n        e.currentTarget = Y.one(currentTarget[i]);\n\n        // 回调函数中的this指向被代理节点\n        ret = this.fn.apply(e.currentTarget, args);\n        if (ret === false) break;\n    }\n\n    return ret;\n};\n\n// 计算符合filter的被代理节点集合\ndelegate._applyFilter = function (filter, args, ce) {\n    var e         = args[0],\n        container = ce.el,\n        target    = e.target || e.srcElement,\n        match     = [],\n        isContainer = false;\n\n    // 处理事件目标节点为文本节点的情况\n    if (target.nodeType === 3) {\n        target = target.parentNode;\n    }\n\n    // filter是selector\n    if (isString(filter)) {\n        while (target) {\n            isContainer = (target === container);\n            // 测试target是否符合selector filter\n            if (Y.Selector.test(target, filter, (isContainer ? null : container))) {\n                match.push(target);\n            }\n            if (isContainer) break;\n\n            target = target.parentNode;\n        }\n    // filter是function\n    } else {\n        // 将target节点作为function filter的第一个参数，\n        // 第二个参数为事件对象\n        args.unshift(Y.one(target));\n        args[1] = new Y.DOMEventFacade(e, container, ce);\n\n        while (target) {\n            // function filter中this指向target\n            if (filter.apply(args[0], args)) {\n                match.push(target);\n            }\n            if (target === container) break;\n\n            // 更新target\n            target = target.parentNode;\n            args[0] = Y.one(target);\n        }\n\n        // 恢复args对象\n        args[1] = e;\n        args.shift();\n    }\n\n    return match.length <= 1 ? match[0] : match;\n};\n\nY.delegate = Y.Event.delegate = delegate;\n```\n\n## 进阶用法\n\n### 批量代理\n\n`Y.delegate`支持同时代理多种类型的事件，调用方式有如下两种：\n\n- Y.delegate({ typeA: fnA, typeB: fnB }, el, filter)\n- Y.delegate([typeA, typeB], fn, el, filter)\n\n```js\n// 例4\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul');\n    ndList.delegate({\n        click: function (e) {\n            e.halt();\n            console.log(e.type);\n        },\n        dblclick: function (e) {\n            e.halt();\n            console.log(e.type);\n        }\n    }, 'li');\n\n    // double click the first anchor\n    // output 'click'\n    // output 'click'\n    // output 'dblclick'\n\n    ndList.delegate(['click', 'dblclick'], function (e) {\n        e.halt();\n        console.log(e.type);\n    }, 'li');\n\n    // double click the first anchor\n    // output 'click'\n    // output 'click'\n    // output 'dblclick'\n});\n```\n\n### 修改回调函数this，传递数据\n\n```js\n// 例5\nYUI().use('node-event-delegate', function(Y) {\n    Y.one('ul').delegate('click', function (e, args) {\n        e.halt();\n        console.log(this === document.body);\n        console.log(args.data);\n    }, 'li', document.body, { data: 'data' });\n\n    // click the first anchor\n    // output 'true'\n    // output 'data'\n});\n```\n\n### focus、blur事件的代理\n\n在DOM规范中，诸如focus、blur、load、unload、resize等事件是不冒泡的，因为这类事件只限定在某个节点上触发。但focus和blur事件有些特殊，在表单交互方面十分常用，如果能够支持冒泡，那么通过事件代理可以减少很多监听事件的操作。滑稽的是，focusin、focusout两个类似的事件却支持冒泡。\n\n令人欣喜的是，YUI通过定义新的DOM事件实现了focus、blur事件的代理，awesome！\n\n```js\n// 例6\nYUI().use('node-event-delegate', 'event-focus', function(Y) {\n    Y.one('form').delegate({\n        focus: function (e) {\n            // 清除错误提示\n            clearErr(this);\n        },\n        blur: function (e) {\n            // 如果内容为空，则提示错误信息\n            if (this.get('value') === '') showErr(this);\n        }\n    }, 'input');\n\n    function clearErr(nd) {\n        var ndErr = nd.next('.error');\n        if (ndErr) ndErr.hide().setHTML('');\n    };\n\n    function showErr(nd) {\n        var ndErr = nd.next('.error');\n        if (!ndErr) {\n            ndErr = Y.Node.create('<span class=\"error\"></span>');\n            nd.insert(ndErr, 'after');\n        }\n\n        ndErr.show().setHTML('请输入内容');\n    };\n});\n```\n\n## 示例代码\n\n所有示例代码均在[GitHub](https://github.com/springuper/yuianalyser/tree/master/event)。\n\n## 参考\n\n- [YUILibrary-UserGuides-Event Delegation](http://yuilibrary.com/yui/docs/event/#delegation)\n- [Event delegation in JavaScript](http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/)\n- [YUILibrary-delegate](https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js)\n","source":"_posts/event-delegate.md","raw":"---\nlayout: post\ntitle: \"YUI事件体系之Y.delegate\"\ndate: 2013-04-05 23:23\nstatus: publish\ntags: [Y.delegate, YUI]\n---\n\n![relay baton](/images/delegate.jpg)\n\n在介绍了YUI自定义事件体系和对DOM事件的封装后，本篇文章重点阐述事件方面的一种常用技术——事件代理。事件代理（Event Delegation，又称事件委托）充分运用事件传播模型，用一种十分优雅的方式实现了批量节点事件监听。具体的原理和优点请移步zakas比较古老的一篇文章[Event delegation in JavaScript](http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/)。事件代理在YUI中的实现为`Y.delegate`。\n\n## 基本用法\n\n为方便讨论，约定以下名称：\n\n- 代理节点：实际监听事件的节点。在事件传播到此节点时判断是否符合代理条件，符合则执行回调函数。\n- 被代理节点：希望监听事件的节点。如果不采用事件代理，那么应该直接监听这些节点的事件。\n- 目标节点：事件发生的目标节点，即`event.target`。\n\n三者的层次关系从内到外依次为：目标节点 &lt;= 被代理节点 &lt;= 代理节点。\n\n<!-- more -->\n\n假设html为：\n\n```html\n<ul>\n    <li>\n        <a href=\"http://google.com\">google</a>\n    </li>\n    <li>\n        <a name=\"facebook\" href=\"http://facebook.com\">facebook</a>\n    </li>\n    <li>\n        <a name=\"twitter\" href=\"http://twitter.com\">twitter</a>\n    </li>\n</ul>\n```\n\n先来看下`Y.delegate`的简单用法：\n\n```js\n// 例1\n// API: Y.delegate(type, fn, el, filter)\nYUI().use('event-delegate', function(Y) {\n    var handle = Y.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'ul', 'a');\n\n    Y.delegate('click', function (e) {\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'ul', 'li');\n\n    // click first anchor\n    // output 'A is clicked'\n    // output 'LI is clicked'\n\n    handle.detach();\n\n    // click first anchor again\n    // output 'LI is clicked'\n});\n```\n\n可以看出，回调函数中的this指向的是使用`Y.Node`包装的被代理节点。\n\nYUI3新加入的`Y.Node`对象也封装了delegate，例1更常见的实现如下：\n\n```js\n// 例2\n// API: Y.Node.prototype.delegate(type, fn, filter)\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul'),\n        handle;\n\n    handle = ndList.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'a');\n\n    ndList.delegate('click', function (e) {\n        console.log(this.get('tagName') + ' is clicked');\n    }, 'li');\n\n    // click first anchor\n    // output 'A is clicked'\n    // output 'LI is clicked'\n\n    handle.detach();\n\n    // click first anchor again\n    // output 'LI is clicked'\n});\n```\n\n筛选条件除了例1中使用的selector外，还支持函数：\n\n```js\n// 例3\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul');\n\n    ndList.delegate('click', function (e) {\n        e.halt();\n        console.log(this.get('tagName') + ' is clicked');\n    }, function (nd, e) {\n        return nd.get('name') &&\n               e.target.get('tagName').toLowerCase() === 'a';\n    });\n\n    // click the first anchor\n    // no output\n\n    // click the second anchor\n    // output 'LI is clicked'\n});\n```\n\n## 源码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js)。\n\n```js\nvar toArray = Y.Array,\n    isString = Y.Lang.isString;\n\nfunction delegate(type, fn, el, filter) {\n    var container = isString(el) ? Y.Selector.query(el, null, true) : el,\n        handle;\n\n    // 监听代理节点的type事件\n    handle = Y.Event._attach([type, fn, container], { facade: false });\n    handle.sub.filter  = filter;\n    // 改写事件触发回调函数\n    handle.sub._notify = delegate.notifySub;\n\n    return handle;\n}\n    \n// 代理节点触发事件时的回调函数\ndelegate.notifySub = function (thisObj, args, ce) {\n    // 计算符合filter的被代理节点集合\n    var currentTarget = delegate._applyFilter(this.filter, args, ce),\n        e, i, len, ret;\n    if (!currentTarget) return;\n\n    currentTarget = toArray(currentTarget);\n\n    // 生成事件对象\n    e = args[0] = new Y.DOMEventFacade(args[0], ce.el, ce);\n    // 将代理节点保存在事件对象container属性上，方便回调函数调用\n    e.container = Y.one(ce.el);\n\n    for (i = 0, len = currentTarget.length; i < len && !e.stopped; ++i) {\n        // 将被代理节点保存在事件对象currentTarget属性上\n        e.currentTarget = Y.one(currentTarget[i]);\n\n        // 回调函数中的this指向被代理节点\n        ret = this.fn.apply(e.currentTarget, args);\n        if (ret === false) break;\n    }\n\n    return ret;\n};\n\n// 计算符合filter的被代理节点集合\ndelegate._applyFilter = function (filter, args, ce) {\n    var e         = args[0],\n        container = ce.el,\n        target    = e.target || e.srcElement,\n        match     = [],\n        isContainer = false;\n\n    // 处理事件目标节点为文本节点的情况\n    if (target.nodeType === 3) {\n        target = target.parentNode;\n    }\n\n    // filter是selector\n    if (isString(filter)) {\n        while (target) {\n            isContainer = (target === container);\n            // 测试target是否符合selector filter\n            if (Y.Selector.test(target, filter, (isContainer ? null : container))) {\n                match.push(target);\n            }\n            if (isContainer) break;\n\n            target = target.parentNode;\n        }\n    // filter是function\n    } else {\n        // 将target节点作为function filter的第一个参数，\n        // 第二个参数为事件对象\n        args.unshift(Y.one(target));\n        args[1] = new Y.DOMEventFacade(e, container, ce);\n\n        while (target) {\n            // function filter中this指向target\n            if (filter.apply(args[0], args)) {\n                match.push(target);\n            }\n            if (target === container) break;\n\n            // 更新target\n            target = target.parentNode;\n            args[0] = Y.one(target);\n        }\n\n        // 恢复args对象\n        args[1] = e;\n        args.shift();\n    }\n\n    return match.length <= 1 ? match[0] : match;\n};\n\nY.delegate = Y.Event.delegate = delegate;\n```\n\n## 进阶用法\n\n### 批量代理\n\n`Y.delegate`支持同时代理多种类型的事件，调用方式有如下两种：\n\n- Y.delegate({ typeA: fnA, typeB: fnB }, el, filter)\n- Y.delegate([typeA, typeB], fn, el, filter)\n\n```js\n// 例4\nYUI().use('node-event-delegate', function(Y) {\n    var ndList = Y.one('ul');\n    ndList.delegate({\n        click: function (e) {\n            e.halt();\n            console.log(e.type);\n        },\n        dblclick: function (e) {\n            e.halt();\n            console.log(e.type);\n        }\n    }, 'li');\n\n    // double click the first anchor\n    // output 'click'\n    // output 'click'\n    // output 'dblclick'\n\n    ndList.delegate(['click', 'dblclick'], function (e) {\n        e.halt();\n        console.log(e.type);\n    }, 'li');\n\n    // double click the first anchor\n    // output 'click'\n    // output 'click'\n    // output 'dblclick'\n});\n```\n\n### 修改回调函数this，传递数据\n\n```js\n// 例5\nYUI().use('node-event-delegate', function(Y) {\n    Y.one('ul').delegate('click', function (e, args) {\n        e.halt();\n        console.log(this === document.body);\n        console.log(args.data);\n    }, 'li', document.body, { data: 'data' });\n\n    // click the first anchor\n    // output 'true'\n    // output 'data'\n});\n```\n\n### focus、blur事件的代理\n\n在DOM规范中，诸如focus、blur、load、unload、resize等事件是不冒泡的，因为这类事件只限定在某个节点上触发。但focus和blur事件有些特殊，在表单交互方面十分常用，如果能够支持冒泡，那么通过事件代理可以减少很多监听事件的操作。滑稽的是，focusin、focusout两个类似的事件却支持冒泡。\n\n令人欣喜的是，YUI通过定义新的DOM事件实现了focus、blur事件的代理，awesome！\n\n```js\n// 例6\nYUI().use('node-event-delegate', 'event-focus', function(Y) {\n    Y.one('form').delegate({\n        focus: function (e) {\n            // 清除错误提示\n            clearErr(this);\n        },\n        blur: function (e) {\n            // 如果内容为空，则提示错误信息\n            if (this.get('value') === '') showErr(this);\n        }\n    }, 'input');\n\n    function clearErr(nd) {\n        var ndErr = nd.next('.error');\n        if (ndErr) ndErr.hide().setHTML('');\n    };\n\n    function showErr(nd) {\n        var ndErr = nd.next('.error');\n        if (!ndErr) {\n            ndErr = Y.Node.create('<span class=\"error\"></span>');\n            nd.insert(ndErr, 'after');\n        }\n\n        ndErr.show().setHTML('请输入内容');\n    };\n});\n```\n\n## 示例代码\n\n所有示例代码均在[GitHub](https://github.com/springuper/yuianalyser/tree/master/event)。\n\n## 参考\n\n- [YUILibrary-UserGuides-Event Delegation](http://yuilibrary.com/yui/docs/event/#delegation)\n- [Event delegation in JavaScript](http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/)\n- [YUILibrary-delegate](https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js)\n","slug":"event-delegate","published":1,"updated":"2021-10-05T09:22:50.791Z","comments":1,"photos":[],"link":"","_id":"cl1klgupa00088e857bp81ncu","content":"<p><img src=\"/images/delegate.jpg\" alt=\"relay baton\"></p>\n<p>在介绍了YUI自定义事件体系和对DOM事件的封装后，本篇文章重点阐述事件方面的一种常用技术——事件代理。事件代理（Event Delegation，又称事件委托）充分运用事件传播模型，用一种十分优雅的方式实现了批量节点事件监听。具体的原理和优点请移步zakas比较古老的一篇文章<a href=\"http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/\">Event delegation in JavaScript</a>。事件代理在YUI中的实现为<code>Y.delegate</code>。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>为方便讨论，约定以下名称：</p>\n<ul>\n<li>代理节点：实际监听事件的节点。在事件传播到此节点时判断是否符合代理条件，符合则执行回调函数。</li>\n<li>被代理节点：希望监听事件的节点。如果不采用事件代理，那么应该直接监听这些节点的事件。</li>\n<li>目标节点：事件发生的目标节点，即<code>event.target</code>。</li>\n</ul>\n<p>三者的层次关系从内到外依次为：目标节点 &lt;= 被代理节点 &lt;= 代理节点。</p>\n<span id=\"more\"></span>\n\n<p>假设html为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://google.com&quot;</span>&gt;</span>google<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;facebook&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://facebook.com&quot;</span>&gt;</span>facebook<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;twitter&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://twitter.com&quot;</span>&gt;</span>twitter<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>先来看下<code>Y.delegate</code>的简单用法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"comment\">// API: Y.delegate(type, fn, el, filter)</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handle = Y.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Y.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;A is clicked&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    handle.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor again</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，回调函数中的this指向的是使用<code>Y.Node</code>包装的被代理节点。</p>\n<p>YUI3新加入的<code>Y.Node</code>对象也封装了delegate，例1更常见的实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"comment\">// API: Y.Node.prototype.delegate(type, fn, filter)</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>),</span><br><span class=\"line\">        handle;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;A is clicked&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    handle.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor again</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>筛选条件除了例1中使用的selector外，还支持函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nd, e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nd.get(<span class=\"string\">&#x27;name&#x27;</span>) &amp;&amp;</span><br><span class=\"line\">               e.target.get(<span class=\"string\">&#x27;tagName&#x27;</span>).toLowerCase() === <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// no output</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the second anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js\">源码</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toArray = Y.Array,</span><br><span class=\"line\">    isString = Y.Lang.isString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">type, fn, el, filter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> container = isString(el) ? Y.Selector.query(el, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>) : el,</span><br><span class=\"line\">        handle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听代理节点的type事件</span></span><br><span class=\"line\">    handle = Y.Event._attach([type, fn, container], &#123; <span class=\"attr\">facade</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\">    handle.sub.filter  = filter;</span><br><span class=\"line\">    <span class=\"comment\">// 改写事件触发回调函数</span></span><br><span class=\"line\">    handle.sub._notify = delegate.notifySub;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 代理节点触发事件时的回调函数</span></span><br><span class=\"line\">delegate.notifySub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisObj, args, ce</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算符合filter的被代理节点集合</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTarget = delegate._applyFilter(<span class=\"built_in\">this</span>.filter, args, ce),</span><br><span class=\"line\">        e, i, len, ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!currentTarget) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentTarget = toArray(currentTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成事件对象</span></span><br><span class=\"line\">    e = args[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Y.DOMEventFacade(args[<span class=\"number\">0</span>], ce.el, ce);</span><br><span class=\"line\">    <span class=\"comment\">// 将代理节点保存在事件对象container属性上，方便回调函数调用</span></span><br><span class=\"line\">    e.container = Y.one(ce.el);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, len = currentTarget.length; i &lt; len &amp;&amp; !e.stopped; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将被代理节点保存在事件对象currentTarget属性上</span></span><br><span class=\"line\">        e.currentTarget = Y.one(currentTarget[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调函数中的this指向被代理节点</span></span><br><span class=\"line\">        ret = <span class=\"built_in\">this</span>.fn.apply(e.currentTarget, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret === <span class=\"literal\">false</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算符合filter的被代理节点集合</span></span><br><span class=\"line\">delegate._applyFilter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filter, args, ce</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> e         = args[<span class=\"number\">0</span>],</span><br><span class=\"line\">        container = ce.el,</span><br><span class=\"line\">        target    = e.target || e.srcElement,</span><br><span class=\"line\">        match     = [],</span><br><span class=\"line\">        isContainer = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理事件目标节点为文本节点的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.nodeType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        target = target.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// filter是selector</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isString(filter)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (target) &#123;</span><br><span class=\"line\">            isContainer = (target === container);</span><br><span class=\"line\">            <span class=\"comment\">// 测试target是否符合selector filter</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Y.Selector.test(target, filter, (isContainer ? <span class=\"literal\">null</span> : container))) &#123;</span><br><span class=\"line\">                match.push(target);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isContainer) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            target = target.parentNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// filter是function</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将target节点作为function filter的第一个参数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数为事件对象</span></span><br><span class=\"line\">        args.unshift(Y.one(target));</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Y.DOMEventFacade(e, container, ce);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// function filter中this指向target</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filter.apply(args[<span class=\"number\">0</span>], args)) &#123;</span><br><span class=\"line\">                match.push(target);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target === container) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 更新target</span></span><br><span class=\"line\">            target = target.parentNode;</span><br><span class=\"line\">            args[<span class=\"number\">0</span>] = Y.one(target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 恢复args对象</span></span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = e;</span><br><span class=\"line\">        args.shift();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> match.length &lt;= <span class=\"number\">1</span> ? match[<span class=\"number\">0</span>] : match;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.delegate = Y.Event.delegate = delegate;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h2><h3 id=\"批量代理\"><a href=\"#批量代理\" class=\"headerlink\" title=\"批量代理\"></a>批量代理</h3><p><code>Y.delegate</code>支持同时代理多种类型的事件，调用方式有如下两种：</p>\n<ul>\n<li>Y.delegate({ typeA: fnA, typeB: fnB }, el, filter)</li>\n<li>Y.delegate([typeA, typeB], fn, el, filter)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>);</span><br><span class=\"line\">    ndList.delegate(&#123;</span><br><span class=\"line\">        <span class=\"attr\">click</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.halt();</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">dblclick</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.halt();</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// double click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;dblclick&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate([<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"string\">&#x27;dblclick&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// double click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;dblclick&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改回调函数this，传递数据\"><a href=\"#修改回调函数this，传递数据\" class=\"headerlink\" title=\"修改回调函数this，传递数据\"></a>修改回调函数this，传递数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;ul&#x27;</span>).delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, args</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(args.data);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>, <span class=\"built_in\">document</span>.body, &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;data&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;true&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;data&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"focus、blur事件的代理\"><a href=\"#focus、blur事件的代理\" class=\"headerlink\" title=\"focus、blur事件的代理\"></a>focus、blur事件的代理</h3><p>在DOM规范中，诸如focus、blur、load、unload、resize等事件是不冒泡的，因为这类事件只限定在某个节点上触发。但focus和blur事件有些特殊，在表单交互方面十分常用，如果能够支持冒泡，那么通过事件代理可以减少很多监听事件的操作。滑稽的是，focusin、focusout两个类似的事件却支持冒泡。</p>\n<p>令人欣喜的是，YUI通过定义新的DOM事件实现了focus、blur事件的代理，awesome！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例6</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"string\">&#x27;event-focus&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;form&#x27;</span>).delegate(&#123;</span><br><span class=\"line\">        <span class=\"attr\">focus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 清除错误提示</span></span><br><span class=\"line\">            clearErr(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">blur</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果内容为空，则提示错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;value&#x27;</span>) === <span class=\"string\">&#x27;&#x27;</span>) showErr(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;input&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clearErr</span>(<span class=\"params\">nd</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ndErr = nd.next(<span class=\"string\">&#x27;.error&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ndErr) ndErr.hide().setHTML(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showErr</span>(<span class=\"params\">nd</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ndErr = nd.next(<span class=\"string\">&#x27;.error&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ndErr) &#123;</span><br><span class=\"line\">            ndErr = Y.Node.create(<span class=\"string\">&#x27;&lt;span class=&quot;error&quot;&gt;&lt;/span&gt;&#x27;</span>);</span><br><span class=\"line\">            nd.insert(ndErr, <span class=\"string\">&#x27;after&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ndErr.show().setHTML(<span class=\"string\">&#x27;请输入内容&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>所有示例代码均在<a href=\"https://github.com/springuper/yuianalyser/tree/master/event\">GitHub</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/event/#delegation\">YUILibrary-UserGuides-Event Delegation</a></li>\n<li><a href=\"http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/\">Event delegation in JavaScript</a></li>\n<li><a href=\"https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js\">YUILibrary-delegate</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/delegate.jpg\" alt=\"relay baton\"></p>\n<p>在介绍了YUI自定义事件体系和对DOM事件的封装后，本篇文章重点阐述事件方面的一种常用技术——事件代理。事件代理（Event Delegation，又称事件委托）充分运用事件传播模型，用一种十分优雅的方式实现了批量节点事件监听。具体的原理和优点请移步zakas比较古老的一篇文章<a href=\"http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/\">Event delegation in JavaScript</a>。事件代理在YUI中的实现为<code>Y.delegate</code>。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>为方便讨论，约定以下名称：</p>\n<ul>\n<li>代理节点：实际监听事件的节点。在事件传播到此节点时判断是否符合代理条件，符合则执行回调函数。</li>\n<li>被代理节点：希望监听事件的节点。如果不采用事件代理，那么应该直接监听这些节点的事件。</li>\n<li>目标节点：事件发生的目标节点，即<code>event.target</code>。</li>\n</ul>\n<p>三者的层次关系从内到外依次为：目标节点 &lt;= 被代理节点 &lt;= 代理节点。</p>","more":"<p>假设html为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://google.com&quot;</span>&gt;</span>google<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;facebook&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://facebook.com&quot;</span>&gt;</span>facebook<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;twitter&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://twitter.com&quot;</span>&gt;</span>twitter<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>先来看下<code>Y.delegate</code>的简单用法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"comment\">// API: Y.delegate(type, fn, el, filter)</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handle = Y.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Y.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;A is clicked&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    handle.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor again</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，回调函数中的this指向的是使用<code>Y.Node</code>包装的被代理节点。</p>\n<p>YUI3新加入的<code>Y.Node</code>对象也封装了delegate，例1更常见的实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"comment\">// API: Y.Node.prototype.delegate(type, fn, filter)</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>),</span><br><span class=\"line\">        handle;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;A is clicked&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    handle.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click first anchor again</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>筛选条件除了例1中使用的selector外，还支持函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;tagName&#x27;</span>) + <span class=\"string\">&#x27; is clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nd, e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nd.get(<span class=\"string\">&#x27;name&#x27;</span>) &amp;&amp;</span><br><span class=\"line\">               e.target.get(<span class=\"string\">&#x27;tagName&#x27;</span>).toLowerCase() === <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// no output</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the second anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;LI is clicked&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js\">源码</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toArray = Y.Array,</span><br><span class=\"line\">    isString = Y.Lang.isString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">type, fn, el, filter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> container = isString(el) ? Y.Selector.query(el, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>) : el,</span><br><span class=\"line\">        handle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听代理节点的type事件</span></span><br><span class=\"line\">    handle = Y.Event._attach([type, fn, container], &#123; <span class=\"attr\">facade</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\">    handle.sub.filter  = filter;</span><br><span class=\"line\">    <span class=\"comment\">// 改写事件触发回调函数</span></span><br><span class=\"line\">    handle.sub._notify = delegate.notifySub;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 代理节点触发事件时的回调函数</span></span><br><span class=\"line\">delegate.notifySub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisObj, args, ce</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算符合filter的被代理节点集合</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTarget = delegate._applyFilter(<span class=\"built_in\">this</span>.filter, args, ce),</span><br><span class=\"line\">        e, i, len, ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!currentTarget) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentTarget = toArray(currentTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成事件对象</span></span><br><span class=\"line\">    e = args[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Y.DOMEventFacade(args[<span class=\"number\">0</span>], ce.el, ce);</span><br><span class=\"line\">    <span class=\"comment\">// 将代理节点保存在事件对象container属性上，方便回调函数调用</span></span><br><span class=\"line\">    e.container = Y.one(ce.el);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, len = currentTarget.length; i &lt; len &amp;&amp; !e.stopped; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将被代理节点保存在事件对象currentTarget属性上</span></span><br><span class=\"line\">        e.currentTarget = Y.one(currentTarget[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调函数中的this指向被代理节点</span></span><br><span class=\"line\">        ret = <span class=\"built_in\">this</span>.fn.apply(e.currentTarget, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret === <span class=\"literal\">false</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算符合filter的被代理节点集合</span></span><br><span class=\"line\">delegate._applyFilter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filter, args, ce</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> e         = args[<span class=\"number\">0</span>],</span><br><span class=\"line\">        container = ce.el,</span><br><span class=\"line\">        target    = e.target || e.srcElement,</span><br><span class=\"line\">        match     = [],</span><br><span class=\"line\">        isContainer = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理事件目标节点为文本节点的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.nodeType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        target = target.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// filter是selector</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isString(filter)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (target) &#123;</span><br><span class=\"line\">            isContainer = (target === container);</span><br><span class=\"line\">            <span class=\"comment\">// 测试target是否符合selector filter</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Y.Selector.test(target, filter, (isContainer ? <span class=\"literal\">null</span> : container))) &#123;</span><br><span class=\"line\">                match.push(target);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isContainer) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            target = target.parentNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// filter是function</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将target节点作为function filter的第一个参数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数为事件对象</span></span><br><span class=\"line\">        args.unshift(Y.one(target));</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Y.DOMEventFacade(e, container, ce);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// function filter中this指向target</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filter.apply(args[<span class=\"number\">0</span>], args)) &#123;</span><br><span class=\"line\">                match.push(target);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target === container) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 更新target</span></span><br><span class=\"line\">            target = target.parentNode;</span><br><span class=\"line\">            args[<span class=\"number\">0</span>] = Y.one(target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 恢复args对象</span></span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = e;</span><br><span class=\"line\">        args.shift();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> match.length &lt;= <span class=\"number\">1</span> ? match[<span class=\"number\">0</span>] : match;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.delegate = Y.Event.delegate = delegate;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h2><h3 id=\"批量代理\"><a href=\"#批量代理\" class=\"headerlink\" title=\"批量代理\"></a>批量代理</h3><p><code>Y.delegate</code>支持同时代理多种类型的事件，调用方式有如下两种：</p>\n<ul>\n<li>Y.delegate({ typeA: fnA, typeB: fnB }, el, filter)</li>\n<li>Y.delegate([typeA, typeB], fn, el, filter)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ndList = Y.one(<span class=\"string\">&#x27;ul&#x27;</span>);</span><br><span class=\"line\">    ndList.delegate(&#123;</span><br><span class=\"line\">        <span class=\"attr\">click</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.halt();</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">dblclick</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.halt();</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// double click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;dblclick&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ndList.delegate([<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"string\">&#x27;dblclick&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(e.type);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// double click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;click&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;dblclick&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改回调函数this，传递数据\"><a href=\"#修改回调函数this，传递数据\" class=\"headerlink\" title=\"修改回调函数this，传递数据\"></a>修改回调函数this，传递数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;ul&#x27;</span>).delegate(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, args</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(args.data);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;li&#x27;</span>, <span class=\"built_in\">document</span>.body, &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;data&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click the first anchor</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;true&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;data&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"focus、blur事件的代理\"><a href=\"#focus、blur事件的代理\" class=\"headerlink\" title=\"focus、blur事件的代理\"></a>focus、blur事件的代理</h3><p>在DOM规范中，诸如focus、blur、load、unload、resize等事件是不冒泡的，因为这类事件只限定在某个节点上触发。但focus和blur事件有些特殊，在表单交互方面十分常用，如果能够支持冒泡，那么通过事件代理可以减少很多监听事件的操作。滑稽的是，focusin、focusout两个类似的事件却支持冒泡。</p>\n<p>令人欣喜的是，YUI通过定义新的DOM事件实现了focus、blur事件的代理，awesome！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例6</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node-event-delegate&#x27;</span>, <span class=\"string\">&#x27;event-focus&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;form&#x27;</span>).delegate(&#123;</span><br><span class=\"line\">        <span class=\"attr\">focus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 清除错误提示</span></span><br><span class=\"line\">            clearErr(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">blur</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果内容为空，则提示错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;value&#x27;</span>) === <span class=\"string\">&#x27;&#x27;</span>) showErr(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;input&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clearErr</span>(<span class=\"params\">nd</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ndErr = nd.next(<span class=\"string\">&#x27;.error&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ndErr) ndErr.hide().setHTML(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showErr</span>(<span class=\"params\">nd</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ndErr = nd.next(<span class=\"string\">&#x27;.error&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ndErr) &#123;</span><br><span class=\"line\">            ndErr = Y.Node.create(<span class=\"string\">&#x27;&lt;span class=&quot;error&quot;&gt;&lt;/span&gt;&#x27;</span>);</span><br><span class=\"line\">            nd.insert(ndErr, <span class=\"string\">&#x27;after&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ndErr.show().setHTML(<span class=\"string\">&#x27;请输入内容&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>所有示例代码均在<a href=\"https://github.com/springuper/yuianalyser/tree/master/event\">GitHub</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/event/#delegation\">YUILibrary-UserGuides-Event Delegation</a></li>\n<li><a href=\"http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/\">Event delegation in JavaScript</a></li>\n<li><a href=\"https://github.com/yui/yui3/blob/v3.9.1/src/event/js/delegate.js\">YUILibrary-delegate</a></li>\n</ul>"},{"layout":"post","title":"YUI事件体系之Y.CustomEvent","date":"2012-09-01T11:13:00.000Z","comments":1,"status":"publish","_content":"\n![DIY](/images/DIY.jpg)\n\n上一篇[文章](/2013/01/20/event-do/)中，简要介绍了YUI实现AOP的`Y.Do`对象。\n\n接下来，我们继续对YUI事件体系进行探索。本次要介绍的是`Y.CustomEvent`对象，从命名上就可以看出，这个对象在整个YUI事件体系中十分重要。它建立起整个自定义事件的体系，而且，DOM事件也构建在这个体系之上。\n\n## Y.Subscriber\n\nY.Subscriber的作用比较简单：执行回调函数。\n\n```javascript\nY.Subscriber = function (fn, context) {\n    this.fn = fn; // 回调函数\n    this.context = context; // 上下文\n    this.id = Y.stamp(this); // 设置唯一id\n};\nY.Subscriber.prototype = {\n    constructor: Y.Subscriber,\n    // 执行回调函数\n    notify: function (args, ce) {\n        if (this.deleted) return null;\n        var ret;\n\n        ret = this.fn.apply(this.context, args || []);\n        // 只监听一次\n        if (this.once) {\n            ce._delete(this);\n        }\n\n        return ret;\n    }\n};\n```\n\n## Y.CustomEvent\n\n`Y.CustomEvent`主要作用是：建立自定义事件机制，为方便的进行事件创建、监听、触发提供良好基础。自定义事件机制，实际上是[Observer Pattern](http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)（[Publish–subscribe Pattern](http://en.wikipedia.org/wiki/Observer_pattern)的演化）的一种实现，这种机制能够方便的实现模块间解耦，增强模块的扩展性。\n\nYUI的自定义事件较其它一些js库来说要强大一些，有这样一些好的features：\n\n- 支持事件接口(Event Facade)，在回调函数中可以进行调用\n- 支持设置默认执行方法\n- 支持停止/立即停止传播，并可设定停止传播时执行的方法\n- 支持阻止默认行为(默认执行方法)，并可设定阻止默认行为时执行的方法\n- 支持冒泡。指定冒泡目标序列，就可以顺序的触发事件(需要`Y.EventTarget`)\n- 支持广播。每个自定义事件，都可以设置在当前YUI实例范围内和全局YUI内进行广播\n\n可以看出，YUI的自定义事件和DOM事件极其类似，这种设计自然到我们在用自定义事件时，丝毫感觉不到和DOM事件的差异。\n\n<!-- more -->\n\n### 示例\n\n让我们先来看个简单的例子：\n\n```javascript\n// 例1 简单自定义事件\nYUI().use('event-custom', function (Y) {\n    var eatEvent = new Y.CustomEvent('eat');\n    var onHandle = eatEvent.on(function () {\n        Y.log('before eating');\n    });\n    var onHandle2 = eatEvent.on(function () {\n        Y.log('before eating, too');\n    });\n    var afterHandle = eatEvent.after(function () {\n        Y.log('after eating');\n    }); \n\n    // output: \"before eating\", \"before eating, too\", \"after eating\"\n    eatEvent.fire();\n\n    onHandle2.detach();\n    // output: \"before eating\", \"after eating\"\n    eatEvent.fire();\n});\n```\n\n有些事件只需触发一次，比如你的各种第一次～～～。来看这个例子：\n```javascript\n// 例2 仅触发一次的自定义事件\nYUI().use('event-custom', function (Y) {\n    var birthEvent = new Y.CustomEvent('birth', {\n        fireOnce: true  // you can only birth once\n    });\n    var onBirthHandle = birthEvent.on(function () {\n        Y.log('before birth');\n    });\n\n    // output: \"before birth\"\n    birthEvent.fire();\n    // nothing happened\n    birthEvent.fire();\n\n    // 只触发一次的事件在触发后，再次添加监听方法时，会被立即执行\n    // output: before birth, too\n    var onBirthHandle2 = birthEvent.on(function () {\n        Y.log('before birth, too');\n    });\n});\n```\n\n也许你还在琢磨，事件广播是什么？因为YUI使用了sandbox设计，可以生成不同实例绑定不同api，所以才有了事件广播机制。来看这个例子：\n\n```javascript\n// 例3 事件广播\nYUI().use('event-custom', function (Y) {\n    var cryEvent = new Y.CustomEvent('cry', {\n        broadcast: 2  // global broadcast\n    });\n    cryEvent.on(function () {\n        Y.log('before cry');\n    });\n    Y.on('cry', function () {\n        Y.log('YUI instance broadcast');\n    });\n    Y.Global.on('cry', function () {\n        Y.log('YUI global broadcast');\n    });\n\n    // output: \"before cry\", \"YUI instance broadcast\", \"YUI global broadcast\"\n    cryEvent.fire();\n});\n```\n\n文章之前介绍过YUI自定义事件的种种NB之处，那么用起来如何呢，来看下面的例子：\n\n```javascript\n// 例4 复杂自定义事件\nYUI().use('event-custom', function (Y) {\n    var driveEvent = new Y.CustomEvent('drive', {\n        emitFacade: true,\n        host: {  // hacking. 复杂自定义事件需要指定host，该host必须augment Y.EventTarget\n            _yuievt: {},\n            _monitor: function () {}\n        },\n        defaultFn: function () {\n            Y.log('execute defaultFn');\n        },\n        preventedFn: function () {\n            Y.log('execute preventedFn');\n        },\n        stoppedFn: function () {\n            Y.log('execute stoppedFn');\n        }\n    });\n    driveEvent.on(function (e) {\n        e.stopImmediatePropagation();\n    });\n    driveEvent.on(function (e) {\n        e.preventDefault();\n    });\n    driveEvent.after(function (e) {\n        Y.log('after driving');\n    });\n\n    // output: \"execute stoppedFn\", \"execute defaultFn\"\n    driveEvent.fire();\n});\n```\n\n不要失望，现在还没有介绍到事件体系的精华部分`Y.EventTarget`，所以很多特性（例如冒泡）还不能体现出来，拭目以待吧。\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38)。\n\n```javascript\nvar AFTER = 'after',\n    // config白名单\n    CONFIGS = ['broadcast', 'monitored', 'bubbles', 'context', 'contextFn', 'currentTarget', 'defaultFn', 'defaultTargetOnly', 'details', 'emitFacade', 'fireOnce', 'async', 'host', 'preventable', 'preventedFn', 'queuable', 'silent', 'stoppedFn', 'target', 'type'];\n\nY.CustomEvent = function (type, o) {\n    this.id = Y.stamp(this);\n    this.type = type;\n    this.context = Y;\n    this.preventable = true;\n    this.bubbles = true;\n    this.subscribers = {}; // (前置)监听对象容器 注：YUI3.7.0将此处进行了优化\n    this.afters = {}; // 后置监听对象容器 注：YUI3.7.0将此处进行了优化\n    this.subCount = 0;\n    this.afterCount = 0;\n\n    o = o || {};\n    this.applyConfig(o, true);\n};\nY.CustomEvent.prototype = {\n    constructor: Y.CustomEvent,\n    // 设置参数\n    applyConfig: function (o, force) {\n        if (o) {\n            Y.mix(this, o, force, CONFIGS);\n        }\n    },\n\n    // 添加前置监听对象\n    on: function (fn, context) {\n        var a = (arguments.length &gt; 2) ? Y.Array(arguments, 2, true) : null;\n        return this._on(fn, context, a, true);\n    },\n    // 添加后置监听对象\n    after: function (fn, context) {\n        var a = (arguments.length &gt; 2) ? Y.Array(arguments, 2, true) : null;\n        return this._on(fn, context, a, AFTER);\n    },\n    // 内部添加监听对象\n    _on: function (fn, context, args, when) {\n        var s = new Y.Subscriber(fn, context);\n\n        if (this.fireOnce &amp;&amp; this.fired) {\n            // 仅触发一次的事件在触发后，再次添加监听方法时，会被立即执行\n            this._notify(s, this.firedWith);\n        }\n\n        if (when == AFTER) {\n            this.afters[s.id] = s;\n            this.afterCount++;\n        } else {\n            this.subscribers[s.id] = s;\n            this.subCount++;\n        }\n\n        return new Y.EventHandle(this, s);\n    },\n\n    // 触发事件\n    fire: function () {\n        if (this.fireOnce &amp;&amp; this.fired) {\n            // 仅触发一次的事件，如果已经触发过，直接返回true\n            return true;\n        } else {\n            // 可以设置参数，传给回调函数\n            var args = Y.Array(arguments, 0, true);\n\n            this.fired = true;\n            this.firedWith = args;\n\n            if (this.emitFacade) {\n                // 复杂事件\n                return this.fireComplex(args);\n            } else {\n                return this.fireSimple(args);\n            }\n        }\n    },\n    // 触发简单事件\n    fireSimple: function (args) {\n        this.stopped = 0;\n        this.prevented = 0;\n        if (this.hasSubs()) {\n            var subs = this.getSubs();\n            // 处理前置监听对象\n            this._procSubs(subs[0], args);\n            // 处理前置监听对象\n            this._procSubs(subs[1], args);\n        }\n        this._broadcast(args);\n        return this.stopped ? false : true;\n    },\n    // 判断是否有监听对象\n    hasSubs: function (when) {\n        var s = this.subCount,\n            a = this.afterCount;\n        if (when) {\n            return (when == 'after') ? a : s;\n        }\n        return (s + a);\n    },\n    // 获取所有前置／后置监听对象\n    getSubs: function () {\n        var s = Y.merge(this.subscribers),\n            a = Y.merge(this.afters);\n        return [s, a];\n    },\n    // 获取监听对象\n    _procSubs: function (subs, args, ef) {\n        var s, i;\n        for (i in subs) {\n            if (subs.hasOwnProperty(i)) {\n                s = subs[i];\n                if (s && s.fn) {\n                    if (false === this._notify(s, args, ef)) {\n                        // 回调返回false时，立即停止处理后续回调\n                        this.stopped = 2;\n                    }\n                    if (this.stopped == 2) {\n                        // 立即停止处理后续回调，方便实现stopImmediatePropagation\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n    // 通知监听对象，执行回调方法\n    _notify: function (s, args, ef) {\n        var ret = s.notify(args, this);\n        if (false === ret || this.stopped &gt; 1) {\n            return false;\n        }\n        return true;\n    },\n    // 广播事件\n    _broadcast: function (args) {\n        if (!this.stopped &amp;&amp; this.broadcast) {\n            var a = Y.Array(args);\n            a.unshift(this.type);\n\n            // 在当前YUI实例Y上广播\n            if (this.host !== Y) {\n                Y.fire.apply(Y, a);\n            }\n\n            // 在全局对象YUI上广播，跨实例\n            if (this.broadcast == 2) {\n                Y.Global.fire.apply(Y.Global, a);\n            }\n        }\n    },\n\n    // TODO: 在下一篇介绍Y.EventTarget的文章中再做介绍\n    fireComplex: function (args) {},\n\n    // 移除监听器\n    detach: function (fn, context) {\n        // unsubscribe handle\n        if (fn &amp;&amp; fn.detach) {\n            return fn.detach();\n        }\n\n        var i, s,\n            found = 0,\n            subs = Y.merge(this.subscribers, this.afters);\n\n        for (i in subs) {\n            if (subs.hasOwnProperty(i)) {\n                s = subs[i];\n                if (s &amp;&amp; (!fn || fn === s.fn)) {\n                    this._delete(s);\n                    found++;\n                }\n            }\n        }\n\n        return found;\n    },\n    _delete: function (s) {\n        if (s) {\n            if (this.subscribers[s.id]) {\n                delete this.subscribers[s.id];\n                this.subCount--;\n            }\n            if (this.afters[s.id]) {\n                delete this.afters[s.id];\n                this.afterCount--;\n            }\n        }\n\n        if (s) {\n            s.deleted = true;\n        }\n    }\n};\n```\n\n### 适用场景\n自定义事件的适用场景与Publish–subscribe Pattern基本一致。具体来讲，我觉得以下一些场景是非常适合用自定义事件的：\n\n#### a) 需要暴露接口/行为以满足扩展需要\n\n底层模块一般会设计的尽量简单，解决核心问题，并适当的开放一些接口，方便应用层进行扩展以满足实际需求。例如表单验证控件，有可能需要在某个表单项验证成功/失败后执行一些额外操作，举一个实际的例子：当用户输入的邮箱地址验证成功时，我们会检查是不是某些比较烂的邮件服务商，如果是则给出一些建议。\n\nYUI作为一个底层基础库，在组件/控件层面加入了大量的自定义事件，以满足实际应用中的需要。例如`Y.Anim`的start、end事件，`Y.io`的success、failure、end事件，`Y.Attribute`中的属性变化事件等。\n\n#### b) 行为可能会被其它模块/方法中止\n\n这一点非常像DOM事件，我们经常会中止一些事件的默认行为，例如anchor的点击事件。\n\n### 自定义事件 VS 回调函数\n\n这是一个比较难的问题，我自己的看法是：相对回调函数，自定义事件是一种更重但更灵活的方案。在实际应用中，如果对于关心某消息的受众不够清楚，那么就使用事件。否则，比较适合使用回调函数。\n\n[MSDN](http://msdn.microsoft.com/en-us/library/aa733743%28v=vs.60%29.aspx)上的解释更好一些：“An event is like an anonymous broadcast, while a call-back is like a handshake. The corollary of this is that a component that raises events knows nothing about its clients, while a component that makes call-backs knows a great deal”。\n\n另外，如果对于性能特别关心，在可能的情况下，尽量使用回调。\n\n## 参考\n- [YUILibrary-CustomEvent](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n- [Wikipedia-Publish–subscribe Pattern](http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)\n- [Zakas-Custom events in JavaScript](http://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/)\n- [When to Use Events or Call-Backs for Notifications][1]\n\n[1]:http://msdn.microsoft.com/en-us/library/aa733743(v=vs.60).aspx\n","source":"_posts/event-custom.md","raw":"---\nlayout: post\ntitle: \"YUI事件体系之Y.CustomEvent\"\ndate: 2012-09-01 19:13\ncomments: true\nstatus: publish\ntags: [YUI, Event, JavaScript]\n---\n\n![DIY](/images/DIY.jpg)\n\n上一篇[文章](/2013/01/20/event-do/)中，简要介绍了YUI实现AOP的`Y.Do`对象。\n\n接下来，我们继续对YUI事件体系进行探索。本次要介绍的是`Y.CustomEvent`对象，从命名上就可以看出，这个对象在整个YUI事件体系中十分重要。它建立起整个自定义事件的体系，而且，DOM事件也构建在这个体系之上。\n\n## Y.Subscriber\n\nY.Subscriber的作用比较简单：执行回调函数。\n\n```javascript\nY.Subscriber = function (fn, context) {\n    this.fn = fn; // 回调函数\n    this.context = context; // 上下文\n    this.id = Y.stamp(this); // 设置唯一id\n};\nY.Subscriber.prototype = {\n    constructor: Y.Subscriber,\n    // 执行回调函数\n    notify: function (args, ce) {\n        if (this.deleted) return null;\n        var ret;\n\n        ret = this.fn.apply(this.context, args || []);\n        // 只监听一次\n        if (this.once) {\n            ce._delete(this);\n        }\n\n        return ret;\n    }\n};\n```\n\n## Y.CustomEvent\n\n`Y.CustomEvent`主要作用是：建立自定义事件机制，为方便的进行事件创建、监听、触发提供良好基础。自定义事件机制，实际上是[Observer Pattern](http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)（[Publish–subscribe Pattern](http://en.wikipedia.org/wiki/Observer_pattern)的演化）的一种实现，这种机制能够方便的实现模块间解耦，增强模块的扩展性。\n\nYUI的自定义事件较其它一些js库来说要强大一些，有这样一些好的features：\n\n- 支持事件接口(Event Facade)，在回调函数中可以进行调用\n- 支持设置默认执行方法\n- 支持停止/立即停止传播，并可设定停止传播时执行的方法\n- 支持阻止默认行为(默认执行方法)，并可设定阻止默认行为时执行的方法\n- 支持冒泡。指定冒泡目标序列，就可以顺序的触发事件(需要`Y.EventTarget`)\n- 支持广播。每个自定义事件，都可以设置在当前YUI实例范围内和全局YUI内进行广播\n\n可以看出，YUI的自定义事件和DOM事件极其类似，这种设计自然到我们在用自定义事件时，丝毫感觉不到和DOM事件的差异。\n\n<!-- more -->\n\n### 示例\n\n让我们先来看个简单的例子：\n\n```javascript\n// 例1 简单自定义事件\nYUI().use('event-custom', function (Y) {\n    var eatEvent = new Y.CustomEvent('eat');\n    var onHandle = eatEvent.on(function () {\n        Y.log('before eating');\n    });\n    var onHandle2 = eatEvent.on(function () {\n        Y.log('before eating, too');\n    });\n    var afterHandle = eatEvent.after(function () {\n        Y.log('after eating');\n    }); \n\n    // output: \"before eating\", \"before eating, too\", \"after eating\"\n    eatEvent.fire();\n\n    onHandle2.detach();\n    // output: \"before eating\", \"after eating\"\n    eatEvent.fire();\n});\n```\n\n有些事件只需触发一次，比如你的各种第一次～～～。来看这个例子：\n```javascript\n// 例2 仅触发一次的自定义事件\nYUI().use('event-custom', function (Y) {\n    var birthEvent = new Y.CustomEvent('birth', {\n        fireOnce: true  // you can only birth once\n    });\n    var onBirthHandle = birthEvent.on(function () {\n        Y.log('before birth');\n    });\n\n    // output: \"before birth\"\n    birthEvent.fire();\n    // nothing happened\n    birthEvent.fire();\n\n    // 只触发一次的事件在触发后，再次添加监听方法时，会被立即执行\n    // output: before birth, too\n    var onBirthHandle2 = birthEvent.on(function () {\n        Y.log('before birth, too');\n    });\n});\n```\n\n也许你还在琢磨，事件广播是什么？因为YUI使用了sandbox设计，可以生成不同实例绑定不同api，所以才有了事件广播机制。来看这个例子：\n\n```javascript\n// 例3 事件广播\nYUI().use('event-custom', function (Y) {\n    var cryEvent = new Y.CustomEvent('cry', {\n        broadcast: 2  // global broadcast\n    });\n    cryEvent.on(function () {\n        Y.log('before cry');\n    });\n    Y.on('cry', function () {\n        Y.log('YUI instance broadcast');\n    });\n    Y.Global.on('cry', function () {\n        Y.log('YUI global broadcast');\n    });\n\n    // output: \"before cry\", \"YUI instance broadcast\", \"YUI global broadcast\"\n    cryEvent.fire();\n});\n```\n\n文章之前介绍过YUI自定义事件的种种NB之处，那么用起来如何呢，来看下面的例子：\n\n```javascript\n// 例4 复杂自定义事件\nYUI().use('event-custom', function (Y) {\n    var driveEvent = new Y.CustomEvent('drive', {\n        emitFacade: true,\n        host: {  // hacking. 复杂自定义事件需要指定host，该host必须augment Y.EventTarget\n            _yuievt: {},\n            _monitor: function () {}\n        },\n        defaultFn: function () {\n            Y.log('execute defaultFn');\n        },\n        preventedFn: function () {\n            Y.log('execute preventedFn');\n        },\n        stoppedFn: function () {\n            Y.log('execute stoppedFn');\n        }\n    });\n    driveEvent.on(function (e) {\n        e.stopImmediatePropagation();\n    });\n    driveEvent.on(function (e) {\n        e.preventDefault();\n    });\n    driveEvent.after(function (e) {\n        Y.log('after driving');\n    });\n\n    // output: \"execute stoppedFn\", \"execute defaultFn\"\n    driveEvent.fire();\n});\n```\n\n不要失望，现在还没有介绍到事件体系的精华部分`Y.EventTarget`，所以很多特性（例如冒泡）还不能体现出来，拭目以待吧。\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38)。\n\n```javascript\nvar AFTER = 'after',\n    // config白名单\n    CONFIGS = ['broadcast', 'monitored', 'bubbles', 'context', 'contextFn', 'currentTarget', 'defaultFn', 'defaultTargetOnly', 'details', 'emitFacade', 'fireOnce', 'async', 'host', 'preventable', 'preventedFn', 'queuable', 'silent', 'stoppedFn', 'target', 'type'];\n\nY.CustomEvent = function (type, o) {\n    this.id = Y.stamp(this);\n    this.type = type;\n    this.context = Y;\n    this.preventable = true;\n    this.bubbles = true;\n    this.subscribers = {}; // (前置)监听对象容器 注：YUI3.7.0将此处进行了优化\n    this.afters = {}; // 后置监听对象容器 注：YUI3.7.0将此处进行了优化\n    this.subCount = 0;\n    this.afterCount = 0;\n\n    o = o || {};\n    this.applyConfig(o, true);\n};\nY.CustomEvent.prototype = {\n    constructor: Y.CustomEvent,\n    // 设置参数\n    applyConfig: function (o, force) {\n        if (o) {\n            Y.mix(this, o, force, CONFIGS);\n        }\n    },\n\n    // 添加前置监听对象\n    on: function (fn, context) {\n        var a = (arguments.length &gt; 2) ? Y.Array(arguments, 2, true) : null;\n        return this._on(fn, context, a, true);\n    },\n    // 添加后置监听对象\n    after: function (fn, context) {\n        var a = (arguments.length &gt; 2) ? Y.Array(arguments, 2, true) : null;\n        return this._on(fn, context, a, AFTER);\n    },\n    // 内部添加监听对象\n    _on: function (fn, context, args, when) {\n        var s = new Y.Subscriber(fn, context);\n\n        if (this.fireOnce &amp;&amp; this.fired) {\n            // 仅触发一次的事件在触发后，再次添加监听方法时，会被立即执行\n            this._notify(s, this.firedWith);\n        }\n\n        if (when == AFTER) {\n            this.afters[s.id] = s;\n            this.afterCount++;\n        } else {\n            this.subscribers[s.id] = s;\n            this.subCount++;\n        }\n\n        return new Y.EventHandle(this, s);\n    },\n\n    // 触发事件\n    fire: function () {\n        if (this.fireOnce &amp;&amp; this.fired) {\n            // 仅触发一次的事件，如果已经触发过，直接返回true\n            return true;\n        } else {\n            // 可以设置参数，传给回调函数\n            var args = Y.Array(arguments, 0, true);\n\n            this.fired = true;\n            this.firedWith = args;\n\n            if (this.emitFacade) {\n                // 复杂事件\n                return this.fireComplex(args);\n            } else {\n                return this.fireSimple(args);\n            }\n        }\n    },\n    // 触发简单事件\n    fireSimple: function (args) {\n        this.stopped = 0;\n        this.prevented = 0;\n        if (this.hasSubs()) {\n            var subs = this.getSubs();\n            // 处理前置监听对象\n            this._procSubs(subs[0], args);\n            // 处理前置监听对象\n            this._procSubs(subs[1], args);\n        }\n        this._broadcast(args);\n        return this.stopped ? false : true;\n    },\n    // 判断是否有监听对象\n    hasSubs: function (when) {\n        var s = this.subCount,\n            a = this.afterCount;\n        if (when) {\n            return (when == 'after') ? a : s;\n        }\n        return (s + a);\n    },\n    // 获取所有前置／后置监听对象\n    getSubs: function () {\n        var s = Y.merge(this.subscribers),\n            a = Y.merge(this.afters);\n        return [s, a];\n    },\n    // 获取监听对象\n    _procSubs: function (subs, args, ef) {\n        var s, i;\n        for (i in subs) {\n            if (subs.hasOwnProperty(i)) {\n                s = subs[i];\n                if (s && s.fn) {\n                    if (false === this._notify(s, args, ef)) {\n                        // 回调返回false时，立即停止处理后续回调\n                        this.stopped = 2;\n                    }\n                    if (this.stopped == 2) {\n                        // 立即停止处理后续回调，方便实现stopImmediatePropagation\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n    // 通知监听对象，执行回调方法\n    _notify: function (s, args, ef) {\n        var ret = s.notify(args, this);\n        if (false === ret || this.stopped &gt; 1) {\n            return false;\n        }\n        return true;\n    },\n    // 广播事件\n    _broadcast: function (args) {\n        if (!this.stopped &amp;&amp; this.broadcast) {\n            var a = Y.Array(args);\n            a.unshift(this.type);\n\n            // 在当前YUI实例Y上广播\n            if (this.host !== Y) {\n                Y.fire.apply(Y, a);\n            }\n\n            // 在全局对象YUI上广播，跨实例\n            if (this.broadcast == 2) {\n                Y.Global.fire.apply(Y.Global, a);\n            }\n        }\n    },\n\n    // TODO: 在下一篇介绍Y.EventTarget的文章中再做介绍\n    fireComplex: function (args) {},\n\n    // 移除监听器\n    detach: function (fn, context) {\n        // unsubscribe handle\n        if (fn &amp;&amp; fn.detach) {\n            return fn.detach();\n        }\n\n        var i, s,\n            found = 0,\n            subs = Y.merge(this.subscribers, this.afters);\n\n        for (i in subs) {\n            if (subs.hasOwnProperty(i)) {\n                s = subs[i];\n                if (s &amp;&amp; (!fn || fn === s.fn)) {\n                    this._delete(s);\n                    found++;\n                }\n            }\n        }\n\n        return found;\n    },\n    _delete: function (s) {\n        if (s) {\n            if (this.subscribers[s.id]) {\n                delete this.subscribers[s.id];\n                this.subCount--;\n            }\n            if (this.afters[s.id]) {\n                delete this.afters[s.id];\n                this.afterCount--;\n            }\n        }\n\n        if (s) {\n            s.deleted = true;\n        }\n    }\n};\n```\n\n### 适用场景\n自定义事件的适用场景与Publish–subscribe Pattern基本一致。具体来讲，我觉得以下一些场景是非常适合用自定义事件的：\n\n#### a) 需要暴露接口/行为以满足扩展需要\n\n底层模块一般会设计的尽量简单，解决核心问题，并适当的开放一些接口，方便应用层进行扩展以满足实际需求。例如表单验证控件，有可能需要在某个表单项验证成功/失败后执行一些额外操作，举一个实际的例子：当用户输入的邮箱地址验证成功时，我们会检查是不是某些比较烂的邮件服务商，如果是则给出一些建议。\n\nYUI作为一个底层基础库，在组件/控件层面加入了大量的自定义事件，以满足实际应用中的需要。例如`Y.Anim`的start、end事件，`Y.io`的success、failure、end事件，`Y.Attribute`中的属性变化事件等。\n\n#### b) 行为可能会被其它模块/方法中止\n\n这一点非常像DOM事件，我们经常会中止一些事件的默认行为，例如anchor的点击事件。\n\n### 自定义事件 VS 回调函数\n\n这是一个比较难的问题，我自己的看法是：相对回调函数，自定义事件是一种更重但更灵活的方案。在实际应用中，如果对于关心某消息的受众不够清楚，那么就使用事件。否则，比较适合使用回调函数。\n\n[MSDN](http://msdn.microsoft.com/en-us/library/aa733743%28v=vs.60%29.aspx)上的解释更好一些：“An event is like an anonymous broadcast, while a call-back is like a handshake. The corollary of this is that a component that raises events knows nothing about its clients, while a component that makes call-backs knows a great deal”。\n\n另外，如果对于性能特别关心，在可能的情况下，尽量使用回调。\n\n## 参考\n- [YUILibrary-CustomEvent](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n- [Wikipedia-Publish–subscribe Pattern](http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)\n- [Zakas-Custom events in JavaScript](http://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/)\n- [When to Use Events or Call-Backs for Notifications][1]\n\n[1]:http://msdn.microsoft.com/en-us/library/aa733743(v=vs.60).aspx\n","slug":"event-custom","published":1,"updated":"2021-10-05T09:22:23.355Z","photos":[],"link":"","_id":"cl1klgupb00098e85htfeay0o","content":"<p><img src=\"/images/DIY.jpg\" alt=\"DIY\"></p>\n<p>上一篇<a href=\"/2013/01/20/event-do/\">文章</a>中，简要介绍了YUI实现AOP的<code>Y.Do</code>对象。</p>\n<p>接下来，我们继续对YUI事件体系进行探索。本次要介绍的是<code>Y.CustomEvent</code>对象，从命名上就可以看出，这个对象在整个YUI事件体系中十分重要。它建立起整个自定义事件的体系，而且，DOM事件也构建在这个体系之上。</p>\n<h2 id=\"Y-Subscriber\"><a href=\"#Y-Subscriber\" class=\"headerlink\" title=\"Y.Subscriber\"></a>Y.Subscriber</h2><p>Y.Subscriber的作用比较简单：执行回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.Subscriber = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.fn = fn; <span class=\"comment\">// 回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.context = context; <span class=\"comment\">// 上下文</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.id = Y.stamp(<span class=\"built_in\">this</span>); <span class=\"comment\">// 设置唯一id</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Subscriber.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: Y.Subscriber,</span><br><span class=\"line\">    <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">    <span class=\"attr\">notify</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args, ce</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.deleted) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">this</span>.fn.apply(<span class=\"built_in\">this</span>.context, args || []);</span><br><span class=\"line\">        <span class=\"comment\">// 只监听一次</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.once) &#123;</span><br><span class=\"line\">            ce._delete(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-CustomEvent\"><a href=\"#Y-CustomEvent\" class=\"headerlink\" title=\"Y.CustomEvent\"></a>Y.CustomEvent</h2><p><code>Y.CustomEvent</code>主要作用是：建立自定义事件机制，为方便的进行事件创建、监听、触发提供良好基础。自定义事件机制，实际上是<a href=\"http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">Observer Pattern</a>（<a href=\"http://en.wikipedia.org/wiki/Observer_pattern\">Publish–subscribe Pattern</a>的演化）的一种实现，这种机制能够方便的实现模块间解耦，增强模块的扩展性。</p>\n<p>YUI的自定义事件较其它一些js库来说要强大一些，有这样一些好的features：</p>\n<ul>\n<li>支持事件接口(Event Facade)，在回调函数中可以进行调用</li>\n<li>支持设置默认执行方法</li>\n<li>支持停止/立即停止传播，并可设定停止传播时执行的方法</li>\n<li>支持阻止默认行为(默认执行方法)，并可设定阻止默认行为时执行的方法</li>\n<li>支持冒泡。指定冒泡目标序列，就可以顺序的触发事件(需要<code>Y.EventTarget</code>)</li>\n<li>支持广播。每个自定义事件，都可以设置在当前YUI实例范围内和全局YUI内进行广播</li>\n</ul>\n<p>可以看出，YUI的自定义事件和DOM事件极其类似，这种设计自然到我们在用自定义事件时，丝毫感觉不到和DOM事件的差异。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>让我们先来看个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1 简单自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> eatEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onHandle = eatEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before eating&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onHandle2 = eatEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before eating, too&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> afterHandle = eatEvent.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;after eating&#x27;</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before eating&quot;, &quot;before eating, too&quot;, &quot;after eating&quot;</span></span><br><span class=\"line\">    eatEvent.fire();</span><br><span class=\"line\"></span><br><span class=\"line\">    onHandle2.detach();</span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before eating&quot;, &quot;after eating&quot;</span></span><br><span class=\"line\">    eatEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有些事件只需触发一次，比如你的各种第一次～～～。来看这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2 仅触发一次的自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> birthEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;birth&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">fireOnce</span>: <span class=\"literal\">true</span>  <span class=\"comment\">// you can only birth once</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onBirthHandle = birthEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before birth&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before birth&quot;</span></span><br><span class=\"line\">    birthEvent.fire();</span><br><span class=\"line\">    <span class=\"comment\">// nothing happened</span></span><br><span class=\"line\">    birthEvent.fire();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 只触发一次的事件在触发后，再次添加监听方法时，会被立即执行</span></span><br><span class=\"line\">    <span class=\"comment\">// output: before birth, too</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onBirthHandle2 = birthEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before birth, too&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>也许你还在琢磨，事件广播是什么？因为YUI使用了sandbox设计，可以生成不同实例绑定不同api，所以才有了事件广播机制。来看这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3 事件广播</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cryEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;cry&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">broadcast</span>: <span class=\"number\">2</span>  <span class=\"comment\">// global broadcast</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    cryEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before cry&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Y.on(<span class=\"string\">&#x27;cry&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;YUI instance broadcast&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Y.Global.on(<span class=\"string\">&#x27;cry&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;YUI global broadcast&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before cry&quot;, &quot;YUI instance broadcast&quot;, &quot;YUI global broadcast&quot;</span></span><br><span class=\"line\">    cryEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>文章之前介绍过YUI自定义事件的种种NB之处，那么用起来如何呢，来看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4 复杂自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> driveEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;drive&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">host</span>: &#123;  <span class=\"comment\">// hacking. 复杂自定义事件需要指定host，该host必须augment Y.EventTarget</span></span><br><span class=\"line\">            <span class=\"attr\">_yuievt</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"attr\">_monitor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute defaultFn&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">preventedFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute preventedFn&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">stoppedFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute stoppedFn&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;after driving&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;execute stoppedFn&quot;, &quot;execute defaultFn&quot;</span></span><br><span class=\"line\">    driveEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不要失望，现在还没有介绍到事件体系的精华部分<code>Y.EventTarget</code>，所以很多特性（例如冒泡）还不能体现出来，拭目以待吧。</p>\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> AFTER = <span class=\"string\">&#x27;after&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// config白名单</span></span><br><span class=\"line\">    CONFIGS = [<span class=\"string\">&#x27;broadcast&#x27;</span>, <span class=\"string\">&#x27;monitored&#x27;</span>, <span class=\"string\">&#x27;bubbles&#x27;</span>, <span class=\"string\">&#x27;context&#x27;</span>, <span class=\"string\">&#x27;contextFn&#x27;</span>, <span class=\"string\">&#x27;currentTarget&#x27;</span>, <span class=\"string\">&#x27;defaultFn&#x27;</span>, <span class=\"string\">&#x27;defaultTargetOnly&#x27;</span>, <span class=\"string\">&#x27;details&#x27;</span>, <span class=\"string\">&#x27;emitFacade&#x27;</span>, <span class=\"string\">&#x27;fireOnce&#x27;</span>, <span class=\"string\">&#x27;async&#x27;</span>, <span class=\"string\">&#x27;host&#x27;</span>, <span class=\"string\">&#x27;preventable&#x27;</span>, <span class=\"string\">&#x27;preventedFn&#x27;</span>, <span class=\"string\">&#x27;queuable&#x27;</span>, <span class=\"string\">&#x27;silent&#x27;</span>, <span class=\"string\">&#x27;stoppedFn&#x27;</span>, <span class=\"string\">&#x27;target&#x27;</span>, <span class=\"string\">&#x27;type&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">Y.CustomEvent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.id = Y.stamp(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.type = type;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.context = Y;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preventable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.bubbles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subscribers = &#123;&#125;; <span class=\"comment\">// (前置)监听对象容器 注：YUI3.7.0将此处进行了优化</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.afters = &#123;&#125;; <span class=\"comment\">// 后置监听对象容器 注：YUI3.7.0将此处进行了优化</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.afterCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    o = o || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.applyConfig(o, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.CustomEvent.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: Y.CustomEvent,</span><br><span class=\"line\">    <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">    <span class=\"attr\">applyConfig</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o, force</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o) &#123;</span><br><span class=\"line\">            Y.mix(<span class=\"built_in\">this</span>, o, force, CONFIGS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加前置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">2</span>) ? Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._on(fn, context, a, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 添加后置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">2</span>) ? Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._on(fn, context, a, AFTER);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 内部添加监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">_on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context, args, when</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> Y.Subscriber(fn, context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.fireOnce &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.fired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅触发一次的事件在触发后，再次添加监听方法时，会被立即执行</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._notify(s, <span class=\"built_in\">this</span>.firedWith);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when == AFTER) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afters[s.id] = s;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afterCount++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.subscribers[s.id] = s;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.subCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.EventHandle(<span class=\"built_in\">this</span>, s);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    <span class=\"attr\">fire</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.fireOnce &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.fired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅触发一次的事件，如果已经触发过，直接返回true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以设置参数，传给回调函数</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.fired = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.firedWith = args;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.emitFacade) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 复杂事件</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.fireComplex(args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.fireSimple(args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发简单事件</span></span><br><span class=\"line\">    <span class=\"attr\">fireSimple</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prevented = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasSubs()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> subs = <span class=\"built_in\">this</span>.getSubs();</span><br><span class=\"line\">            <span class=\"comment\">// 处理前置监听对象</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._procSubs(subs[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">            <span class=\"comment\">// 处理前置监听对象</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._procSubs(subs[<span class=\"number\">1</span>], args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._broadcast(args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.stopped ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">hasSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">when</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"built_in\">this</span>.subCount,</span><br><span class=\"line\">            a = <span class=\"built_in\">this</span>.afterCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (when == <span class=\"string\">&#x27;after&#x27;</span>) ? a : s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (s + a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有前置／后置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">getSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = Y.merge(<span class=\"built_in\">this</span>.subscribers),</span><br><span class=\"line\">            a = Y.merge(<span class=\"built_in\">this</span>.afters);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [s, a];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 获取监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">_procSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">subs, args, ef</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s, i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subs.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                s = subs[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &amp;&amp; s.fn) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === <span class=\"built_in\">this</span>._notify(s, args, ef)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 回调返回false时，立即停止处理后续回调</span></span><br><span class=\"line\">                        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.stopped == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 立即停止处理后续回调，方便实现stopImmediatePropagation</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 通知监听对象，执行回调方法</span></span><br><span class=\"line\">    <span class=\"attr\">_notify</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, args, ef</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret = s.notify(args, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === ret || <span class=\"built_in\">this</span>.stopped &amp;gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 广播事件</span></span><br><span class=\"line\">    <span class=\"attr\">_broadcast</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.stopped &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.broadcast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> a = Y.Array(args);</span><br><span class=\"line\">            a.unshift(<span class=\"built_in\">this</span>.type);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在当前YUI实例Y上广播</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.host !== Y) &#123;</span><br><span class=\"line\">                Y.fire.apply(Y, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在全局对象YUI上广播，跨实例</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.broadcast == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                Y.Global.fire.apply(Y.Global, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在下一篇介绍Y.EventTarget的文章中再做介绍</span></span><br><span class=\"line\">    <span class=\"attr\">fireComplex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移除监听器</span></span><br><span class=\"line\">    <span class=\"attr\">detach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// unsubscribe handle</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fn &amp;amp;&amp;amp; fn.detach) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.detach();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i, s,</span><br><span class=\"line\">            found = <span class=\"number\">0</span>,</span><br><span class=\"line\">            subs = Y.merge(<span class=\"built_in\">this</span>.subscribers, <span class=\"built_in\">this</span>.afters);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subs.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                s = subs[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &amp;amp;&amp;amp; (!fn || fn === s.fn)) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._delete(s);</span><br><span class=\"line\">                    found++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">_delete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.subscribers[s.id]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.subscribers[s.id];</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.subCount--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.afters[s.id]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.afters[s.id];</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.afterCount--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s) &#123;</span><br><span class=\"line\">            s.deleted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>自定义事件的适用场景与Publish–subscribe Pattern基本一致。具体来讲，我觉得以下一些场景是非常适合用自定义事件的：</p>\n<h4 id=\"a-需要暴露接口-行为以满足扩展需要\"><a href=\"#a-需要暴露接口-行为以满足扩展需要\" class=\"headerlink\" title=\"a) 需要暴露接口/行为以满足扩展需要\"></a>a) 需要暴露接口/行为以满足扩展需要</h4><p>底层模块一般会设计的尽量简单，解决核心问题，并适当的开放一些接口，方便应用层进行扩展以满足实际需求。例如表单验证控件，有可能需要在某个表单项验证成功/失败后执行一些额外操作，举一个实际的例子：当用户输入的邮箱地址验证成功时，我们会检查是不是某些比较烂的邮件服务商，如果是则给出一些建议。</p>\n<p>YUI作为一个底层基础库，在组件/控件层面加入了大量的自定义事件，以满足实际应用中的需要。例如<code>Y.Anim</code>的start、end事件，<code>Y.io</code>的success、failure、end事件，<code>Y.Attribute</code>中的属性变化事件等。</p>\n<h4 id=\"b-行为可能会被其它模块-方法中止\"><a href=\"#b-行为可能会被其它模块-方法中止\" class=\"headerlink\" title=\"b) 行为可能会被其它模块/方法中止\"></a>b) 行为可能会被其它模块/方法中止</h4><p>这一点非常像DOM事件，我们经常会中止一些事件的默认行为，例如anchor的点击事件。</p>\n<h3 id=\"自定义事件-VS-回调函数\"><a href=\"#自定义事件-VS-回调函数\" class=\"headerlink\" title=\"自定义事件 VS 回调函数\"></a>自定义事件 VS 回调函数</h3><p>这是一个比较难的问题，我自己的看法是：相对回调函数，自定义事件是一种更重但更灵活的方案。在实际应用中，如果对于关心某消息的受众不够清楚，那么就使用事件。否则，比较适合使用回调函数。</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/aa733743%28v=vs.60%29.aspx\">MSDN</a>上的解释更好一些：“An event is like an anonymous broadcast, while a call-back is like a handshake. The corollary of this is that a component that raises events knows nothing about its clients, while a component that makes call-backs knows a great deal”。</p>\n<p>另外，如果对于性能特别关心，在可能的情况下，尽量使用回调。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html\">YUILibrary-CustomEvent</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">Wikipedia-Publish–subscribe Pattern</a></li>\n<li><a href=\"http://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/\">Zakas-Custom events in JavaScript</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/aa733743(v=vs.60).aspx\">When to Use Events or Call-Backs for Notifications</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/DIY.jpg\" alt=\"DIY\"></p>\n<p>上一篇<a href=\"/2013/01/20/event-do/\">文章</a>中，简要介绍了YUI实现AOP的<code>Y.Do</code>对象。</p>\n<p>接下来，我们继续对YUI事件体系进行探索。本次要介绍的是<code>Y.CustomEvent</code>对象，从命名上就可以看出，这个对象在整个YUI事件体系中十分重要。它建立起整个自定义事件的体系，而且，DOM事件也构建在这个体系之上。</p>\n<h2 id=\"Y-Subscriber\"><a href=\"#Y-Subscriber\" class=\"headerlink\" title=\"Y.Subscriber\"></a>Y.Subscriber</h2><p>Y.Subscriber的作用比较简单：执行回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.Subscriber = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.fn = fn; <span class=\"comment\">// 回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.context = context; <span class=\"comment\">// 上下文</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.id = Y.stamp(<span class=\"built_in\">this</span>); <span class=\"comment\">// 设置唯一id</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Subscriber.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: Y.Subscriber,</span><br><span class=\"line\">    <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">    <span class=\"attr\">notify</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args, ce</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.deleted) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">this</span>.fn.apply(<span class=\"built_in\">this</span>.context, args || []);</span><br><span class=\"line\">        <span class=\"comment\">// 只监听一次</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.once) &#123;</span><br><span class=\"line\">            ce._delete(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-CustomEvent\"><a href=\"#Y-CustomEvent\" class=\"headerlink\" title=\"Y.CustomEvent\"></a>Y.CustomEvent</h2><p><code>Y.CustomEvent</code>主要作用是：建立自定义事件机制，为方便的进行事件创建、监听、触发提供良好基础。自定义事件机制，实际上是<a href=\"http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">Observer Pattern</a>（<a href=\"http://en.wikipedia.org/wiki/Observer_pattern\">Publish–subscribe Pattern</a>的演化）的一种实现，这种机制能够方便的实现模块间解耦，增强模块的扩展性。</p>\n<p>YUI的自定义事件较其它一些js库来说要强大一些，有这样一些好的features：</p>\n<ul>\n<li>支持事件接口(Event Facade)，在回调函数中可以进行调用</li>\n<li>支持设置默认执行方法</li>\n<li>支持停止/立即停止传播，并可设定停止传播时执行的方法</li>\n<li>支持阻止默认行为(默认执行方法)，并可设定阻止默认行为时执行的方法</li>\n<li>支持冒泡。指定冒泡目标序列，就可以顺序的触发事件(需要<code>Y.EventTarget</code>)</li>\n<li>支持广播。每个自定义事件，都可以设置在当前YUI实例范围内和全局YUI内进行广播</li>\n</ul>\n<p>可以看出，YUI的自定义事件和DOM事件极其类似，这种设计自然到我们在用自定义事件时，丝毫感觉不到和DOM事件的差异。</p>","more":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>让我们先来看个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1 简单自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> eatEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onHandle = eatEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before eating&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onHandle2 = eatEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before eating, too&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> afterHandle = eatEvent.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;after eating&#x27;</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before eating&quot;, &quot;before eating, too&quot;, &quot;after eating&quot;</span></span><br><span class=\"line\">    eatEvent.fire();</span><br><span class=\"line\"></span><br><span class=\"line\">    onHandle2.detach();</span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before eating&quot;, &quot;after eating&quot;</span></span><br><span class=\"line\">    eatEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>有些事件只需触发一次，比如你的各种第一次～～～。来看这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2 仅触发一次的自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> birthEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;birth&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">fireOnce</span>: <span class=\"literal\">true</span>  <span class=\"comment\">// you can only birth once</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onBirthHandle = birthEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before birth&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before birth&quot;</span></span><br><span class=\"line\">    birthEvent.fire();</span><br><span class=\"line\">    <span class=\"comment\">// nothing happened</span></span><br><span class=\"line\">    birthEvent.fire();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 只触发一次的事件在触发后，再次添加监听方法时，会被立即执行</span></span><br><span class=\"line\">    <span class=\"comment\">// output: before birth, too</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onBirthHandle2 = birthEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before birth, too&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>也许你还在琢磨，事件广播是什么？因为YUI使用了sandbox设计，可以生成不同实例绑定不同api，所以才有了事件广播机制。来看这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3 事件广播</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cryEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;cry&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">broadcast</span>: <span class=\"number\">2</span>  <span class=\"comment\">// global broadcast</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    cryEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;before cry&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Y.on(<span class=\"string\">&#x27;cry&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;YUI instance broadcast&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Y.Global.on(<span class=\"string\">&#x27;cry&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;YUI global broadcast&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;before cry&quot;, &quot;YUI instance broadcast&quot;, &quot;YUI global broadcast&quot;</span></span><br><span class=\"line\">    cryEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>文章之前介绍过YUI自定义事件的种种NB之处，那么用起来如何呢，来看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4 复杂自定义事件</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> driveEvent = <span class=\"keyword\">new</span> Y.CustomEvent(<span class=\"string\">&#x27;drive&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">host</span>: &#123;  <span class=\"comment\">// hacking. 复杂自定义事件需要指定host，该host必须augment Y.EventTarget</span></span><br><span class=\"line\">            <span class=\"attr\">_yuievt</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"attr\">_monitor</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute defaultFn&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">preventedFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute preventedFn&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">stoppedFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Y.log(<span class=\"string\">&#x27;execute stoppedFn&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.on(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    driveEvent.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        Y.log(<span class=\"string\">&#x27;after driving&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: &quot;execute stoppedFn&quot;, &quot;execute defaultFn&quot;</span></span><br><span class=\"line\">    driveEvent.fire();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不要失望，现在还没有介绍到事件体系的精华部分<code>Y.EventTarget</code>，所以很多特性（例如冒泡）还不能体现出来，拭目以待吧。</p>\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> AFTER = <span class=\"string\">&#x27;after&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// config白名单</span></span><br><span class=\"line\">    CONFIGS = [<span class=\"string\">&#x27;broadcast&#x27;</span>, <span class=\"string\">&#x27;monitored&#x27;</span>, <span class=\"string\">&#x27;bubbles&#x27;</span>, <span class=\"string\">&#x27;context&#x27;</span>, <span class=\"string\">&#x27;contextFn&#x27;</span>, <span class=\"string\">&#x27;currentTarget&#x27;</span>, <span class=\"string\">&#x27;defaultFn&#x27;</span>, <span class=\"string\">&#x27;defaultTargetOnly&#x27;</span>, <span class=\"string\">&#x27;details&#x27;</span>, <span class=\"string\">&#x27;emitFacade&#x27;</span>, <span class=\"string\">&#x27;fireOnce&#x27;</span>, <span class=\"string\">&#x27;async&#x27;</span>, <span class=\"string\">&#x27;host&#x27;</span>, <span class=\"string\">&#x27;preventable&#x27;</span>, <span class=\"string\">&#x27;preventedFn&#x27;</span>, <span class=\"string\">&#x27;queuable&#x27;</span>, <span class=\"string\">&#x27;silent&#x27;</span>, <span class=\"string\">&#x27;stoppedFn&#x27;</span>, <span class=\"string\">&#x27;target&#x27;</span>, <span class=\"string\">&#x27;type&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">Y.CustomEvent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.id = Y.stamp(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.type = type;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.context = Y;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preventable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.bubbles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subscribers = &#123;&#125;; <span class=\"comment\">// (前置)监听对象容器 注：YUI3.7.0将此处进行了优化</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.afters = &#123;&#125;; <span class=\"comment\">// 后置监听对象容器 注：YUI3.7.0将此处进行了优化</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.afterCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    o = o || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.applyConfig(o, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.CustomEvent.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: Y.CustomEvent,</span><br><span class=\"line\">    <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">    <span class=\"attr\">applyConfig</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o, force</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o) &#123;</span><br><span class=\"line\">            Y.mix(<span class=\"built_in\">this</span>, o, force, CONFIGS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加前置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">2</span>) ? Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._on(fn, context, a, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 添加后置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">2</span>) ? Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._on(fn, context, a, AFTER);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 内部添加监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">_on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context, args, when</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> Y.Subscriber(fn, context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.fireOnce &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.fired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅触发一次的事件在触发后，再次添加监听方法时，会被立即执行</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._notify(s, <span class=\"built_in\">this</span>.firedWith);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when == AFTER) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afters[s.id] = s;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afterCount++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.subscribers[s.id] = s;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.subCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.EventHandle(<span class=\"built_in\">this</span>, s);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    <span class=\"attr\">fire</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.fireOnce &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.fired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅触发一次的事件，如果已经触发过，直接返回true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以设置参数，传给回调函数</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.fired = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.firedWith = args;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.emitFacade) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 复杂事件</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.fireComplex(args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.fireSimple(args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发简单事件</span></span><br><span class=\"line\">    <span class=\"attr\">fireSimple</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prevented = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasSubs()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> subs = <span class=\"built_in\">this</span>.getSubs();</span><br><span class=\"line\">            <span class=\"comment\">// 处理前置监听对象</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._procSubs(subs[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">            <span class=\"comment\">// 处理前置监听对象</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>._procSubs(subs[<span class=\"number\">1</span>], args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._broadcast(args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.stopped ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">hasSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">when</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"built_in\">this</span>.subCount,</span><br><span class=\"line\">            a = <span class=\"built_in\">this</span>.afterCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (when == <span class=\"string\">&#x27;after&#x27;</span>) ? a : s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (s + a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有前置／后置监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">getSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = Y.merge(<span class=\"built_in\">this</span>.subscribers),</span><br><span class=\"line\">            a = Y.merge(<span class=\"built_in\">this</span>.afters);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [s, a];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 获取监听对象</span></span><br><span class=\"line\">    <span class=\"attr\">_procSubs</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">subs, args, ef</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s, i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subs.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                s = subs[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &amp;&amp; s.fn) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === <span class=\"built_in\">this</span>._notify(s, args, ef)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 回调返回false时，立即停止处理后续回调</span></span><br><span class=\"line\">                        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.stopped == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 立即停止处理后续回调，方便实现stopImmediatePropagation</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 通知监听对象，执行回调方法</span></span><br><span class=\"line\">    <span class=\"attr\">_notify</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, args, ef</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret = s.notify(args, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === ret || <span class=\"built_in\">this</span>.stopped &amp;gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 广播事件</span></span><br><span class=\"line\">    <span class=\"attr\">_broadcast</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.stopped &amp;amp;&amp;amp; <span class=\"built_in\">this</span>.broadcast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> a = Y.Array(args);</span><br><span class=\"line\">            a.unshift(<span class=\"built_in\">this</span>.type);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在当前YUI实例Y上广播</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.host !== Y) &#123;</span><br><span class=\"line\">                Y.fire.apply(Y, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在全局对象YUI上广播，跨实例</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.broadcast == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                Y.Global.fire.apply(Y.Global, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在下一篇介绍Y.EventTarget的文章中再做介绍</span></span><br><span class=\"line\">    <span class=\"attr\">fireComplex</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移除监听器</span></span><br><span class=\"line\">    <span class=\"attr\">detach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// unsubscribe handle</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fn &amp;amp;&amp;amp; fn.detach) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.detach();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i, s,</span><br><span class=\"line\">            found = <span class=\"number\">0</span>,</span><br><span class=\"line\">            subs = Y.merge(<span class=\"built_in\">this</span>.subscribers, <span class=\"built_in\">this</span>.afters);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> subs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subs.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                s = subs[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &amp;amp;&amp;amp; (!fn || fn === s.fn)) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._delete(s);</span><br><span class=\"line\">                    found++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">_delete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.subscribers[s.id]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.subscribers[s.id];</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.subCount--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.afters[s.id]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.afters[s.id];</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.afterCount--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s) &#123;</span><br><span class=\"line\">            s.deleted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>自定义事件的适用场景与Publish–subscribe Pattern基本一致。具体来讲，我觉得以下一些场景是非常适合用自定义事件的：</p>\n<h4 id=\"a-需要暴露接口-行为以满足扩展需要\"><a href=\"#a-需要暴露接口-行为以满足扩展需要\" class=\"headerlink\" title=\"a) 需要暴露接口/行为以满足扩展需要\"></a>a) 需要暴露接口/行为以满足扩展需要</h4><p>底层模块一般会设计的尽量简单，解决核心问题，并适当的开放一些接口，方便应用层进行扩展以满足实际需求。例如表单验证控件，有可能需要在某个表单项验证成功/失败后执行一些额外操作，举一个实际的例子：当用户输入的邮箱地址验证成功时，我们会检查是不是某些比较烂的邮件服务商，如果是则给出一些建议。</p>\n<p>YUI作为一个底层基础库，在组件/控件层面加入了大量的自定义事件，以满足实际应用中的需要。例如<code>Y.Anim</code>的start、end事件，<code>Y.io</code>的success、failure、end事件，<code>Y.Attribute</code>中的属性变化事件等。</p>\n<h4 id=\"b-行为可能会被其它模块-方法中止\"><a href=\"#b-行为可能会被其它模块-方法中止\" class=\"headerlink\" title=\"b) 行为可能会被其它模块/方法中止\"></a>b) 行为可能会被其它模块/方法中止</h4><p>这一点非常像DOM事件，我们经常会中止一些事件的默认行为，例如anchor的点击事件。</p>\n<h3 id=\"自定义事件-VS-回调函数\"><a href=\"#自定义事件-VS-回调函数\" class=\"headerlink\" title=\"自定义事件 VS 回调函数\"></a>自定义事件 VS 回调函数</h3><p>这是一个比较难的问题，我自己的看法是：相对回调函数，自定义事件是一种更重但更灵活的方案。在实际应用中，如果对于关心某消息的受众不够清楚，那么就使用事件。否则，比较适合使用回调函数。</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/aa733743%28v=vs.60%29.aspx\">MSDN</a>上的解释更好一些：“An event is like an anonymous broadcast, while a call-back is like a handshake. The corollary of this is that a component that raises events knows nothing about its clients, while a component that makes call-backs knows a great deal”。</p>\n<p>另外，如果对于性能特别关心，在可能的情况下，尽量使用回调。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html\">YUILibrary-CustomEvent</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">Wikipedia-Publish–subscribe Pattern</a></li>\n<li><a href=\"http://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/\">Zakas-Custom events in JavaScript</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/aa733743(v=vs.60).aspx\">When to Use Events or Call-Backs for Notifications</a></li>\n</ul>"},{"layout":"post","title":"Event小记","date":"2011-03-16T16:39:00.000Z","status":"publish","_content":"\nEvent在javascript中的重要性不言而喻，正是它驱动着所有事情的进行。记下一些读书的心得，整理如下：\n\n- Event按类别可分为input events和semantic events。semantic events的发生通常都建立在input events之上，例如点击“提交”按钮后产生onsubmit事件。input events依赖于输入设备。Events按模块可分为HTMLEvents、MouseEvents和UIEvents，对应的接口分别为Event、MouseEvent和UIEvent，其中MouseEvent接口继承了Event接口和UIEvent接口，常用的属性有altKey、ctrlKey、shiftKey和一些位置信息。\n- DOM level 0的事件响应方式得到最为广泛的支持。具体应用方式有两种，一种是在页面目标元素中添加对应属性，如&lt;input type=\"button\" onclick=\"alert(this.nodeName)\" /&gt;；对应的另一种方式为 elButton.onclick = function(){ alert(this.nodeName); }。显式调用响应方法也非常简单，elButton.onclick()即可。响应方法中的this指代的是触发事件的页面元素。这种事件处理方式有一些缺点，例如：每个对象的某种事件只能添加一个响应方法，当需要将多个元素绑定事件时实现较为复杂等。\n- DOM level 2的事件响应方式进行了诸多改进。事件被赋予一个传播过程，细分为capturing、target node、bubbling三个阶段。这一机制是有一定渊源的，不妨细讲。在当年Netscape与IE大战的年代，当遇到多个嵌套元素绑定同一事件时，如何确定响应方法执行顺序成为大家共同的问题，不幸的是他们做出了相反的选择：NetScape按照事件捕获的顺序执行，即父级节点响应方法优先执行，而IE按照事件冒泡的顺序执行，即子级节点响应方法优先执行。之后W3C过来和稀泥，也就制定了事件传播过程这一机制。需要注意的是，可以通过设定addEventListener的第三个参数设定响应方法在capturing阶段执行（true）还是在bubbling阶段执行（false）。\n- 有些元素在一些操作后会有默认动作，如果恰好添加了这类事件监听器的话，执行的顺序是：响应方法执行先于默认动作。阻止默认动作发生，DOM level 0中可以用return false（window.status是一个例外，需return true）；DOM level 2中可以使用preventDefault方法。停止事件传播使用stopPropagation方法。\n- IE的事件模型并未遵循W3C标准。事件传播没有capturing阶段，bubbling阶段不能获得currentTarget，不会传递给事件响应方法event对象而是有一个全局event对象，注册/移除响应方法使用attachEvent/detachEvent，阻止事件传播使用cancelBubble等等。\n- 为了将鼠标动作限定在特定页面元素，即便鼠标已不在该元素区域内，可将响应方法和事件注册在document上，在IE中可使用setCapture/releaseCapture方法。一个典型的案例是在拖拽模块时，鼠标移动常常快于模块。\n- keyCode代表键位编号，charCode代表键位上字符的编号。IE的键盘事件中只有keyCode属性，可以用 e.charCode || e.keyCode获得keypress事件发生时对应按键的字符编号。\n- 通过Document.createEvent创建自定义事件，并用Event.initEvent进行初始化，dispatchEvent进行调度。IE中可使用Document.createEventObject创建自定义事件，并用fireEvent进行调度。这部分可以说成为高级前端必备知识，在模块化编程等方面有较为重要的应用。\n","source":"_posts/event-note.md","raw":"---\nlayout: post\ntitle: \"Event小记\"\ndate: 2011-03-17 00:39\nstatus: publish\ntags: [Event]\n---\n\nEvent在javascript中的重要性不言而喻，正是它驱动着所有事情的进行。记下一些读书的心得，整理如下：\n\n- Event按类别可分为input events和semantic events。semantic events的发生通常都建立在input events之上，例如点击“提交”按钮后产生onsubmit事件。input events依赖于输入设备。Events按模块可分为HTMLEvents、MouseEvents和UIEvents，对应的接口分别为Event、MouseEvent和UIEvent，其中MouseEvent接口继承了Event接口和UIEvent接口，常用的属性有altKey、ctrlKey、shiftKey和一些位置信息。\n- DOM level 0的事件响应方式得到最为广泛的支持。具体应用方式有两种，一种是在页面目标元素中添加对应属性，如&lt;input type=\"button\" onclick=\"alert(this.nodeName)\" /&gt;；对应的另一种方式为 elButton.onclick = function(){ alert(this.nodeName); }。显式调用响应方法也非常简单，elButton.onclick()即可。响应方法中的this指代的是触发事件的页面元素。这种事件处理方式有一些缺点，例如：每个对象的某种事件只能添加一个响应方法，当需要将多个元素绑定事件时实现较为复杂等。\n- DOM level 2的事件响应方式进行了诸多改进。事件被赋予一个传播过程，细分为capturing、target node、bubbling三个阶段。这一机制是有一定渊源的，不妨细讲。在当年Netscape与IE大战的年代，当遇到多个嵌套元素绑定同一事件时，如何确定响应方法执行顺序成为大家共同的问题，不幸的是他们做出了相反的选择：NetScape按照事件捕获的顺序执行，即父级节点响应方法优先执行，而IE按照事件冒泡的顺序执行，即子级节点响应方法优先执行。之后W3C过来和稀泥，也就制定了事件传播过程这一机制。需要注意的是，可以通过设定addEventListener的第三个参数设定响应方法在capturing阶段执行（true）还是在bubbling阶段执行（false）。\n- 有些元素在一些操作后会有默认动作，如果恰好添加了这类事件监听器的话，执行的顺序是：响应方法执行先于默认动作。阻止默认动作发生，DOM level 0中可以用return false（window.status是一个例外，需return true）；DOM level 2中可以使用preventDefault方法。停止事件传播使用stopPropagation方法。\n- IE的事件模型并未遵循W3C标准。事件传播没有capturing阶段，bubbling阶段不能获得currentTarget，不会传递给事件响应方法event对象而是有一个全局event对象，注册/移除响应方法使用attachEvent/detachEvent，阻止事件传播使用cancelBubble等等。\n- 为了将鼠标动作限定在特定页面元素，即便鼠标已不在该元素区域内，可将响应方法和事件注册在document上，在IE中可使用setCapture/releaseCapture方法。一个典型的案例是在拖拽模块时，鼠标移动常常快于模块。\n- keyCode代表键位编号，charCode代表键位上字符的编号。IE的键盘事件中只有keyCode属性，可以用 e.charCode || e.keyCode获得keypress事件发生时对应按键的字符编号。\n- 通过Document.createEvent创建自定义事件，并用Event.initEvent进行初始化，dispatchEvent进行调度。IE中可使用Document.createEventObject创建自定义事件，并用fireEvent进行调度。这部分可以说成为高级前端必备知识，在模块化编程等方面有较为重要的应用。\n","slug":"event-note","published":1,"updated":"2021-10-04T12:57:16.033Z","comments":1,"photos":[],"link":"","_id":"cl1klgupe000b8e85bh9f4lyu","content":"<p>Event在javascript中的重要性不言而喻，正是它驱动着所有事情的进行。记下一些读书的心得，整理如下：</p>\n<ul>\n<li>Event按类别可分为input events和semantic events。semantic events的发生通常都建立在input events之上，例如点击“提交”按钮后产生onsubmit事件。input events依赖于输入设备。Events按模块可分为HTMLEvents、MouseEvents和UIEvents，对应的接口分别为Event、MouseEvent和UIEvent，其中MouseEvent接口继承了Event接口和UIEvent接口，常用的属性有altKey、ctrlKey、shiftKey和一些位置信息。</li>\n<li>DOM level 0的事件响应方式得到最为广泛的支持。具体应用方式有两种，一种是在页面目标元素中添加对应属性，如&lt;input type=”button” onclick=”alert(this.nodeName)” /&gt;；对应的另一种方式为 elButton.onclick = function(){ alert(this.nodeName); }。显式调用响应方法也非常简单，elButton.onclick()即可。响应方法中的this指代的是触发事件的页面元素。这种事件处理方式有一些缺点，例如：每个对象的某种事件只能添加一个响应方法，当需要将多个元素绑定事件时实现较为复杂等。</li>\n<li>DOM level 2的事件响应方式进行了诸多改进。事件被赋予一个传播过程，细分为capturing、target node、bubbling三个阶段。这一机制是有一定渊源的，不妨细讲。在当年Netscape与IE大战的年代，当遇到多个嵌套元素绑定同一事件时，如何确定响应方法执行顺序成为大家共同的问题，不幸的是他们做出了相反的选择：NetScape按照事件捕获的顺序执行，即父级节点响应方法优先执行，而IE按照事件冒泡的顺序执行，即子级节点响应方法优先执行。之后W3C过来和稀泥，也就制定了事件传播过程这一机制。需要注意的是，可以通过设定addEventListener的第三个参数设定响应方法在capturing阶段执行（true）还是在bubbling阶段执行（false）。</li>\n<li>有些元素在一些操作后会有默认动作，如果恰好添加了这类事件监听器的话，执行的顺序是：响应方法执行先于默认动作。阻止默认动作发生，DOM level 0中可以用return false（window.status是一个例外，需return true）；DOM level 2中可以使用preventDefault方法。停止事件传播使用stopPropagation方法。</li>\n<li>IE的事件模型并未遵循W3C标准。事件传播没有capturing阶段，bubbling阶段不能获得currentTarget，不会传递给事件响应方法event对象而是有一个全局event对象，注册/移除响应方法使用attachEvent/detachEvent，阻止事件传播使用cancelBubble等等。</li>\n<li>为了将鼠标动作限定在特定页面元素，即便鼠标已不在该元素区域内，可将响应方法和事件注册在document上，在IE中可使用setCapture/releaseCapture方法。一个典型的案例是在拖拽模块时，鼠标移动常常快于模块。</li>\n<li>keyCode代表键位编号，charCode代表键位上字符的编号。IE的键盘事件中只有keyCode属性，可以用 e.charCode || e.keyCode获得keypress事件发生时对应按键的字符编号。</li>\n<li>通过Document.createEvent创建自定义事件，并用Event.initEvent进行初始化，dispatchEvent进行调度。IE中可使用Document.createEventObject创建自定义事件，并用fireEvent进行调度。这部分可以说成为高级前端必备知识，在模块化编程等方面有较为重要的应用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Event在javascript中的重要性不言而喻，正是它驱动着所有事情的进行。记下一些读书的心得，整理如下：</p>\n<ul>\n<li>Event按类别可分为input events和semantic events。semantic events的发生通常都建立在input events之上，例如点击“提交”按钮后产生onsubmit事件。input events依赖于输入设备。Events按模块可分为HTMLEvents、MouseEvents和UIEvents，对应的接口分别为Event、MouseEvent和UIEvent，其中MouseEvent接口继承了Event接口和UIEvent接口，常用的属性有altKey、ctrlKey、shiftKey和一些位置信息。</li>\n<li>DOM level 0的事件响应方式得到最为广泛的支持。具体应用方式有两种，一种是在页面目标元素中添加对应属性，如&lt;input type=”button” onclick=”alert(this.nodeName)” /&gt;；对应的另一种方式为 elButton.onclick = function(){ alert(this.nodeName); }。显式调用响应方法也非常简单，elButton.onclick()即可。响应方法中的this指代的是触发事件的页面元素。这种事件处理方式有一些缺点，例如：每个对象的某种事件只能添加一个响应方法，当需要将多个元素绑定事件时实现较为复杂等。</li>\n<li>DOM level 2的事件响应方式进行了诸多改进。事件被赋予一个传播过程，细分为capturing、target node、bubbling三个阶段。这一机制是有一定渊源的，不妨细讲。在当年Netscape与IE大战的年代，当遇到多个嵌套元素绑定同一事件时，如何确定响应方法执行顺序成为大家共同的问题，不幸的是他们做出了相反的选择：NetScape按照事件捕获的顺序执行，即父级节点响应方法优先执行，而IE按照事件冒泡的顺序执行，即子级节点响应方法优先执行。之后W3C过来和稀泥，也就制定了事件传播过程这一机制。需要注意的是，可以通过设定addEventListener的第三个参数设定响应方法在capturing阶段执行（true）还是在bubbling阶段执行（false）。</li>\n<li>有些元素在一些操作后会有默认动作，如果恰好添加了这类事件监听器的话，执行的顺序是：响应方法执行先于默认动作。阻止默认动作发生，DOM level 0中可以用return false（window.status是一个例外，需return true）；DOM level 2中可以使用preventDefault方法。停止事件传播使用stopPropagation方法。</li>\n<li>IE的事件模型并未遵循W3C标准。事件传播没有capturing阶段，bubbling阶段不能获得currentTarget，不会传递给事件响应方法event对象而是有一个全局event对象，注册/移除响应方法使用attachEvent/detachEvent，阻止事件传播使用cancelBubble等等。</li>\n<li>为了将鼠标动作限定在特定页面元素，即便鼠标已不在该元素区域内，可将响应方法和事件注册在document上，在IE中可使用setCapture/releaseCapture方法。一个典型的案例是在拖拽模块时，鼠标移动常常快于模块。</li>\n<li>keyCode代表键位编号，charCode代表键位上字符的编号。IE的键盘事件中只有keyCode属性，可以用 e.charCode || e.keyCode获得keypress事件发生时对应按键的字符编号。</li>\n<li>通过Document.createEvent创建自定义事件，并用Event.initEvent进行初始化，dispatchEvent进行调度。IE中可使用Document.createEventObject创建自定义事件，并用fireEvent进行调度。这部分可以说成为高级前端必备知识，在模块化编程等方面有较为重要的应用。</li>\n</ul>\n"},{"layout":"post","title":"YUI事件体系之Y.EventTarget","date":"2012-11-25T13:25:00.000Z","comments":1,"status":"publish","_content":"\n![bubble girl](/images/bubble-girl.jpg)\n\n上两篇文章[YUI事件体系之Y.Do](/event-do/)、[YUI事件体系之Y.CustomEvent](/event-custom/)中，分别介绍了YUI实现AOP的`Y.Do`对象，以及建立自定义事件机制的`Y.CustomEvent`对象。\n\n本篇文章，将要介绍YUI事件体系集大成者、最为精华的部分——`Y.EventTarget`。\n\n## Y.EventTarget\n\nDOM事件中的目标元素为`event.target`，这类元素可以触发、监听一些事件，例如input元素的click、focus等事件。这也正是`Y.EventTarget`的命名渊源，它提供了一种让任意对象定义、监听、触发自定义事件的实现方式。\n\n从设计上看，`Y.EventTarget`通过内部维护一系列`Y.EventCustom`对象，提供了可以通过事件名称进行事件定义、监听和触发的便捷接口。另外，推荐使用`Y.augment`将它以组合的方式加载在其它类上，而不要使用继承。关于`Y.augment`和`Y.extend`之间的异同，可以参考我之前的一篇文章：[Y.extend与Y.augment](/extend-and-augment/)。\n\nYUI很多基础类都扩展了`Y.EventTarget`，重要的有`Y`（YUI instance，sandbox）、`Y.Global`、`Y.Node`、`Y.NodeList`、`Y.Base`等。\n\nYUILibrary有专门一个章节介绍EventTarget，非常详尽，如果你对EventTarget的设计思路和使用方法感兴趣，请移步[YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/)。\n\n<!-- more -->\n\n### 示例\n\n首先，让我们看看`Y.EventTarget`独立调用的例子：\n\n```javascript\n// 例1\nYUI().use('event-custom', function (Y) {\n    var et = new Y.EventTarget();\n\n    et.on('say', function (msg) {\n        console.log('say:', msg);\n    });\n    et.on('listen', function (msg) {\n        console.log('listen:', msg);\n    });\n\n    // output: say: Hello, world\n    instance.fire('say', 'Hello, world');\n});\n```\n\n<!-- more -->\n\n这种方式实际意义不大，YUI中只有`Y.Global`使用了这种方式。\n\n下面，让我们看下最广泛的使用方式，即通过`Y.augment`扩展其它类：\n\n```javascript\n// 例2\nYUI().use('event-custom', function (Y) {\n    function MyClass() {}\n    MyClass.prototype.add = function (item) {\n        // do sth\n        this.fire('addItem', { item: item });\n    };\n    MyClass.prototype.remove = function (item) {\n        // do sth\n        this.fire('removeItem', { item: item });\n    };\n    // 用EventTarget扩展MyClass\n    Y.augment(MyClass, Y.EventTarget);\n\n    var instance = new MyClass();\n    // 监听addItem事件\n    instance.on('addItem', function (data) {\n        console.log('add an item:', data.item);\n    });\n    // 监听removeItem事件\n    instance.on('removeItem', function (data) {\n        console.log('remove an item:', data.item);\n    });\n\n    // output: add an item: orange\n    instance.add('orange');\n    // output: remove an item: red\n    instance.remove('red');\n});\n```\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38)。\n\n```javascript\nvar AFTER_PREFIX = '~AFTER~';\n\n// EventTarget构造器\nvar ET = function (opts) {\n    var o = opts || {};\n    // 私有事件聚合器\n    this._yuievt = this._yuievt || {\n        id: Y.guid(),\n        events: {},\n        config: o,\n        // 默认配置\n        defaults: {\n            context: o.context || this,\n            host: this,\n            emitFacade: o.emitFacade,\n            fireOnce: o.fireOnce,\n            queuable: o.queuable,\n            broadcast: o.broadcast\n        }\n    };\n};\n\nET.prototype = {\n    constructor: ET,\n    // 创建事件\n    publish: function (type, opts) {\n        var ce,\n            events = this._yuievt.events,\n            defaults = this._yuievt.defaults;\n\n        ce = events[type];\n        if (ce) { // 已创建过该事件\n            if (opts) {\n                ce.applyConfig(opts, true);\n            }\n        } else { // 基于CustomEvent，创建新事件\n            ce = new Y.CustomEvent(type,\n                                    (opts) ? Y.merge(defaults, opts) : defaults);\n            events[type] = ce;\n        }\n\n        return ce;\n    },\n    // 监听事件\n    on: function (type, fn, context) {\n        var ce,\n            after,\n            handle,\n            args = null;\n\n        // 判断是否为后置监听\n        if (type.indexOf(AFTER_PREFIX) &gt; -1) {\n            after = true;\n            type = type.substr(AFTER_PREFIX.length);\n        }\n\n        // 获取自定义事件对象，如果未创建则先创建\n        ce = this._yuievt.events[type] || this.publish(type);\n        if (arguments.length &gt; 3) {\n            args = Y.Array(arguments, 3, true);\n        }\n\n        // 调用自定义事件对象的_on方法监听事件\n        handle = ce._on(fn, context, args, after ? 'after' : true);\n\n        return handle;\n    },\n    // 监听一次事件\n    once: function () {\n        var handle = this.on.apply(this, arguments);\n        if (handle.sub) {\n            // 监听器执行一次则失效\n            handle.sub.once = true;\n        }\n        return handle;\n    },\n    // 后置监听事件\n    after: function (type, fn) {\n        var a = Y.Array(arguments, 0, true);\n        a[0] = AFTER_PREFIX + type;\n        return this.on.apply(this, a);\n    },\n    // 后置监听一次事件\n    onceAfter: function () {\n        var handle = this.after.apply(this, arguments);\n        if (handle.sub) {\n            handle.sub.once = true;\n        }\n        return handle;\n    },\n    // 触发事件\n    fire: function (type) {\n        var ce,\n            args;\n        args = Y.Array(arguments, 1, true);\n        ce = this._yuievt.events[type];\n        // 尚未创建事件\n        if (!ce) return true;\n\n        return ce.fire.apply(ce, args);\n    },\n    // 注销事件监听\n    detach: function (type, fn, context) {\n        var events = this._yuievt.events,\n            ce,\n            i;\n\n        // 未设置事件类型，则注销所有类型的事件\n        if (!type) {\n            for (i in events) {\n                if (events.hasOwnProperty(i)) {\n                    events[i].detach(fn, context);\n                }\n            }\n            return this;\n        }\n\n        ce = events[type];\n        if (ce) {\n            ce.detach(fn, context);\n        }\n\n        return this;\n    }\n};\n```\n\n### 进阶用法\n\n`Y.EventTarget`作为一个十分重要的类，提供了非常丰富、方便的使用方式，除了依赖内部`Y.CustomEvent`实现的事件接口、默认执行方法、事件广播等，其余主要有：\n\n#### a) 事件冒泡\n\n多个EventTarget对象之间可以建立一定事件传播关系，类似DOM事件中的冒泡。\n\n```javascript\n// 例3\nYUI().use('event-custom', function (Y) {\n    // 父类\n    function Parent() { ... }\n    Y.augment(Parent, Y.EventTarget, true, null, { emitFacade: true });\n    // 子类\n    function Child() { ... }\n    Y.augment(Child, Y.EventTarget, true, null, { emitFacade: true });\n\n    var parent = new Parent(),\n        child = new Child();\n    // 子类对象添加冒泡目标对象，child -&gt; parent\n    child.addTarget(parent);\n\n    parent.on('hear', function (e) {\n        console.log('parent hear', e.msg);\n    });\n    child.on('hear', function (e) {\n        console.log('child hear', e.msg);\n    });\n\n    // output: child hear Hi, parent hear Hi\n    child.fire('hear', { msg: 'Hi' });\n});\n```\n\n#### b) 事件前缀\n\n在事件冒泡的基础上，考虑到区分不同EventTarget对象触发相同事件，YUI引入了事件前缀（Event Prefix）。\n\n```javascript\n// 例4\nYUI().use('event-custom', function (Y) {\n    // 父类\n    function Parent() { ... }\n    Y.augment(Parent, Y.EventTarget, true, null, {\n        emitFacade: true,\n        prefix: 'parent' // 配置事件前缀\n    });\n    // 子类\n    function Child() { ... }\n    Y.augment(Child, Y.EventTarget, true, null, {\n        emitFacade: true,\n        prefix: 'child' // 配置事件前缀\n    });\n\n    var parent = new Parent(),\n        child = new Child();\n    child.addTarget(parent);\n\n    parent.on('hear', function (e) { // 不能捕捉到child的hear事件\n        console.log('parent hear', e.msg);\n    });\n    child.on('hear', function (e) {\n        console.log('child hear', e.msg);\n    });\n\n    // output: child hear Hi\n    child.fire('hear', { msg: 'Hi' });\n\n    parent.on('*:see', function (e) { // 要想监听到其它EventTarget对象的see事件，需要设置prefix\n        console.log('parent see', e.thing);\n    });\n    child.on('child:see', function (e) { // 等同监听see事件\n        console.log('child see', e.thing);\n    });\n\n    // output: child hear MM, parent see MM\n    child.fire('see', { thing: 'MM' });\n});\n```\n\n## 参考\n\n- [YUILibrary-CustomEvent](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n","source":"_posts/event-target.md","raw":"---\nlayout: post\ntitle: \"YUI事件体系之Y.EventTarget\"\ndate: 2012-11-25 21:25\ncomments: true\nstatus: publish\ntags: [YUI, Event, JavaScript]\n---\n\n![bubble girl](/images/bubble-girl.jpg)\n\n上两篇文章[YUI事件体系之Y.Do](/event-do/)、[YUI事件体系之Y.CustomEvent](/event-custom/)中，分别介绍了YUI实现AOP的`Y.Do`对象，以及建立自定义事件机制的`Y.CustomEvent`对象。\n\n本篇文章，将要介绍YUI事件体系集大成者、最为精华的部分——`Y.EventTarget`。\n\n## Y.EventTarget\n\nDOM事件中的目标元素为`event.target`，这类元素可以触发、监听一些事件，例如input元素的click、focus等事件。这也正是`Y.EventTarget`的命名渊源，它提供了一种让任意对象定义、监听、触发自定义事件的实现方式。\n\n从设计上看，`Y.EventTarget`通过内部维护一系列`Y.EventCustom`对象，提供了可以通过事件名称进行事件定义、监听和触发的便捷接口。另外，推荐使用`Y.augment`将它以组合的方式加载在其它类上，而不要使用继承。关于`Y.augment`和`Y.extend`之间的异同，可以参考我之前的一篇文章：[Y.extend与Y.augment](/extend-and-augment/)。\n\nYUI很多基础类都扩展了`Y.EventTarget`，重要的有`Y`（YUI instance，sandbox）、`Y.Global`、`Y.Node`、`Y.NodeList`、`Y.Base`等。\n\nYUILibrary有专门一个章节介绍EventTarget，非常详尽，如果你对EventTarget的设计思路和使用方法感兴趣，请移步[YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/)。\n\n<!-- more -->\n\n### 示例\n\n首先，让我们看看`Y.EventTarget`独立调用的例子：\n\n```javascript\n// 例1\nYUI().use('event-custom', function (Y) {\n    var et = new Y.EventTarget();\n\n    et.on('say', function (msg) {\n        console.log('say:', msg);\n    });\n    et.on('listen', function (msg) {\n        console.log('listen:', msg);\n    });\n\n    // output: say: Hello, world\n    instance.fire('say', 'Hello, world');\n});\n```\n\n<!-- more -->\n\n这种方式实际意义不大，YUI中只有`Y.Global`使用了这种方式。\n\n下面，让我们看下最广泛的使用方式，即通过`Y.augment`扩展其它类：\n\n```javascript\n// 例2\nYUI().use('event-custom', function (Y) {\n    function MyClass() {}\n    MyClass.prototype.add = function (item) {\n        // do sth\n        this.fire('addItem', { item: item });\n    };\n    MyClass.prototype.remove = function (item) {\n        // do sth\n        this.fire('removeItem', { item: item });\n    };\n    // 用EventTarget扩展MyClass\n    Y.augment(MyClass, Y.EventTarget);\n\n    var instance = new MyClass();\n    // 监听addItem事件\n    instance.on('addItem', function (data) {\n        console.log('add an item:', data.item);\n    });\n    // 监听removeItem事件\n    instance.on('removeItem', function (data) {\n        console.log('remove an item:', data.item);\n    });\n\n    // output: add an item: orange\n    instance.add('orange');\n    // output: remove an item: red\n    instance.remove('red');\n});\n```\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38)。\n\n```javascript\nvar AFTER_PREFIX = '~AFTER~';\n\n// EventTarget构造器\nvar ET = function (opts) {\n    var o = opts || {};\n    // 私有事件聚合器\n    this._yuievt = this._yuievt || {\n        id: Y.guid(),\n        events: {},\n        config: o,\n        // 默认配置\n        defaults: {\n            context: o.context || this,\n            host: this,\n            emitFacade: o.emitFacade,\n            fireOnce: o.fireOnce,\n            queuable: o.queuable,\n            broadcast: o.broadcast\n        }\n    };\n};\n\nET.prototype = {\n    constructor: ET,\n    // 创建事件\n    publish: function (type, opts) {\n        var ce,\n            events = this._yuievt.events,\n            defaults = this._yuievt.defaults;\n\n        ce = events[type];\n        if (ce) { // 已创建过该事件\n            if (opts) {\n                ce.applyConfig(opts, true);\n            }\n        } else { // 基于CustomEvent，创建新事件\n            ce = new Y.CustomEvent(type,\n                                    (opts) ? Y.merge(defaults, opts) : defaults);\n            events[type] = ce;\n        }\n\n        return ce;\n    },\n    // 监听事件\n    on: function (type, fn, context) {\n        var ce,\n            after,\n            handle,\n            args = null;\n\n        // 判断是否为后置监听\n        if (type.indexOf(AFTER_PREFIX) &gt; -1) {\n            after = true;\n            type = type.substr(AFTER_PREFIX.length);\n        }\n\n        // 获取自定义事件对象，如果未创建则先创建\n        ce = this._yuievt.events[type] || this.publish(type);\n        if (arguments.length &gt; 3) {\n            args = Y.Array(arguments, 3, true);\n        }\n\n        // 调用自定义事件对象的_on方法监听事件\n        handle = ce._on(fn, context, args, after ? 'after' : true);\n\n        return handle;\n    },\n    // 监听一次事件\n    once: function () {\n        var handle = this.on.apply(this, arguments);\n        if (handle.sub) {\n            // 监听器执行一次则失效\n            handle.sub.once = true;\n        }\n        return handle;\n    },\n    // 后置监听事件\n    after: function (type, fn) {\n        var a = Y.Array(arguments, 0, true);\n        a[0] = AFTER_PREFIX + type;\n        return this.on.apply(this, a);\n    },\n    // 后置监听一次事件\n    onceAfter: function () {\n        var handle = this.after.apply(this, arguments);\n        if (handle.sub) {\n            handle.sub.once = true;\n        }\n        return handle;\n    },\n    // 触发事件\n    fire: function (type) {\n        var ce,\n            args;\n        args = Y.Array(arguments, 1, true);\n        ce = this._yuievt.events[type];\n        // 尚未创建事件\n        if (!ce) return true;\n\n        return ce.fire.apply(ce, args);\n    },\n    // 注销事件监听\n    detach: function (type, fn, context) {\n        var events = this._yuievt.events,\n            ce,\n            i;\n\n        // 未设置事件类型，则注销所有类型的事件\n        if (!type) {\n            for (i in events) {\n                if (events.hasOwnProperty(i)) {\n                    events[i].detach(fn, context);\n                }\n            }\n            return this;\n        }\n\n        ce = events[type];\n        if (ce) {\n            ce.detach(fn, context);\n        }\n\n        return this;\n    }\n};\n```\n\n### 进阶用法\n\n`Y.EventTarget`作为一个十分重要的类，提供了非常丰富、方便的使用方式，除了依赖内部`Y.CustomEvent`实现的事件接口、默认执行方法、事件广播等，其余主要有：\n\n#### a) 事件冒泡\n\n多个EventTarget对象之间可以建立一定事件传播关系，类似DOM事件中的冒泡。\n\n```javascript\n// 例3\nYUI().use('event-custom', function (Y) {\n    // 父类\n    function Parent() { ... }\n    Y.augment(Parent, Y.EventTarget, true, null, { emitFacade: true });\n    // 子类\n    function Child() { ... }\n    Y.augment(Child, Y.EventTarget, true, null, { emitFacade: true });\n\n    var parent = new Parent(),\n        child = new Child();\n    // 子类对象添加冒泡目标对象，child -&gt; parent\n    child.addTarget(parent);\n\n    parent.on('hear', function (e) {\n        console.log('parent hear', e.msg);\n    });\n    child.on('hear', function (e) {\n        console.log('child hear', e.msg);\n    });\n\n    // output: child hear Hi, parent hear Hi\n    child.fire('hear', { msg: 'Hi' });\n});\n```\n\n#### b) 事件前缀\n\n在事件冒泡的基础上，考虑到区分不同EventTarget对象触发相同事件，YUI引入了事件前缀（Event Prefix）。\n\n```javascript\n// 例4\nYUI().use('event-custom', function (Y) {\n    // 父类\n    function Parent() { ... }\n    Y.augment(Parent, Y.EventTarget, true, null, {\n        emitFacade: true,\n        prefix: 'parent' // 配置事件前缀\n    });\n    // 子类\n    function Child() { ... }\n    Y.augment(Child, Y.EventTarget, true, null, {\n        emitFacade: true,\n        prefix: 'child' // 配置事件前缀\n    });\n\n    var parent = new Parent(),\n        child = new Child();\n    child.addTarget(parent);\n\n    parent.on('hear', function (e) { // 不能捕捉到child的hear事件\n        console.log('parent hear', e.msg);\n    });\n    child.on('hear', function (e) {\n        console.log('child hear', e.msg);\n    });\n\n    // output: child hear Hi\n    child.fire('hear', { msg: 'Hi' });\n\n    parent.on('*:see', function (e) { // 要想监听到其它EventTarget对象的see事件，需要设置prefix\n        console.log('parent see', e.thing);\n    });\n    child.on('child:see', function (e) { // 等同监听see事件\n        console.log('child see', e.thing);\n    });\n\n    // output: child hear MM, parent see MM\n    child.fire('see', { thing: 'MM' });\n});\n```\n\n## 参考\n\n- [YUILibrary-CustomEvent](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n","slug":"event-target","published":1,"updated":"2021-10-05T09:30:56.356Z","photos":[],"link":"","_id":"cl1klgupf000d8e85h32qf2h5","content":"<p><img src=\"/images/bubble-girl.jpg\" alt=\"bubble girl\"></p>\n<p>上两篇文章<a href=\"/event-do/\">YUI事件体系之Y.Do</a>、<a href=\"/event-custom/\">YUI事件体系之Y.CustomEvent</a>中，分别介绍了YUI实现AOP的<code>Y.Do</code>对象，以及建立自定义事件机制的<code>Y.CustomEvent</code>对象。</p>\n<p>本篇文章，将要介绍YUI事件体系集大成者、最为精华的部分——<code>Y.EventTarget</code>。</p>\n<h2 id=\"Y-EventTarget\"><a href=\"#Y-EventTarget\" class=\"headerlink\" title=\"Y.EventTarget\"></a>Y.EventTarget</h2><p>DOM事件中的目标元素为<code>event.target</code>，这类元素可以触发、监听一些事件，例如input元素的click、focus等事件。这也正是<code>Y.EventTarget</code>的命名渊源，它提供了一种让任意对象定义、监听、触发自定义事件的实现方式。</p>\n<p>从设计上看，<code>Y.EventTarget</code>通过内部维护一系列<code>Y.EventCustom</code>对象，提供了可以通过事件名称进行事件定义、监听和触发的便捷接口。另外，推荐使用<code>Y.augment</code>将它以组合的方式加载在其它类上，而不要使用继承。关于<code>Y.augment</code>和<code>Y.extend</code>之间的异同，可以参考我之前的一篇文章：<a href=\"/extend-and-augment/\">Y.extend与Y.augment</a>。</p>\n<p>YUI很多基础类都扩展了<code>Y.EventTarget</code>，重要的有<code>Y</code>（YUI instance，sandbox）、<code>Y.Global</code>、<code>Y.Node</code>、<code>Y.NodeList</code>、<code>Y.Base</code>等。</p>\n<p>YUILibrary有专门一个章节介绍EventTarget，非常详尽，如果你对EventTarget的设计思路和使用方法感兴趣，请移步<a href=\"http://yuilibrary.com/yui/docs/event-custom/\">YUILibrary-EventTarget</a>。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>首先，让我们看看<code>Y.EventTarget</code>独立调用的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> et = <span class=\"keyword\">new</span> Y.EventTarget();</span><br><span class=\"line\"></span><br><span class=\"line\">    et.on(<span class=\"string\">&#x27;say&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say:&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    et.on(<span class=\"string\">&#x27;listen&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;listen:&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: say: Hello, world</span></span><br><span class=\"line\">    instance.fire(<span class=\"string\">&#x27;say&#x27;</span>, <span class=\"string\">&#x27;Hello, world&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<!-- more -->\n\n<p>这种方式实际意义不大，YUI中只有<code>Y.Global</code>使用了这种方式。</p>\n<p>下面，让我们看下最广泛的使用方式，即通过<code>Y.augment</code>扩展其它类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyClass</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    MyClass.prototype.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.fire(<span class=\"string\">&#x27;addItem&#x27;</span>, &#123; <span class=\"attr\">item</span>: item &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    MyClass.prototype.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.fire(<span class=\"string\">&#x27;removeItem&#x27;</span>, &#123; <span class=\"attr\">item</span>: item &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 用EventTarget扩展MyClass</span></span><br><span class=\"line\">    Y.augment(MyClass, Y.EventTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">    <span class=\"comment\">// 监听addItem事件</span></span><br><span class=\"line\">    instance.on(<span class=\"string\">&#x27;addItem&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;add an item:&#x27;</span>, data.item);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 监听removeItem事件</span></span><br><span class=\"line\">    instance.on(<span class=\"string\">&#x27;removeItem&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;remove an item:&#x27;</span>, data.item);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: add an item: orange</span></span><br><span class=\"line\">    instance.add(<span class=\"string\">&#x27;orange&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// output: remove an item: red</span></span><br><span class=\"line\">    instance.remove(<span class=\"string\">&#x27;red&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> AFTER_PREFIX = <span class=\"string\">&#x27;~AFTER~&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventTarget构造器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ET = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = opts || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 私有事件聚合器</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._yuievt = <span class=\"built_in\">this</span>._yuievt || &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: Y.guid(),</span><br><span class=\"line\">        <span class=\"attr\">events</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"attr\">config</span>: o,</span><br><span class=\"line\">        <span class=\"comment\">// 默认配置</span></span><br><span class=\"line\">        <span class=\"attr\">defaults</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">context</span>: o.context || <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            <span class=\"attr\">host</span>: <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            <span class=\"attr\">emitFacade</span>: o.emitFacade,</span><br><span class=\"line\">            <span class=\"attr\">fireOnce</span>: o.fireOnce,</span><br><span class=\"line\">            <span class=\"attr\">queuable</span>: o.queuable,</span><br><span class=\"line\">            <span class=\"attr\">broadcast</span>: o.broadcast</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ET.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: ET,</span><br><span class=\"line\">    <span class=\"comment\">// 创建事件</span></span><br><span class=\"line\">    <span class=\"attr\">publish</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, opts</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            events = <span class=\"built_in\">this</span>._yuievt.events,</span><br><span class=\"line\">            defaults = <span class=\"built_in\">this</span>._yuievt.defaults;</span><br><span class=\"line\"></span><br><span class=\"line\">        ce = events[type];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ce) &#123; <span class=\"comment\">// 已创建过该事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (opts) &#123;</span><br><span class=\"line\">                ce.applyConfig(opts, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 基于CustomEvent，创建新事件</span></span><br><span class=\"line\">            ce = <span class=\"keyword\">new</span> Y.CustomEvent(type,</span><br><span class=\"line\">                                    (opts) ? Y.merge(defaults, opts) : defaults);</span><br><span class=\"line\">            events[type] = ce;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ce;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 监听事件</span></span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            after,</span><br><span class=\"line\">            handle,</span><br><span class=\"line\">            args = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为后置监听</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.indexOf(AFTER_PREFIX) &amp;gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            after = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            type = type.substr(AFTER_PREFIX.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取自定义事件对象，如果未创建则先创建</span></span><br><span class=\"line\">        ce = <span class=\"built_in\">this</span>._yuievt.events[type] || <span class=\"built_in\">this</span>.publish(type);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">3</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用自定义事件对象的_on方法监听事件</span></span><br><span class=\"line\">        handle = ce._on(fn, context, args, after ? <span class=\"string\">&#x27;after&#x27;</span> : <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 监听一次事件</span></span><br><span class=\"line\">    <span class=\"attr\">once</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> handle = <span class=\"built_in\">this</span>.on.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle.sub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 监听器执行一次则失效</span></span><br><span class=\"line\">            handle.sub.once = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 后置监听事件</span></span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        a[<span class=\"number\">0</span>] = AFTER_PREFIX + type;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.on.apply(<span class=\"built_in\">this</span>, a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 后置监听一次事件</span></span><br><span class=\"line\">    <span class=\"attr\">onceAfter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> handle = <span class=\"built_in\">this</span>.after.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle.sub) &#123;</span><br><span class=\"line\">            handle.sub.once = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    <span class=\"attr\">fire</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            args;</span><br><span class=\"line\">        args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        ce = <span class=\"built_in\">this</span>._yuievt.events[type];</span><br><span class=\"line\">        <span class=\"comment\">// 尚未创建事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ce) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ce.fire.apply(ce, args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 注销事件监听</span></span><br><span class=\"line\">    <span class=\"attr\">detach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> events = <span class=\"built_in\">this</span>._yuievt.events,</span><br><span class=\"line\">            ce,</span><br><span class=\"line\">            i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 未设置事件类型，则注销所有类型的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> events) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (events.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                    events[i].detach(fn, context);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ce = events[type];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ce) &#123;</span><br><span class=\"line\">            ce.detach(fn, context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p><code>Y.EventTarget</code>作为一个十分重要的类，提供了非常丰富、方便的使用方式，除了依赖内部<code>Y.CustomEvent</code>实现的事件接口、默认执行方法、事件广播等，其余主要有：</p>\n<h4 id=\"a-事件冒泡\"><a href=\"#a-事件冒泡\" class=\"headerlink\" title=\"a) 事件冒泡\"></a>a) 事件冒泡</h4><p>多个EventTarget对象之间可以建立一定事件传播关系，类似DOM事件中的冒泡。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Parent, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123; <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 子类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Child, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123; <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(),</span><br><span class=\"line\">        child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    <span class=\"comment\">// 子类对象添加冒泡目标对象，child -&amp;gt; parent</span></span><br><span class=\"line\">    child.addTarget(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear Hi, parent hear Hi</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;hear&#x27;</span>, &#123; <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;Hi&#x27;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-事件前缀\"><a href=\"#b-事件前缀\" class=\"headerlink\" title=\"b) 事件前缀\"></a>b) 事件前缀</h4><p>在事件冒泡的基础上，考虑到区分不同EventTarget对象触发相同事件，YUI引入了事件前缀（Event Prefix）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Parent, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">prefix</span>: <span class=\"string\">&#x27;parent&#x27;</span> <span class=\"comment\">// 配置事件前缀</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 子类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Child, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">prefix</span>: <span class=\"string\">&#x27;child&#x27;</span> <span class=\"comment\">// 配置事件前缀</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(),</span><br><span class=\"line\">        child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    child.addTarget(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 不能捕捉到child的hear事件</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear Hi</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;hear&#x27;</span>, &#123; <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;Hi&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;*:see&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 要想监听到其它EventTarget对象的see事件，需要设置prefix</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent see&#x27;</span>, e.thing);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;child:see&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 等同监听see事件</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child see&#x27;</span>, e.thing);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear MM, parent see MM</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;see&#x27;</span>, &#123; <span class=\"attr\">thing</span>: <span class=\"string\">&#x27;MM&#x27;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html\">YUILibrary-CustomEvent</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/bubble-girl.jpg\" alt=\"bubble girl\"></p>\n<p>上两篇文章<a href=\"/event-do/\">YUI事件体系之Y.Do</a>、<a href=\"/event-custom/\">YUI事件体系之Y.CustomEvent</a>中，分别介绍了YUI实现AOP的<code>Y.Do</code>对象，以及建立自定义事件机制的<code>Y.CustomEvent</code>对象。</p>\n<p>本篇文章，将要介绍YUI事件体系集大成者、最为精华的部分——<code>Y.EventTarget</code>。</p>\n<h2 id=\"Y-EventTarget\"><a href=\"#Y-EventTarget\" class=\"headerlink\" title=\"Y.EventTarget\"></a>Y.EventTarget</h2><p>DOM事件中的目标元素为<code>event.target</code>，这类元素可以触发、监听一些事件，例如input元素的click、focus等事件。这也正是<code>Y.EventTarget</code>的命名渊源，它提供了一种让任意对象定义、监听、触发自定义事件的实现方式。</p>\n<p>从设计上看，<code>Y.EventTarget</code>通过内部维护一系列<code>Y.EventCustom</code>对象，提供了可以通过事件名称进行事件定义、监听和触发的便捷接口。另外，推荐使用<code>Y.augment</code>将它以组合的方式加载在其它类上，而不要使用继承。关于<code>Y.augment</code>和<code>Y.extend</code>之间的异同，可以参考我之前的一篇文章：<a href=\"/extend-and-augment/\">Y.extend与Y.augment</a>。</p>\n<p>YUI很多基础类都扩展了<code>Y.EventTarget</code>，重要的有<code>Y</code>（YUI instance，sandbox）、<code>Y.Global</code>、<code>Y.Node</code>、<code>Y.NodeList</code>、<code>Y.Base</code>等。</p>\n<p>YUILibrary有专门一个章节介绍EventTarget，非常详尽，如果你对EventTarget的设计思路和使用方法感兴趣，请移步<a href=\"http://yuilibrary.com/yui/docs/event-custom/\">YUILibrary-EventTarget</a>。</p>","more":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>首先，让我们看看<code>Y.EventTarget</code>独立调用的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> et = <span class=\"keyword\">new</span> Y.EventTarget();</span><br><span class=\"line\"></span><br><span class=\"line\">    et.on(<span class=\"string\">&#x27;say&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say:&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    et.on(<span class=\"string\">&#x27;listen&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;listen:&#x27;</span>, msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: say: Hello, world</span></span><br><span class=\"line\">    instance.fire(<span class=\"string\">&#x27;say&#x27;</span>, <span class=\"string\">&#x27;Hello, world&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<!-- more -->\n\n<p>这种方式实际意义不大，YUI中只有<code>Y.Global</code>使用了这种方式。</p>\n<p>下面，让我们看下最广泛的使用方式，即通过<code>Y.augment</code>扩展其它类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyClass</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    MyClass.prototype.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.fire(<span class=\"string\">&#x27;addItem&#x27;</span>, &#123; <span class=\"attr\">item</span>: item &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    MyClass.prototype.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.fire(<span class=\"string\">&#x27;removeItem&#x27;</span>, &#123; <span class=\"attr\">item</span>: item &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 用EventTarget扩展MyClass</span></span><br><span class=\"line\">    Y.augment(MyClass, Y.EventTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">    <span class=\"comment\">// 监听addItem事件</span></span><br><span class=\"line\">    instance.on(<span class=\"string\">&#x27;addItem&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;add an item:&#x27;</span>, data.item);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 监听removeItem事件</span></span><br><span class=\"line\">    instance.on(<span class=\"string\">&#x27;removeItem&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;remove an item:&#x27;</span>, data.item);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: add an item: orange</span></span><br><span class=\"line\">    instance.add(<span class=\"string\">&#x27;orange&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// output: remove an item: red</span></span><br><span class=\"line\">    instance.remove(<span class=\"string\">&#x27;red&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html#l38\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> AFTER_PREFIX = <span class=\"string\">&#x27;~AFTER~&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventTarget构造器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ET = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = opts || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 私有事件聚合器</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._yuievt = <span class=\"built_in\">this</span>._yuievt || &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: Y.guid(),</span><br><span class=\"line\">        <span class=\"attr\">events</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"attr\">config</span>: o,</span><br><span class=\"line\">        <span class=\"comment\">// 默认配置</span></span><br><span class=\"line\">        <span class=\"attr\">defaults</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">context</span>: o.context || <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            <span class=\"attr\">host</span>: <span class=\"built_in\">this</span>,</span><br><span class=\"line\">            <span class=\"attr\">emitFacade</span>: o.emitFacade,</span><br><span class=\"line\">            <span class=\"attr\">fireOnce</span>: o.fireOnce,</span><br><span class=\"line\">            <span class=\"attr\">queuable</span>: o.queuable,</span><br><span class=\"line\">            <span class=\"attr\">broadcast</span>: o.broadcast</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ET.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: ET,</span><br><span class=\"line\">    <span class=\"comment\">// 创建事件</span></span><br><span class=\"line\">    <span class=\"attr\">publish</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, opts</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            events = <span class=\"built_in\">this</span>._yuievt.events,</span><br><span class=\"line\">            defaults = <span class=\"built_in\">this</span>._yuievt.defaults;</span><br><span class=\"line\"></span><br><span class=\"line\">        ce = events[type];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ce) &#123; <span class=\"comment\">// 已创建过该事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (opts) &#123;</span><br><span class=\"line\">                ce.applyConfig(opts, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 基于CustomEvent，创建新事件</span></span><br><span class=\"line\">            ce = <span class=\"keyword\">new</span> Y.CustomEvent(type,</span><br><span class=\"line\">                                    (opts) ? Y.merge(defaults, opts) : defaults);</span><br><span class=\"line\">            events[type] = ce;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ce;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 监听事件</span></span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            after,</span><br><span class=\"line\">            handle,</span><br><span class=\"line\">            args = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为后置监听</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.indexOf(AFTER_PREFIX) &amp;gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            after = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            type = type.substr(AFTER_PREFIX.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取自定义事件对象，如果未创建则先创建</span></span><br><span class=\"line\">        ce = <span class=\"built_in\">this</span>._yuievt.events[type] || <span class=\"built_in\">this</span>.publish(type);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &amp;gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">3</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用自定义事件对象的_on方法监听事件</span></span><br><span class=\"line\">        handle = ce._on(fn, context, args, after ? <span class=\"string\">&#x27;after&#x27;</span> : <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 监听一次事件</span></span><br><span class=\"line\">    <span class=\"attr\">once</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> handle = <span class=\"built_in\">this</span>.on.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle.sub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 监听器执行一次则失效</span></span><br><span class=\"line\">            handle.sub.once = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 后置监听事件</span></span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        a[<span class=\"number\">0</span>] = AFTER_PREFIX + type;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.on.apply(<span class=\"built_in\">this</span>, a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 后置监听一次事件</span></span><br><span class=\"line\">    <span class=\"attr\">onceAfter</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> handle = <span class=\"built_in\">this</span>.after.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle.sub) &#123;</span><br><span class=\"line\">            handle.sub.once = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    <span class=\"attr\">fire</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ce,</span><br><span class=\"line\">            args;</span><br><span class=\"line\">        args = Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        ce = <span class=\"built_in\">this</span>._yuievt.events[type];</span><br><span class=\"line\">        <span class=\"comment\">// 尚未创建事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ce) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ce.fire.apply(ce, args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 注销事件监听</span></span><br><span class=\"line\">    <span class=\"attr\">detach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, context</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> events = <span class=\"built_in\">this</span>._yuievt.events,</span><br><span class=\"line\">            ce,</span><br><span class=\"line\">            i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 未设置事件类型，则注销所有类型的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> events) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (events.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">                    events[i].detach(fn, context);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ce = events[type];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ce) &#123;</span><br><span class=\"line\">            ce.detach(fn, context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p><code>Y.EventTarget</code>作为一个十分重要的类，提供了非常丰富、方便的使用方式，除了依赖内部<code>Y.CustomEvent</code>实现的事件接口、默认执行方法、事件广播等，其余主要有：</p>\n<h4 id=\"a-事件冒泡\"><a href=\"#a-事件冒泡\" class=\"headerlink\" title=\"a) 事件冒泡\"></a>a) 事件冒泡</h4><p>多个EventTarget对象之间可以建立一定事件传播关系，类似DOM事件中的冒泡。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Parent, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123; <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 子类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Child, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123; <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(),</span><br><span class=\"line\">        child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    <span class=\"comment\">// 子类对象添加冒泡目标对象，child -&amp;gt; parent</span></span><br><span class=\"line\">    child.addTarget(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear Hi, parent hear Hi</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;hear&#x27;</span>, &#123; <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;Hi&#x27;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-事件前缀\"><a href=\"#b-事件前缀\" class=\"headerlink\" title=\"b) 事件前缀\"></a>b) 事件前缀</h4><p>在事件冒泡的基础上，考虑到区分不同EventTarget对象触发相同事件，YUI引入了事件前缀（Event Prefix）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Parent, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">prefix</span>: <span class=\"string\">&#x27;parent&#x27;</span> <span class=\"comment\">// 配置事件前缀</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 子类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">    Y.augment(Child, Y.EventTarget, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">prefix</span>: <span class=\"string\">&#x27;child&#x27;</span> <span class=\"comment\">// 配置事件前缀</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(),</span><br><span class=\"line\">        child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    child.addTarget(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 不能捕捉到child的hear事件</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;hear&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child hear&#x27;</span>, e.msg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear Hi</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;hear&#x27;</span>, &#123; <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;Hi&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    parent.on(<span class=\"string\">&#x27;*:see&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 要想监听到其它EventTarget对象的see事件，需要设置prefix</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;parent see&#x27;</span>, e.thing);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    child.on(<span class=\"string\">&#x27;child:see&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// 等同监听see事件</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;child see&#x27;</span>, e.thing);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// output: child hear MM, parent see MM</span></span><br><span class=\"line\">    child.fire(<span class=\"string\">&#x27;see&#x27;</span>, &#123; <span class=\"attr\">thing</span>: <span class=\"string\">&#x27;MM&#x27;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-custom.js.html\">YUILibrary-CustomEvent</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n</ul>"},{"layout":"post","title":"YUI事件体系之Y.Event","date":"2013-01-20T06:12:00.000Z","status":"publish","_content":"\n![mouse event](/images/mouse.png)\n\n在介绍了由`Y.Do`、`Y.CustomEvent`、`Y.EventTarget`构建的自定义事件体系后，本篇文章将为大家介绍建立在这一体系之上，YUI对DOM事件的封装——`Y.Event`。\n\n## Y.DOMEventFacade\n\n众所周知，浏览器之间存在大量的不兼容问题，在事件方面尤其如此。`Y.DOMEventFacade`主要用来处理DOM事件对象的浏览器兼容问题，提供跨浏览器的简洁接口。事实上，我们常在`Y.one('.selector').on('click', function (e) {})`中使用的`e`就是`Y.DOMEventFacade`的实例。\n\n具体来说，兼容处理的属性主要有：\n\n- target，专门处理了target为文本节点的情况，统一为元素节点，方便操作\n- relativeTarget，关联目标节点，在mouseover/mouseout等事件中设置\n- keyCode/charCode等输入信息\n- pageX/clientX等位置信息\n\n兼容处理的方法主要有：\n\n- stopPropagation/stopImmediatePropagation，不支持停止立即传播时，仅能在YUI层面模拟，不会阻止通过原生方法添加的同层回调，即，在YUI监听过el的click事件后，又通过`el.addEventListener('click', nativeCallback)`监听，如果在YUI的回调中调用`e.stopImmediatePropagation`的话，`nativeCallback`仍然会执行\n- preventDefault\n\n另外，为了方便同时停止传播和阻止默认行为，YUI还提供了`halt`方法。\n\n<!-- more -->\n\n我们来简单分析下`Y.DOMEventFacade`的实现：\n\n```js\n// 为简化代码，省略了专门针对未实现DOM2 Events规范浏览器中的事件对象兼容性处理（代码在event-base-ie模块）\n\nvar DOMEventFacade = function (ev, currentTarget, wrapper) {\n    this._event = ev;\n    this._currentTarget = currentTarget;\n    this._wrapper = wrapper || {};\n\n    this.init();\n};\n\n// 确定目标节点\nDOMEventFacade.resolve = function (n) {\n    if (!n) return n;\n    try {\n        // 如果是TEXT_NODE，则取其父节点\n        if (n && 3 === n.nodeType) n = n.parentNode;\n    } catch (e) {\n        return null;\n    }\n    return Y.one(n);\n};\n\nY.extend(DOMEventFacade, Object, {\n    // 初始化。主要处理事件对象的浏览器兼容问题\n    init: function () {\n        var e = this._event,\n            resolve = DOMEventFacade.resolve;\n\n        // 此处省略对key和dimension的兼容性处理\n\n        this.type = e.type;\n        this.target = resolve(e.target);\n        this.currentTarget = resolve(this._currentTarget);\n        this.relatedTarget = resolve(e.relatedTarget);\n    },\n    // 停止传播\n    stopPropagation: function () {\n        this._event.stopPropagation();\n        this._wrapper.stopped = 1;\n        this.stopped = 1;\n    },\n    // 立即停止传播，不处理同一节点的后续回调\n    stopImmediatePropagation: function () {\n        var e = this._event;\n        if (e.stopImmediatePropagation) {\n            // 原生事件对象支持立即停止传播\n            e.stopImmediatePropagation();\n        } else {\n            // 仅停止传播，在原生层面会继续同层传播\n            this.stopPropagation();\n        }\n        this._wrapper.stopped = 2;\n        this.stopped = 2;\n    },\n    // 阻止默认事件\n    preventDefault: function (returnValue) {\n        var e = this._event;\n        e.preventDefault();\n        e.returnValue = returnValue || false;\n        this._wrapper.prevented = 1;\n        this.prevented = 1;\n    },\n    // 中止事件，包括停止传播和阻止默认事件\n    halt: function (immediate) {\n        if (immediate) {\n            this.stopImmediatePropagation();\n        } else {\n            this.stopPropagation();\n        }\n\n        this.preventDefault();\n    }\n});\n\nY.DOMEventFacade = DOMEventFacade;\n```\n\n## Y.Event\n\n`Y.Event`的主要作用是提供添加、注销DOM事件监听的接口。和我们通常的理解不一样的是，它并不是一个类，而是一个简单的对象。\n\nYUI对DOM事件监听的处理思路大体是：根据节点、事件类型，创建一个`Y.CustomEvent`对象cewrapper。然后通过原生方法注册事件监听，回调执行`cewrapper.fire`方法。所有通过YUI添加的事件监听，都注册cewrapper上，从而实现对DOM事件的包装。\n\n我们先来看下如何使用`Y.Event`添加事件监听：\n\n```js\n// 例1\nYUI().use('selector', 'event-base', function(Y) {\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked');\n    }, '#btn-one');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked again');\n    }, '#btn-one');\n\n    // click #btn-one\n    // output '#btn-one clicked', '#btn-one clicked again'\n\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked');\n        e.stopPropagation();\n    }, '#btn-two');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked again');\n        e.stopImmediatePropagation();\n    }, '#btn-two');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked the third time');\n    }, '#btn-two');\n\n    // click #btn-two\n    // output '#btn-two clicked', '#btn-two clicked again'\n});\n```\n\n当然，也可以使用`Y.Event`注销事件监听：\n\n```js\n// 例2\nYUI().use('selector', 'event-base', function(Y) {\n    var countThree = 0;\n    var handle = Y.Event.attach('click', function (e) {\n        console.log('#btn-three clicked', ++countThree);\n        handle.detach();\n    }, '#btn-three');\n\n    // click #btn-three many times\n    // output '#btn-three clicked 1'\n\n    var countFour = 0;\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-four clicked', ++countFour);\n        Y.Event.detach('click', null, '#btn-four');\n    }, '#btn-four');\n\n    // click #btn-four many times\n    // output '#btn-four clicked 1'\n});\n```\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js#L397)。\n\n```js\nvar add = function (el, type, fn, capture) {\n        if (el && el.addEventListener) {\n            el.addEventListener(type, fn, capture);\n        } else if (el && el.attachEvent) {\n            el.attachEvent('on' + type, fn);\n        }\n    },\n    remove = function (el, type, fn, capture) {\n        if (el && el.removeEventListener) {\n            try {\n                el.removeEventListener(type, fn, capture);\n            } catch (ex) {}\n        } else if (el && el.detachEvent) {\n            el.detachEvent('on' + type, fn);\n        }\n    },\n    // 判断o是否为HTMLCollection或HTMLElement数组\n    shouldIterate = function (o) {\n        try {\n            return (o && typeof o !== \"string\" && Y.Lang.isNumber(o.length) && !o.tagName && !Y.DOM.isWindow(o));\n        } catch (ex) {\n            return false;\n        }\n    };\n\nY.Env.evt.dom_wrappers = {};\nY.Env.evt.dom_map = {};\n\nvar Event = function () {\n    var _wrappers = Y.Env.evt.dom_wrappers,\n        _el_events = Y.Env.evt.dom_map;\n\n    return {\n        // 添加事件监听\n        attach: function (type, fn, el, context) {\n            return Event._attach(Y.Array(arguments, 0, true));\n        },\n\n        // 创建自定义事件对象，在原生事件触发时执行该对象的fire方法，\n        // 从而处理它上面的所有回调\n        _createWrapper: function (el, type) {\n            var cewrapper,\n                ek  = Y.stamp(el),\n                key = 'event:' + ek + type;\n\n            cewrapper = _wrappers[key];\n            if (!cewrapper) {\n                cewrapper = Y.publish(key, {\n                    silent: true,\n                    bubbles: false,\n                    contextFn: function () {\n                        cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);\n                        return cewrapper.nodeRef;\n                    }\n                });\n\n                cewrapper.overrides = {};\n\n                cewrapper.el = el;\n                cewrapper.key = key;\n                cewrapper.domkey = ek;\n                cewrapper.type = type;\n                // 作为原生DOM事件回调\n                cewrapper.fn = function (e) {\n                    // 触发事件，回调方法可以直接调用作为第一个参数的\n                    // DOM事件包装对象\n                    cewrapper.fire(Event.getEvent(e, el));\n                };\n\n                // 重写_delete方法，执行_clean来注销原生DOM节点事件监听\n                cewrapper._delete = function (s) {\n                    var ret = Y.CustomEvent.prototype._delete.apply(this, arguments);\n                    if (!this.hasSubs()) {\n                        // 全部回调都被注销，则注销DOM事件监听\n                        Event._clean(this);\n                    }\n                    return ret;\n                };\n\n                _wrappers[key] = cewrapper;\n                _el_events[ek] = _el_events[ek] || {};\n                _el_events[ek][key] = cewrapper;\n\n                // 通过原生方法注册事件监听，这是关键的入口\n                add(el, type, cewrapper.fn);\n            }\n\n            return cewrapper;\n        },\n\n        // 添加事件监听的内部实现\n        _attach: function (args) {\n            var handles, oEl, cewrapper, context,\n                ret,\n                type = args[0],\n                fn = args[1],\n                el = args[2];\n            if (!fn || !fn.call) return false;\n\n       l) return false;\n\n            if (Y.Node && Y.instanceOf(el,      lis = Event.getListeners(oEl, type),\n                i, lYUI().use('node-base', 'selector', 'event-base', function(Y)  recursively');\n    }, '#btn-six');\n\n    // click #btn-six\n    // and then, click any elements in #wrapper\n    // output nothing\n});\n```\n\n## 通过Y和Node监听事件\n\nYUI3借鉴了jQuery对HTMLElement/HTMLCollection的封装方式，方便进行链式调用，这就是`Y.Node`。\n\n事件监听是不是可以不用繁琐的使用`Y.Event`，在`Y.Node`对象上直接调用呢？当然可以。主要有四个方法：\n\n- NodeInstance.on\n- NodeInstance.once\n- NodeInstance.after\n- NodeInstance.onceAfter\n\n实际上，以上四个方法是通过内部调用Y的对应方法，例如`Node.prototype.on`内部调用了`Y.on`，而Y上的对应方法是由于Y本身是一个`Y.EventTarget`对象才获得的。最终，在`Y.EventTarget.prototype.on`中调用了`Y.Event`。\n\n```js\n// 例5\nYUI().use('node', function(Y) {\n    Y.Event.attach('click', function (e) {\n        console.log('wrapper clicked');\n    }, '#btn-one');\n\n    // 等价的Y.on写法\n    Y.on('click', function (e) {\n        console.log('btn-one clicked');\n    }, '#btn-one');\n\n    // 等价的Node.on写法\n    Y.one('#btn-one').on('click', function (e) {\n        console.log('btn-one clicked');\n    });\n});\n```\n\n## 示例代码\n\n所有示例代码均在[GitHub](https://github.com/springuper/yuianalyser/tree/master/event)。\n\n## 参考\n\n- [YUILibrary-UserGuides-Event](http://yuilibrary.com/yui/docs/event/)\n- [YUILibrary-Event](https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js)\n   \n","source":"_posts/event.md","raw":"---\nlayout: post\ntitle: \"YUI事件体系之Y.Event\"\ndate: 2013-01-20 14:12\nstatus: publish\ntags: [Y.Event, YUI]\n---\n\n![mouse event](/images/mouse.png)\n\n在介绍了由`Y.Do`、`Y.CustomEvent`、`Y.EventTarget`构建的自定义事件体系后，本篇文章将为大家介绍建立在这一体系之上，YUI对DOM事件的封装——`Y.Event`。\n\n## Y.DOMEventFacade\n\n众所周知，浏览器之间存在大量的不兼容问题，在事件方面尤其如此。`Y.DOMEventFacade`主要用来处理DOM事件对象的浏览器兼容问题，提供跨浏览器的简洁接口。事实上，我们常在`Y.one('.selector').on('click', function (e) {})`中使用的`e`就是`Y.DOMEventFacade`的实例。\n\n具体来说，兼容处理的属性主要有：\n\n- target，专门处理了target为文本节点的情况，统一为元素节点，方便操作\n- relativeTarget，关联目标节点，在mouseover/mouseout等事件中设置\n- keyCode/charCode等输入信息\n- pageX/clientX等位置信息\n\n兼容处理的方法主要有：\n\n- stopPropagation/stopImmediatePropagation，不支持停止立即传播时，仅能在YUI层面模拟，不会阻止通过原生方法添加的同层回调，即，在YUI监听过el的click事件后，又通过`el.addEventListener('click', nativeCallback)`监听，如果在YUI的回调中调用`e.stopImmediatePropagation`的话，`nativeCallback`仍然会执行\n- preventDefault\n\n另外，为了方便同时停止传播和阻止默认行为，YUI还提供了`halt`方法。\n\n<!-- more -->\n\n我们来简单分析下`Y.DOMEventFacade`的实现：\n\n```js\n// 为简化代码，省略了专门针对未实现DOM2 Events规范浏览器中的事件对象兼容性处理（代码在event-base-ie模块）\n\nvar DOMEventFacade = function (ev, currentTarget, wrapper) {\n    this._event = ev;\n    this._currentTarget = currentTarget;\n    this._wrapper = wrapper || {};\n\n    this.init();\n};\n\n// 确定目标节点\nDOMEventFacade.resolve = function (n) {\n    if (!n) return n;\n    try {\n        // 如果是TEXT_NODE，则取其父节点\n        if (n && 3 === n.nodeType) n = n.parentNode;\n    } catch (e) {\n        return null;\n    }\n    return Y.one(n);\n};\n\nY.extend(DOMEventFacade, Object, {\n    // 初始化。主要处理事件对象的浏览器兼容问题\n    init: function () {\n        var e = this._event,\n            resolve = DOMEventFacade.resolve;\n\n        // 此处省略对key和dimension的兼容性处理\n\n        this.type = e.type;\n        this.target = resolve(e.target);\n        this.currentTarget = resolve(this._currentTarget);\n        this.relatedTarget = resolve(e.relatedTarget);\n    },\n    // 停止传播\n    stopPropagation: function () {\n        this._event.stopPropagation();\n        this._wrapper.stopped = 1;\n        this.stopped = 1;\n    },\n    // 立即停止传播，不处理同一节点的后续回调\n    stopImmediatePropagation: function () {\n        var e = this._event;\n        if (e.stopImmediatePropagation) {\n            // 原生事件对象支持立即停止传播\n            e.stopImmediatePropagation();\n        } else {\n            // 仅停止传播，在原生层面会继续同层传播\n            this.stopPropagation();\n        }\n        this._wrapper.stopped = 2;\n        this.stopped = 2;\n    },\n    // 阻止默认事件\n    preventDefault: function (returnValue) {\n        var e = this._event;\n        e.preventDefault();\n        e.returnValue = returnValue || false;\n        this._wrapper.prevented = 1;\n        this.prevented = 1;\n    },\n    // 中止事件，包括停止传播和阻止默认事件\n    halt: function (immediate) {\n        if (immediate) {\n            this.stopImmediatePropagation();\n        } else {\n            this.stopPropagation();\n        }\n\n        this.preventDefault();\n    }\n});\n\nY.DOMEventFacade = DOMEventFacade;\n```\n\n## Y.Event\n\n`Y.Event`的主要作用是提供添加、注销DOM事件监听的接口。和我们通常的理解不一样的是，它并不是一个类，而是一个简单的对象。\n\nYUI对DOM事件监听的处理思路大体是：根据节点、事件类型，创建一个`Y.CustomEvent`对象cewrapper。然后通过原生方法注册事件监听，回调执行`cewrapper.fire`方法。所有通过YUI添加的事件监听，都注册cewrapper上，从而实现对DOM事件的包装。\n\n我们先来看下如何使用`Y.Event`添加事件监听：\n\n```js\n// 例1\nYUI().use('selector', 'event-base', function(Y) {\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked');\n    }, '#btn-one');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked again');\n    }, '#btn-one');\n\n    // click #btn-one\n    // output '#btn-one clicked', '#btn-one clicked again'\n\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked');\n        e.stopPropagation();\n    }, '#btn-two');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked again');\n        e.stopImmediatePropagation();\n    }, '#btn-two');\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-one clicked the third time');\n    }, '#btn-two');\n\n    // click #btn-two\n    // output '#btn-two clicked', '#btn-two clicked again'\n});\n```\n\n当然，也可以使用`Y.Event`注销事件监听：\n\n```js\n// 例2\nYUI().use('selector', 'event-base', function(Y) {\n    var countThree = 0;\n    var handle = Y.Event.attach('click', function (e) {\n        console.log('#btn-three clicked', ++countThree);\n        handle.detach();\n    }, '#btn-three');\n\n    // click #btn-three many times\n    // output '#btn-three clicked 1'\n\n    var countFour = 0;\n    Y.Event.attach('click', function (e) {\n        console.log('#btn-four clicked', ++countFour);\n        Y.Event.detach('click', null, '#btn-four');\n    }, '#btn-four');\n\n    // click #btn-four many times\n    // output '#btn-four clicked 1'\n});\n```\n\n### 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。\n\n注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js#L397)。\n\n```js\nvar add = function (el, type, fn, capture) {\n        if (el && el.addEventListener) {\n            el.addEventListener(type, fn, capture);\n        } else if (el && el.attachEvent) {\n            el.attachEvent('on' + type, fn);\n        }\n    },\n    remove = function (el, type, fn, capture) {\n        if (el && el.removeEventListener) {\n            try {\n                el.removeEventListener(type, fn, capture);\n            } catch (ex) {}\n        } else if (el && el.detachEvent) {\n            el.detachEvent('on' + type, fn);\n        }\n    },\n    // 判断o是否为HTMLCollection或HTMLElement数组\n    shouldIterate = function (o) {\n        try {\n            return (o && typeof o !== \"string\" && Y.Lang.isNumber(o.length) && !o.tagName && !Y.DOM.isWindow(o));\n        } catch (ex) {\n            return false;\n        }\n    };\n\nY.Env.evt.dom_wrappers = {};\nY.Env.evt.dom_map = {};\n\nvar Event = function () {\n    var _wrappers = Y.Env.evt.dom_wrappers,\n        _el_events = Y.Env.evt.dom_map;\n\n    return {\n        // 添加事件监听\n        attach: function (type, fn, el, context) {\n            return Event._attach(Y.Array(arguments, 0, true));\n        },\n\n        // 创建自定义事件对象，在原生事件触发时执行该对象的fire方法，\n        // 从而处理它上面的所有回调\n        _createWrapper: function (el, type) {\n            var cewrapper,\n                ek  = Y.stamp(el),\n                key = 'event:' + ek + type;\n\n            cewrapper = _wrappers[key];\n            if (!cewrapper) {\n                cewrapper = Y.publish(key, {\n                    silent: true,\n                    bubbles: false,\n                    contextFn: function () {\n                        cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);\n                        return cewrapper.nodeRef;\n                    }\n                });\n\n                cewrapper.overrides = {};\n\n                cewrapper.el = el;\n                cewrapper.key = key;\n                cewrapper.domkey = ek;\n                cewrapper.type = type;\n                // 作为原生DOM事件回调\n                cewrapper.fn = function (e) {\n                    // 触发事件，回调方法可以直接调用作为第一个参数的\n                    // DOM事件包装对象\n                    cewrapper.fire(Event.getEvent(e, el));\n                };\n\n                // 重写_delete方法，执行_clean来注销原生DOM节点事件监听\n                cewrapper._delete = function (s) {\n                    var ret = Y.CustomEvent.prototype._delete.apply(this, arguments);\n                    if (!this.hasSubs()) {\n                        // 全部回调都被注销，则注销DOM事件监听\n                        Event._clean(this);\n                    }\n                    return ret;\n                };\n\n                _wrappers[key] = cewrapper;\n                _el_events[ek] = _el_events[ek] || {};\n                _el_events[ek][key] = cewrapper;\n\n                // 通过原生方法注册事件监听，这是关键的入口\n                add(el, type, cewrapper.fn);\n            }\n\n            return cewrapper;\n        },\n\n        // 添加事件监听的内部实现\n        _attach: function (args) {\n            var handles, oEl, cewrapper, context,\n                ret,\n                type = args[0],\n                fn = args[1],\n                el = args[2];\n            if (!fn || !fn.call) return false;\n\n       l) return false;\n\n            if (Y.Node && Y.instanceOf(el,      lis = Event.getListeners(oEl, type),\n                i, lYUI().use('node-base', 'selector', 'event-base', function(Y)  recursively');\n    }, '#btn-six');\n\n    // click #btn-six\n    // and then, click any elements in #wrapper\n    // output nothing\n});\n```\n\n## 通过Y和Node监听事件\n\nYUI3借鉴了jQuery对HTMLElement/HTMLCollection的封装方式，方便进行链式调用，这就是`Y.Node`。\n\n事件监听是不是可以不用繁琐的使用`Y.Event`，在`Y.Node`对象上直接调用呢？当然可以。主要有四个方法：\n\n- NodeInstance.on\n- NodeInstance.once\n- NodeInstance.after\n- NodeInstance.onceAfter\n\n实际上，以上四个方法是通过内部调用Y的对应方法，例如`Node.prototype.on`内部调用了`Y.on`，而Y上的对应方法是由于Y本身是一个`Y.EventTarget`对象才获得的。最终，在`Y.EventTarget.prototype.on`中调用了`Y.Event`。\n\n```js\n// 例5\nYUI().use('node', function(Y) {\n    Y.Event.attach('click', function (e) {\n        console.log('wrapper clicked');\n    }, '#btn-one');\n\n    // 等价的Y.on写法\n    Y.on('click', function (e) {\n        console.log('btn-one clicked');\n    }, '#btn-one');\n\n    // 等价的Node.on写法\n    Y.one('#btn-one').on('click', function (e) {\n        console.log('btn-one clicked');\n    });\n});\n```\n\n## 示例代码\n\n所有示例代码均在[GitHub](https://github.com/springuper/yuianalyser/tree/master/event)。\n\n## 参考\n\n- [YUILibrary-UserGuides-Event](http://yuilibrary.com/yui/docs/event/)\n- [YUILibrary-Event](https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js)\n   \n","slug":"event","published":1,"updated":"2021-10-05T09:21:41.238Z","comments":1,"photos":[],"link":"","_id":"cl1klguph000g8e85er5e0m55","content":"<p><img src=\"/images/mouse.png\" alt=\"mouse event\"></p>\n<p>在介绍了由<code>Y.Do</code>、<code>Y.CustomEvent</code>、<code>Y.EventTarget</code>构建的自定义事件体系后，本篇文章将为大家介绍建立在这一体系之上，YUI对DOM事件的封装——<code>Y.Event</code>。</p>\n<h2 id=\"Y-DOMEventFacade\"><a href=\"#Y-DOMEventFacade\" class=\"headerlink\" title=\"Y.DOMEventFacade\"></a>Y.DOMEventFacade</h2><p>众所周知，浏览器之间存在大量的不兼容问题，在事件方面尤其如此。<code>Y.DOMEventFacade</code>主要用来处理DOM事件对象的浏览器兼容问题，提供跨浏览器的简洁接口。事实上，我们常在<code>Y.one(&#39;.selector&#39;).on(&#39;click&#39;, function (e) &#123;&#125;)</code>中使用的<code>e</code>就是<code>Y.DOMEventFacade</code>的实例。</p>\n<p>具体来说，兼容处理的属性主要有：</p>\n<ul>\n<li>target，专门处理了target为文本节点的情况，统一为元素节点，方便操作</li>\n<li>relativeTarget，关联目标节点，在mouseover/mouseout等事件中设置</li>\n<li>keyCode/charCode等输入信息</li>\n<li>pageX/clientX等位置信息</li>\n</ul>\n<p>兼容处理的方法主要有：</p>\n<ul>\n<li>stopPropagation/stopImmediatePropagation，不支持停止立即传播时，仅能在YUI层面模拟，不会阻止通过原生方法添加的同层回调，即，在YUI监听过el的click事件后，又通过<code>el.addEventListener(&#39;click&#39;, nativeCallback)</code>监听，如果在YUI的回调中调用<code>e.stopImmediatePropagation</code>的话，<code>nativeCallback</code>仍然会执行</li>\n<li>preventDefault</li>\n</ul>\n<p>另外，为了方便同时停止传播和阻止默认行为，YUI还提供了<code>halt</code>方法。</p>\n<span id=\"more\"></span>\n\n<p>我们来简单分析下<code>Y.DOMEventFacade</code>的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为简化代码，省略了专门针对未实现DOM2 Events规范浏览器中的事件对象兼容性处理（代码在event-base-ie模块）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DOMEventFacade = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, currentTarget, wrapper</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._event = ev;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._currentTarget = currentTarget;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapper = wrapper || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确定目标节点</span></span><br><span class=\"line\">DOMEventFacade.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是TEXT_NODE，则取其父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp;&amp; <span class=\"number\">3</span> === n.nodeType) n = n.parentNode;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Y.one(n);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.extend(DOMEventFacade, <span class=\"built_in\">Object</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化。主要处理事件对象的浏览器兼容问题</span></span><br><span class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event,</span><br><span class=\"line\">            resolve = DOMEventFacade.resolve;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此处省略对key和dimension的兼容性处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.type = e.type;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = resolve(e.target);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.currentTarget = resolve(<span class=\"built_in\">this</span>._currentTarget);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.relatedTarget = resolve(e.relatedTarget);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 停止传播</span></span><br><span class=\"line\">    <span class=\"attr\">stopPropagation</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._event.stopPropagation();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 立即停止传播，不处理同一节点的后续回调</span></span><br><span class=\"line\">    <span class=\"attr\">stopImmediatePropagation</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.stopImmediatePropagation) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 原生事件对象支持立即停止传播</span></span><br><span class=\"line\">            e.stopImmediatePropagation();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅停止传播，在原生层面会继续同层传播</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopPropagation();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 阻止默认事件</span></span><br><span class=\"line\">    <span class=\"attr\">preventDefault</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">returnValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        e.returnValue = returnValue || <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.prevented = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prevented = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 中止事件，包括停止传播和阻止默认事件</span></span><br><span class=\"line\">    <span class=\"attr\">halt</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">immediate</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopImmediatePropagation();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopPropagation();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.preventDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Y.DOMEventFacade = DOMEventFacade;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-Event\"><a href=\"#Y-Event\" class=\"headerlink\" title=\"Y.Event\"></a>Y.Event</h2><p><code>Y.Event</code>的主要作用是提供添加、注销DOM事件监听的接口。和我们通常的理解不一样的是，它并不是一个类，而是一个简单的对象。</p>\n<p>YUI对DOM事件监听的处理思路大体是：根据节点、事件类型，创建一个<code>Y.CustomEvent</code>对象cewrapper。然后通过原生方法注册事件监听，回调执行<code>cewrapper.fire</code>方法。所有通过YUI添加的事件监听，都注册cewrapper上，从而实现对DOM事件的包装。</p>\n<p>我们先来看下如何使用<code>Y.Event</code>添加事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked again&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-one</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-one clicked&#x27;, &#x27;#btn-one clicked again&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked&#x27;</span>);</span><br><span class=\"line\">        e.stopPropagation();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked again&#x27;</span>);</span><br><span class=\"line\">        e.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked the third time&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-two</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-two clicked&#x27;, &#x27;#btn-two clicked again&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以使用<code>Y.Event</code>注销事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> countThree = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handle = Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-three clicked&#x27;</span>, ++countThree);</span><br><span class=\"line\">        handle.detach();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-three&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-three many times</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-three clicked 1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> countFour = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-four clicked&#x27;</span>, ++countFour);</span><br><span class=\"line\">        Y.Event.detach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&#x27;#btn-four&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-four&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-four many times</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-four clicked 1&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js#L397\">源码</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type, fn, capture</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (el &amp;&amp; el.addEventListener) &#123;</span><br><span class=\"line\">            el.addEventListener(type, fn, capture);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el &amp;&amp; el.attachEvent) &#123;</span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type, fn, capture</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (el &amp;&amp; el.removeEventListener) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                el.removeEventListener(type, fn, capture);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ex) &#123;&#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el &amp;&amp; el.detachEvent) &#123;</span><br><span class=\"line\">            el.detachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 判断o是否为HTMLCollection或HTMLElement数组</span></span><br><span class=\"line\">    shouldIterate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (o &amp;&amp; <span class=\"keyword\">typeof</span> o !== <span class=\"string\">&quot;string&quot;</span> &amp;&amp; Y.Lang.isNumber(o.length) &amp;&amp; !o.tagName &amp;&amp; !Y.DOM.isWindow(o));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Env.evt.dom_wrappers = &#123;&#125;;</span><br><span class=\"line\">Y.Env.evt.dom_map = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Event = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _wrappers = Y.Env.evt.dom_wrappers,</span><br><span class=\"line\">        _el_events = Y.Env.evt.dom_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件监听</span></span><br><span class=\"line\">        <span class=\"attr\">attach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, el, context</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Event._attach(Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建自定义事件对象，在原生事件触发时执行该对象的fire方法，</span></span><br><span class=\"line\">        <span class=\"comment\">// 从而处理它上面的所有回调</span></span><br><span class=\"line\">        <span class=\"attr\">_createWrapper</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> cewrapper,</span><br><span class=\"line\">                ek  = Y.stamp(el),</span><br><span class=\"line\">                key = <span class=\"string\">&#x27;event:&#x27;</span> + ek + type;</span><br><span class=\"line\"></span><br><span class=\"line\">            cewrapper = _wrappers[key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cewrapper) &#123;</span><br><span class=\"line\">                cewrapper = Y.publish(key, &#123;</span><br><span class=\"line\">                    <span class=\"attr\">silent</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    <span class=\"attr\">bubbles</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                    <span class=\"attr\">contextFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> cewrapper.nodeRef;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                cewrapper.overrides = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                cewrapper.el = el;</span><br><span class=\"line\">                cewrapper.key = key;</span><br><span class=\"line\">                cewrapper.domkey = ek;</span><br><span class=\"line\">                cewrapper.type = type;</span><br><span class=\"line\">                <span class=\"comment\">// 作为原生DOM事件回调</span></span><br><span class=\"line\">                cewrapper.fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 触发事件，回调方法可以直接调用作为第一个参数的</span></span><br><span class=\"line\">                    <span class=\"comment\">// DOM事件包装对象</span></span><br><span class=\"line\">                    cewrapper.fire(Event.getEvent(e, el));</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 重写_delete方法，执行_clean来注销原生DOM节点事件监听</span></span><br><span class=\"line\">                cewrapper._delete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> ret = Y.CustomEvent.prototype._delete.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.hasSubs()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 全部回调都被注销，则注销DOM事件监听</span></span><br><span class=\"line\">                        Event._clean(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                _wrappers[key] = cewrapper;</span><br><span class=\"line\">                _el_events[ek] = _el_events[ek] || &#123;&#125;;</span><br><span class=\"line\">                _el_events[ek][key] = cewrapper;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 通过原生方法注册事件监听，这是关键的入口</span></span><br><span class=\"line\">                add(el, type, cewrapper.fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> cewrapper;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加事件监听的内部实现</span></span><br><span class=\"line\">        <span class=\"attr\">_attach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> handles, oEl, cewrapper, context,</span><br><span class=\"line\">                ret,</span><br><span class=\"line\">                type = args[<span class=\"number\">0</span>],</span><br><span class=\"line\">                fn = args[<span class=\"number\">1</span>],</span><br><span class=\"line\">                el = args[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!fn || !fn.call) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       l) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Y.Node &amp;&amp; Y.instanceOf(el,      lis = Event.getListeners(oEl, type),</span><br><span class=\"line\">                i, lYUI().use(<span class=\"string\">&#x27;node-base&#x27;</span>, <span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)  <span class=\"title\">recursively</span>&#x27;)</span>;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-six&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-six</span></span><br><span class=\"line\">    <span class=\"comment\">// and then, click any elements in #wrapper</span></span><br><span class=\"line\">    <span class=\"comment\">// output nothing</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过Y和Node监听事件\"><a href=\"#通过Y和Node监听事件\" class=\"headerlink\" title=\"通过Y和Node监听事件\"></a>通过Y和Node监听事件</h2><p>YUI3借鉴了jQuery对HTMLElement/HTMLCollection的封装方式，方便进行链式调用，这就是<code>Y.Node</code>。</p>\n<p>事件监听是不是可以不用繁琐的使用<code>Y.Event</code>，在<code>Y.Node</code>对象上直接调用呢？当然可以。主要有四个方法：</p>\n<ul>\n<li>NodeInstance.on</li>\n<li>NodeInstance.once</li>\n<li>NodeInstance.after</li>\n<li>NodeInstance.onceAfter</li>\n</ul>\n<p>实际上，以上四个方法是通过内部调用Y的对应方法，例如<code>Node.prototype.on</code>内部调用了<code>Y.on</code>，而Y上的对应方法是由于Y本身是一个<code>Y.EventTarget</code>对象才获得的。最终，在<code>Y.EventTarget.prototype.on</code>中调用了<code>Y.Event</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wrapper clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等价的Y.on写法</span></span><br><span class=\"line\">    Y.on(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等价的Node.on写法</span></span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;#btn-one&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>所有示例代码均在<a href=\"https://github.com/springuper/yuianalyser/tree/master/event\">GitHub</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/event/\">YUILibrary-UserGuides-Event</a></li>\n<li><a href=\"https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js\">YUILibrary-Event</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/mouse.png\" alt=\"mouse event\"></p>\n<p>在介绍了由<code>Y.Do</code>、<code>Y.CustomEvent</code>、<code>Y.EventTarget</code>构建的自定义事件体系后，本篇文章将为大家介绍建立在这一体系之上，YUI对DOM事件的封装——<code>Y.Event</code>。</p>\n<h2 id=\"Y-DOMEventFacade\"><a href=\"#Y-DOMEventFacade\" class=\"headerlink\" title=\"Y.DOMEventFacade\"></a>Y.DOMEventFacade</h2><p>众所周知，浏览器之间存在大量的不兼容问题，在事件方面尤其如此。<code>Y.DOMEventFacade</code>主要用来处理DOM事件对象的浏览器兼容问题，提供跨浏览器的简洁接口。事实上，我们常在<code>Y.one(&#39;.selector&#39;).on(&#39;click&#39;, function (e) &#123;&#125;)</code>中使用的<code>e</code>就是<code>Y.DOMEventFacade</code>的实例。</p>\n<p>具体来说，兼容处理的属性主要有：</p>\n<ul>\n<li>target，专门处理了target为文本节点的情况，统一为元素节点，方便操作</li>\n<li>relativeTarget，关联目标节点，在mouseover/mouseout等事件中设置</li>\n<li>keyCode/charCode等输入信息</li>\n<li>pageX/clientX等位置信息</li>\n</ul>\n<p>兼容处理的方法主要有：</p>\n<ul>\n<li>stopPropagation/stopImmediatePropagation，不支持停止立即传播时，仅能在YUI层面模拟，不会阻止通过原生方法添加的同层回调，即，在YUI监听过el的click事件后，又通过<code>el.addEventListener(&#39;click&#39;, nativeCallback)</code>监听，如果在YUI的回调中调用<code>e.stopImmediatePropagation</code>的话，<code>nativeCallback</code>仍然会执行</li>\n<li>preventDefault</li>\n</ul>\n<p>另外，为了方便同时停止传播和阻止默认行为，YUI还提供了<code>halt</code>方法。</p>","more":"<p>我们来简单分析下<code>Y.DOMEventFacade</code>的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为简化代码，省略了专门针对未实现DOM2 Events规范浏览器中的事件对象兼容性处理（代码在event-base-ie模块）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DOMEventFacade = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, currentTarget, wrapper</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._event = ev;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._currentTarget = currentTarget;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapper = wrapper || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确定目标节点</span></span><br><span class=\"line\">DOMEventFacade.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是TEXT_NODE，则取其父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp;&amp; <span class=\"number\">3</span> === n.nodeType) n = n.parentNode;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Y.one(n);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.extend(DOMEventFacade, <span class=\"built_in\">Object</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化。主要处理事件对象的浏览器兼容问题</span></span><br><span class=\"line\">    <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event,</span><br><span class=\"line\">            resolve = DOMEventFacade.resolve;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此处省略对key和dimension的兼容性处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.type = e.type;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = resolve(e.target);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.currentTarget = resolve(<span class=\"built_in\">this</span>._currentTarget);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.relatedTarget = resolve(e.relatedTarget);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 停止传播</span></span><br><span class=\"line\">    <span class=\"attr\">stopPropagation</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._event.stopPropagation();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 立即停止传播，不处理同一节点的后续回调</span></span><br><span class=\"line\">    <span class=\"attr\">stopImmediatePropagation</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.stopImmediatePropagation) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 原生事件对象支持立即停止传播</span></span><br><span class=\"line\">            e.stopImmediatePropagation();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 仅停止传播，在原生层面会继续同层传播</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopPropagation();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stopped = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 阻止默认事件</span></span><br><span class=\"line\">    <span class=\"attr\">preventDefault</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">returnValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"built_in\">this</span>._event;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        e.returnValue = returnValue || <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>._wrapper.prevented = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prevented = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 中止事件，包括停止传播和阻止默认事件</span></span><br><span class=\"line\">    <span class=\"attr\">halt</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">immediate</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopImmediatePropagation();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stopPropagation();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.preventDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Y.DOMEventFacade = DOMEventFacade;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-Event\"><a href=\"#Y-Event\" class=\"headerlink\" title=\"Y.Event\"></a>Y.Event</h2><p><code>Y.Event</code>的主要作用是提供添加、注销DOM事件监听的接口。和我们通常的理解不一样的是，它并不是一个类，而是一个简单的对象。</p>\n<p>YUI对DOM事件监听的处理思路大体是：根据节点、事件类型，创建一个<code>Y.CustomEvent</code>对象cewrapper。然后通过原生方法注册事件监听，回调执行<code>cewrapper.fire</code>方法。所有通过YUI添加的事件监听，都注册cewrapper上，从而实现对DOM事件的包装。</p>\n<p>我们先来看下如何使用<code>Y.Event</code>添加事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked again&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-one</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-one clicked&#x27;, &#x27;#btn-one clicked again&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked&#x27;</span>);</span><br><span class=\"line\">        e.stopPropagation();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked again&#x27;</span>);</span><br><span class=\"line\">        e.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-one clicked the third time&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-two&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-two</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-two clicked&#x27;, &#x27;#btn-two clicked again&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以使用<code>Y.Event</code>注销事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> countThree = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handle = Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-three clicked&#x27;</span>, ++countThree);</span><br><span class=\"line\">        handle.detach();</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-three&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-three many times</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-three clicked 1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> countFour = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;#btn-four clicked&#x27;</span>, ++countFour);</span><br><span class=\"line\">        Y.Event.detach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&#x27;#btn-four&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-four&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-four many times</span></span><br><span class=\"line\">    <span class=\"comment\">// output &#x27;#btn-four clicked 1&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h3><p>接下来，让我们看看YUI的内部实现吧。</p>\n<p>注：为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js#L397\">源码</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type, fn, capture</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (el &amp;&amp; el.addEventListener) &#123;</span><br><span class=\"line\">            el.addEventListener(type, fn, capture);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el &amp;&amp; el.attachEvent) &#123;</span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type, fn, capture</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (el &amp;&amp; el.removeEventListener) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                el.removeEventListener(type, fn, capture);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ex) &#123;&#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el &amp;&amp; el.detachEvent) &#123;</span><br><span class=\"line\">            el.detachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 判断o是否为HTMLCollection或HTMLElement数组</span></span><br><span class=\"line\">    shouldIterate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (o &amp;&amp; <span class=\"keyword\">typeof</span> o !== <span class=\"string\">&quot;string&quot;</span> &amp;&amp; Y.Lang.isNumber(o.length) &amp;&amp; !o.tagName &amp;&amp; !Y.DOM.isWindow(o));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Env.evt.dom_wrappers = &#123;&#125;;</span><br><span class=\"line\">Y.Env.evt.dom_map = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Event = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _wrappers = Y.Env.evt.dom_wrappers,</span><br><span class=\"line\">        _el_events = Y.Env.evt.dom_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件监听</span></span><br><span class=\"line\">        <span class=\"attr\">attach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn, el, context</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Event._attach(Y.Array(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建自定义事件对象，在原生事件触发时执行该对象的fire方法，</span></span><br><span class=\"line\">        <span class=\"comment\">// 从而处理它上面的所有回调</span></span><br><span class=\"line\">        <span class=\"attr\">_createWrapper</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, type</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> cewrapper,</span><br><span class=\"line\">                ek  = Y.stamp(el),</span><br><span class=\"line\">                key = <span class=\"string\">&#x27;event:&#x27;</span> + ek + type;</span><br><span class=\"line\"></span><br><span class=\"line\">            cewrapper = _wrappers[key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cewrapper) &#123;</span><br><span class=\"line\">                cewrapper = Y.publish(key, &#123;</span><br><span class=\"line\">                    <span class=\"attr\">silent</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    <span class=\"attr\">bubbles</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                    <span class=\"attr\">contextFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> cewrapper.nodeRef;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                cewrapper.overrides = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                cewrapper.el = el;</span><br><span class=\"line\">                cewrapper.key = key;</span><br><span class=\"line\">                cewrapper.domkey = ek;</span><br><span class=\"line\">                cewrapper.type = type;</span><br><span class=\"line\">                <span class=\"comment\">// 作为原生DOM事件回调</span></span><br><span class=\"line\">                cewrapper.fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 触发事件，回调方法可以直接调用作为第一个参数的</span></span><br><span class=\"line\">                    <span class=\"comment\">// DOM事件包装对象</span></span><br><span class=\"line\">                    cewrapper.fire(Event.getEvent(e, el));</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 重写_delete方法，执行_clean来注销原生DOM节点事件监听</span></span><br><span class=\"line\">                cewrapper._delete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> ret = Y.CustomEvent.prototype._delete.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.hasSubs()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 全部回调都被注销，则注销DOM事件监听</span></span><br><span class=\"line\">                        Event._clean(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">                _wrappers[key] = cewrapper;</span><br><span class=\"line\">                _el_events[ek] = _el_events[ek] || &#123;&#125;;</span><br><span class=\"line\">                _el_events[ek][key] = cewrapper;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 通过原生方法注册事件监听，这是关键的入口</span></span><br><span class=\"line\">                add(el, type, cewrapper.fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> cewrapper;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加事件监听的内部实现</span></span><br><span class=\"line\">        <span class=\"attr\">_attach</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> handles, oEl, cewrapper, context,</span><br><span class=\"line\">                ret,</span><br><span class=\"line\">                type = args[<span class=\"number\">0</span>],</span><br><span class=\"line\">                fn = args[<span class=\"number\">1</span>],</span><br><span class=\"line\">                el = args[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!fn || !fn.call) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       l) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Y.Node &amp;&amp; Y.instanceOf(el,      lis = Event.getListeners(oEl, type),</span><br><span class=\"line\">                i, lYUI().use(<span class=\"string\">&#x27;node-base&#x27;</span>, <span class=\"string\">&#x27;selector&#x27;</span>, <span class=\"string\">&#x27;event-base&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)  <span class=\"title\">recursively</span>&#x27;)</span>;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-six&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// click #btn-six</span></span><br><span class=\"line\">    <span class=\"comment\">// and then, click any elements in #wrapper</span></span><br><span class=\"line\">    <span class=\"comment\">// output nothing</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过Y和Node监听事件\"><a href=\"#通过Y和Node监听事件\" class=\"headerlink\" title=\"通过Y和Node监听事件\"></a>通过Y和Node监听事件</h2><p>YUI3借鉴了jQuery对HTMLElement/HTMLCollection的封装方式，方便进行链式调用，这就是<code>Y.Node</code>。</p>\n<p>事件监听是不是可以不用繁琐的使用<code>Y.Event</code>，在<code>Y.Node</code>对象上直接调用呢？当然可以。主要有四个方法：</p>\n<ul>\n<li>NodeInstance.on</li>\n<li>NodeInstance.once</li>\n<li>NodeInstance.after</li>\n<li>NodeInstance.onceAfter</li>\n</ul>\n<p>实际上，以上四个方法是通过内部调用Y的对应方法，例如<code>Node.prototype.on</code>内部调用了<code>Y.on</code>，而Y上的对应方法是由于Y本身是一个<code>Y.EventTarget</code>对象才获得的。最终，在<code>Y.EventTarget.prototype.on</code>中调用了<code>Y.Event</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;node&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.Event.attach(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wrapper clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等价的Y.on写法</span></span><br><span class=\"line\">    Y.on(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&#x27;#btn-one&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等价的Node.on写法</span></span><br><span class=\"line\">    Y.one(<span class=\"string\">&#x27;#btn-one&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;btn-one clicked&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>所有示例代码均在<a href=\"https://github.com/springuper/yuianalyser/tree/master/event\">GitHub</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/event/\">YUILibrary-UserGuides-Event</a></li>\n<li><a href=\"https://github.com/yui/yui3/blob/v3.8.0/build/event-base/event-base-debug.js\">YUILibrary-Event</a></li>\n</ul>"},{"layout":"post","title":"Y.extend与Y.augment","date":"2012-02-11T13:24:00.000Z","comments":1,"status":"publish","_content":"\n很长一段时间内，我都没有搞懂YUI3 OOP模块中的`Y.extend`方法与`Y.augment`之间的区别，尽管它们的名称如此显著。现在有些时间，我相信分析源码是最好的解决方法。为了减少不必要的干扰，我简化了这两个方法，使它们仅处理类构造器。\n\n## Y.extend\n\n`Y.extend`方法应用的场景很简单，就是继承。我们知道，JavaScript有多种继承方式，例如原型继承、构造器继承、组合继承、寄生继承等等。YUI采取的为寄生组合继承（Parasitic combination inheritance）。\n\n`Y.extend`的简化代码如下：\n\n```javascript\nY.extend = function (r, s) {\n    var sp = s.prototype, rp = Y.Object(sp);\n    r.prototype = rp;\n\n    rp.constructor = r;\n    r.superclass = sp;\n\n    return r;\n};\n\nY.Object = function (o) {\n    var F = function () {};\n    F.prototype = o;\n    return new F();\n}\n```\n\n首先获取一个`__proto__`指向父类原型的空对象`rp`，然后将其作为子类原型，这样子类实例就可以沿原型链父类原型方法。然后设置子类的`superclass`属性为父类原型，使得子类构造器可以访问到父类。\n\n<!-- more -->\n\n示例：\n```javascript\nfunction Programmer(name) {\n    this.name = name;\n}\nProgrammer.prototype.getName = function () {\n    return this.name;\n};\n\nfunction FrontEndProgrammer(name, gender) {\n    // 调用父类构造器\n    FrontEndProgrammer.superclass.constructor.call(this, name);\n        this.gender = gender;\n}\nFrontEndProgrammer.prototype.getGender = function () {\n    return this.gender;\n};\n\n// 建立类继承关系\nY.extend(FrontEndProgrammer, Programmer);\n```\n\n## Y.augment\n\nOOP中，继承是一种主要方式，但还有另一种方式同样重要，即组合(Composition)。组合不同于继承的是，不会在类之间建立关系，只将提供类（类似父类）的属性、原型属性和方法添加在接受类（类似子类）中。`Y.augment`就是YUI中一种用来组合类的方法。\n\nY.augment的简化代码如下：\n```javascript\nY.augment = function (receiver, supplier, args) {\n    var rProto    = receiver.prototype,\n        sProto    = supplier.prototype,\n        copy,\n        property;\n\n    args = args ? Y.Array(args) : [];\n\n    copy = function (value, key) {\n        if (!(key in rProto)) {\n            if (Object.prototype.toString.call(value) === '[object Function]') {\n                rProto[key] = function () {\n                    // 将方法赋给实例\n                    this[key] = value;\n                    // 执行提供类构造器\n                    supplier.apply(this, args);\n                    // 执行提供类方法\n                    return value.apply(this, arguments);                \n                };\n            } else {\n                rProto[key] = value;\n            }\n        }\n    };\n\n    for (property in sProto) {\n        copy.call(null, sProto[property], property);\n    }\n\n    return receiver;\n};\n```\n\n逻辑比较简单，将提供类原型属性处理后拷贝给接受类原型。如果拷贝的是一个方法，则使用一个代理方法，主要作用是执行一次提供类构造器，使接受类对象获得提供类构造器中添加的属性。\n\n从代码中可以发现，`Y.augment`的第三个参数`args`是传递给提供类构造器的，问题在于`args`只能在执行`Y.augment`时指定，也就是说不能在创建接受类实例时指定。这是`Y.augment`与`Y.extend`非常重要的一个区别。\n\n另外一个问题是，接受类实例在执行不同提供类原型方法时，提供类构造器会被多次执行，在提供类构造器中逻辑比较复杂时会引起显而易见的效率问题。这个问题是由于我简化代码的缘故，[YUI源码](http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html#l31)中采用了一种方法隔离技术，能够在第一次调用提供类方法时才将所有提供类方法赋给接收类实例，并保证只执行一次提供类构造器。\n\n示例：\n```javascript\nfunction Code(language) {\n    this.language = language;\n}\nCode.prototype.getLanguage = function () {\n    return this.language;\n};\n\nfunction FrontEndProgrammer(name, gender) {\n    this.name = name;\n    this.gender = gender;\n}\nFrontEndProgrammer.prototype.getName = function () {\n    return this.name;\n};\nFrontEndProgrammer.prototype.getGender = function () {\n    return this.gender;\n};\n\n// 组合类\nY.augment(FrontEndProgrammer, Code, 'JavaScript');\n```\n\n## Y.extend与Y.augment区别\n\n`Y.extend`和`Y.augment`很好的体现了OOP两种主要方式：继承和组合。设计模式中提倡使用组合方式：Favor 'object composition' over 'class inheritance' （[Gang of Four](http://en.wikipedia.org/wiki/Design_Patterns) 1995:20）。\n\n总结一下，`Y.extend和`Y.augment`有如下区别：\n- `Y.extend`改变原型链，可以通过`instanceof`操作符判定子类实例与父类关系\n- `Y.extend`可以在创建子类实例时指定传递给父类的参数，`Y.augment`只能在组合类时设定\n- `Y.augment`会将提供类原型方法赋给接受类实例\n\n根据各自特点，可以发现，`Y.extend`更适合从属关系非常强的两个类，例如男人和人，男人的主体属性是人，附加一些胡须、喉结、力气之类的特征；`Y.augment`更适合提供类是接受类一个扩展的情况，例如程序员和工具书，工具书只是程序员用来参考的工具，而不是主要属性。\n\n以下是YUI3中的一些实际使用例子：\n```javascript\n// Y.Base作为YUI组件框架的核心，为继承它的子类提供了属性管理、事件、生命周期等方法。\nY.extend(Y.Anim, Y.Base);\nY.extend(ScrollView, Y.Widget);\nY.extend(ACListPlugin, Y.AutoCompleteList);\nY.extend(CacheOffline, Y.Cache);\nY.extend(Calendar, Y.CalendarBase);\n\n// EventTarget定义了一整套自定义事件、AOP的机制，通过Y.augment可以方便的赋给接受类这些方法。\nY.augment(Y.Node, Y.EventTarget);\nY.augment(Y.DataSource.Local, Pollable);\nY.augment(Lines, Y.Attribute);\n```\n\n## 参考\n- [YUI OOP API](http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html)\n- [Inheritance Patterns in YUI 3](http://www.yuiblog.com/blog/2010/01/06/inheritance-patterns-in-yui-3/)\n- [More code reuse patterns in YUI3](http://www.yuiblog.com/blog/2010/01/07/more-code-reuse-patterns-in-yui3/)\n- [Design Patterns](http://en.wikipedia.org/wiki/Design_Patterns)\n","source":"_posts/extend-and-augment.md","raw":"---\nlayout: post\ntitle: \"Y.extend与Y.augment\"\ndate: 2012-02-11 21:24\ncomments: true\nstatus: publish\ntags: [YUI, OOP, JavaScript]\n---\n\n很长一段时间内，我都没有搞懂YUI3 OOP模块中的`Y.extend`方法与`Y.augment`之间的区别，尽管它们的名称如此显著。现在有些时间，我相信分析源码是最好的解决方法。为了减少不必要的干扰，我简化了这两个方法，使它们仅处理类构造器。\n\n## Y.extend\n\n`Y.extend`方法应用的场景很简单，就是继承。我们知道，JavaScript有多种继承方式，例如原型继承、构造器继承、组合继承、寄生继承等等。YUI采取的为寄生组合继承（Parasitic combination inheritance）。\n\n`Y.extend`的简化代码如下：\n\n```javascript\nY.extend = function (r, s) {\n    var sp = s.prototype, rp = Y.Object(sp);\n    r.prototype = rp;\n\n    rp.constructor = r;\n    r.superclass = sp;\n\n    return r;\n};\n\nY.Object = function (o) {\n    var F = function () {};\n    F.prototype = o;\n    return new F();\n}\n```\n\n首先获取一个`__proto__`指向父类原型的空对象`rp`，然后将其作为子类原型，这样子类实例就可以沿原型链父类原型方法。然后设置子类的`superclass`属性为父类原型，使得子类构造器可以访问到父类。\n\n<!-- more -->\n\n示例：\n```javascript\nfunction Programmer(name) {\n    this.name = name;\n}\nProgrammer.prototype.getName = function () {\n    return this.name;\n};\n\nfunction FrontEndProgrammer(name, gender) {\n    // 调用父类构造器\n    FrontEndProgrammer.superclass.constructor.call(this, name);\n        this.gender = gender;\n}\nFrontEndProgrammer.prototype.getGender = function () {\n    return this.gender;\n};\n\n// 建立类继承关系\nY.extend(FrontEndProgrammer, Programmer);\n```\n\n## Y.augment\n\nOOP中，继承是一种主要方式，但还有另一种方式同样重要，即组合(Composition)。组合不同于继承的是，不会在类之间建立关系，只将提供类（类似父类）的属性、原型属性和方法添加在接受类（类似子类）中。`Y.augment`就是YUI中一种用来组合类的方法。\n\nY.augment的简化代码如下：\n```javascript\nY.augment = function (receiver, supplier, args) {\n    var rProto    = receiver.prototype,\n        sProto    = supplier.prototype,\n        copy,\n        property;\n\n    args = args ? Y.Array(args) : [];\n\n    copy = function (value, key) {\n        if (!(key in rProto)) {\n            if (Object.prototype.toString.call(value) === '[object Function]') {\n                rProto[key] = function () {\n                    // 将方法赋给实例\n                    this[key] = value;\n                    // 执行提供类构造器\n                    supplier.apply(this, args);\n                    // 执行提供类方法\n                    return value.apply(this, arguments);                \n                };\n            } else {\n                rProto[key] = value;\n            }\n        }\n    };\n\n    for (property in sProto) {\n        copy.call(null, sProto[property], property);\n    }\n\n    return receiver;\n};\n```\n\n逻辑比较简单，将提供类原型属性处理后拷贝给接受类原型。如果拷贝的是一个方法，则使用一个代理方法，主要作用是执行一次提供类构造器，使接受类对象获得提供类构造器中添加的属性。\n\n从代码中可以发现，`Y.augment`的第三个参数`args`是传递给提供类构造器的，问题在于`args`只能在执行`Y.augment`时指定，也就是说不能在创建接受类实例时指定。这是`Y.augment`与`Y.extend`非常重要的一个区别。\n\n另外一个问题是，接受类实例在执行不同提供类原型方法时，提供类构造器会被多次执行，在提供类构造器中逻辑比较复杂时会引起显而易见的效率问题。这个问题是由于我简化代码的缘故，[YUI源码](http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html#l31)中采用了一种方法隔离技术，能够在第一次调用提供类方法时才将所有提供类方法赋给接收类实例，并保证只执行一次提供类构造器。\n\n示例：\n```javascript\nfunction Code(language) {\n    this.language = language;\n}\nCode.prototype.getLanguage = function () {\n    return this.language;\n};\n\nfunction FrontEndProgrammer(name, gender) {\n    this.name = name;\n    this.gender = gender;\n}\nFrontEndProgrammer.prototype.getName = function () {\n    return this.name;\n};\nFrontEndProgrammer.prototype.getGender = function () {\n    return this.gender;\n};\n\n// 组合类\nY.augment(FrontEndProgrammer, Code, 'JavaScript');\n```\n\n## Y.extend与Y.augment区别\n\n`Y.extend`和`Y.augment`很好的体现了OOP两种主要方式：继承和组合。设计模式中提倡使用组合方式：Favor 'object composition' over 'class inheritance' （[Gang of Four](http://en.wikipedia.org/wiki/Design_Patterns) 1995:20）。\n\n总结一下，`Y.extend和`Y.augment`有如下区别：\n- `Y.extend`改变原型链，可以通过`instanceof`操作符判定子类实例与父类关系\n- `Y.extend`可以在创建子类实例时指定传递给父类的参数，`Y.augment`只能在组合类时设定\n- `Y.augment`会将提供类原型方法赋给接受类实例\n\n根据各自特点，可以发现，`Y.extend`更适合从属关系非常强的两个类，例如男人和人，男人的主体属性是人，附加一些胡须、喉结、力气之类的特征；`Y.augment`更适合提供类是接受类一个扩展的情况，例如程序员和工具书，工具书只是程序员用来参考的工具，而不是主要属性。\n\n以下是YUI3中的一些实际使用例子：\n```javascript\n// Y.Base作为YUI组件框架的核心，为继承它的子类提供了属性管理、事件、生命周期等方法。\nY.extend(Y.Anim, Y.Base);\nY.extend(ScrollView, Y.Widget);\nY.extend(ACListPlugin, Y.AutoCompleteList);\nY.extend(CacheOffline, Y.Cache);\nY.extend(Calendar, Y.CalendarBase);\n\n// EventTarget定义了一整套自定义事件、AOP的机制，通过Y.augment可以方便的赋给接受类这些方法。\nY.augment(Y.Node, Y.EventTarget);\nY.augment(Y.DataSource.Local, Pollable);\nY.augment(Lines, Y.Attribute);\n```\n\n## 参考\n- [YUI OOP API](http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html)\n- [Inheritance Patterns in YUI 3](http://www.yuiblog.com/blog/2010/01/06/inheritance-patterns-in-yui-3/)\n- [More code reuse patterns in YUI3](http://www.yuiblog.com/blog/2010/01/07/more-code-reuse-patterns-in-yui3/)\n- [Design Patterns](http://en.wikipedia.org/wiki/Design_Patterns)\n","slug":"extend-and-augment","published":1,"updated":"2021-10-04T12:57:16.038Z","photos":[],"link":"","_id":"cl1klgupi000h8e853bu5a8nf","content":"<p>很长一段时间内，我都没有搞懂YUI3 OOP模块中的<code>Y.extend</code>方法与<code>Y.augment</code>之间的区别，尽管它们的名称如此显著。现在有些时间，我相信分析源码是最好的解决方法。为了减少不必要的干扰，我简化了这两个方法，使它们仅处理类构造器。</p>\n<h2 id=\"Y-extend\"><a href=\"#Y-extend\" class=\"headerlink\" title=\"Y.extend\"></a>Y.extend</h2><p><code>Y.extend</code>方法应用的场景很简单，就是继承。我们知道，JavaScript有多种继承方式，例如原型继承、构造器继承、组合继承、寄生继承等等。YUI采取的为寄生组合继承（Parasitic combination inheritance）。</p>\n<p><code>Y.extend</code>的简化代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.extend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">r, s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sp = s.prototype, rp = Y.Object(sp);</span><br><span class=\"line\">    r.prototype = rp;</span><br><span class=\"line\"></span><br><span class=\"line\">    rp.constructor = r;</span><br><span class=\"line\">    r.superclass = sp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Object = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先获取一个<code>__proto__</code>指向父类原型的空对象<code>rp</code>，然后将其作为子类原型，这样子类实例就可以沿原型链父类原型方法。然后设置子类的<code>superclass</code>属性为父类原型，使得子类构造器可以访问到父类。</p>\n<span id=\"more\"></span>\n\n<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Programmer.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FrontEndProgrammer</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用父类构造器</span></span><br><span class=\"line\">    FrontEndProgrammer.superclass.constructor.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getGender = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.gender;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立类继承关系</span></span><br><span class=\"line\">Y.extend(FrontEndProgrammer, Programmer);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-augment\"><a href=\"#Y-augment\" class=\"headerlink\" title=\"Y.augment\"></a>Y.augment</h2><p>OOP中，继承是一种主要方式，但还有另一种方式同样重要，即组合(Composition)。组合不同于继承的是，不会在类之间建立关系，只将提供类（类似父类）的属性、原型属性和方法添加在接受类（类似子类）中。<code>Y.augment</code>就是YUI中一种用来组合类的方法。</p>\n<p>Y.augment的简化代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.augment = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">receiver, supplier, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rProto    = receiver.prototype,</span><br><span class=\"line\">        sProto    = supplier.prototype,</span><br><span class=\"line\">        copy,</span><br><span class=\"line\">        property;</span><br><span class=\"line\"></span><br><span class=\"line\">    args = args ? Y.Array(args) : [];</span><br><span class=\"line\"></span><br><span class=\"line\">    copy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(key <span class=\"keyword\">in</span> rProto)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class=\"line\">                rProto[key] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将方法赋给实例</span></span><br><span class=\"line\">                    <span class=\"built_in\">this</span>[key] = value;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行提供类构造器</span></span><br><span class=\"line\">                    supplier.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">                    <span class=\"comment\">// 执行提供类方法</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> value.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);                </span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rProto[key] = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (property <span class=\"keyword\">in</span> sProto) &#123;</span><br><span class=\"line\">        copy.call(<span class=\"literal\">null</span>, sProto[property], property);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> receiver;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑比较简单，将提供类原型属性处理后拷贝给接受类原型。如果拷贝的是一个方法，则使用一个代理方法，主要作用是执行一次提供类构造器，使接受类对象获得提供类构造器中添加的属性。</p>\n<p>从代码中可以发现，<code>Y.augment</code>的第三个参数<code>args</code>是传递给提供类构造器的，问题在于<code>args</code>只能在执行<code>Y.augment</code>时指定，也就是说不能在创建接受类实例时指定。这是<code>Y.augment</code>与<code>Y.extend</code>非常重要的一个区别。</p>\n<p>另外一个问题是，接受类实例在执行不同提供类原型方法时，提供类构造器会被多次执行，在提供类构造器中逻辑比较复杂时会引起显而易见的效率问题。这个问题是由于我简化代码的缘故，<a href=\"http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html#l31\">YUI源码</a>中采用了一种方法隔离技术，能够在第一次调用提供类方法时才将所有提供类方法赋给接收类实例，并保证只执行一次提供类构造器。</p>\n<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Code</span>(<span class=\"params\">language</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.language = language;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Code.prototype.getLanguage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.language;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FrontEndProgrammer</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getGender = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.gender;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组合类</span></span><br><span class=\"line\">Y.augment(FrontEndProgrammer, Code, <span class=\"string\">&#x27;JavaScript&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-extend与Y-augment区别\"><a href=\"#Y-extend与Y-augment区别\" class=\"headerlink\" title=\"Y.extend与Y.augment区别\"></a>Y.extend与Y.augment区别</h2><p><code>Y.extend</code>和<code>Y.augment</code>很好的体现了OOP两种主要方式：继承和组合。设计模式中提倡使用组合方式：Favor ‘object composition’ over ‘class inheritance’ （<a href=\"http://en.wikipedia.org/wiki/Design_Patterns\">Gang of Four</a> 1995:20）。</p>\n<p>总结一下，<code>Y.extend和</code>Y.augment`有如下区别：</p>\n<ul>\n<li><code>Y.extend</code>改变原型链，可以通过<code>instanceof</code>操作符判定子类实例与父类关系</li>\n<li><code>Y.extend</code>可以在创建子类实例时指定传递给父类的参数，<code>Y.augment</code>只能在组合类时设定</li>\n<li><code>Y.augment</code>会将提供类原型方法赋给接受类实例</li>\n</ul>\n<p>根据各自特点，可以发现，<code>Y.extend</code>更适合从属关系非常强的两个类，例如男人和人，男人的主体属性是人，附加一些胡须、喉结、力气之类的特征；<code>Y.augment</code>更适合提供类是接受类一个扩展的情况，例如程序员和工具书，工具书只是程序员用来参考的工具，而不是主要属性。</p>\n<p>以下是YUI3中的一些实际使用例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Y.Base作为YUI组件框架的核心，为继承它的子类提供了属性管理、事件、生命周期等方法。</span></span><br><span class=\"line\">Y.extend(Y.Anim, Y.Base);</span><br><span class=\"line\">Y.extend(ScrollView, Y.Widget);</span><br><span class=\"line\">Y.extend(ACListPlugin, Y.AutoCompleteList);</span><br><span class=\"line\">Y.extend(CacheOffline, Y.Cache);</span><br><span class=\"line\">Y.extend(Calendar, Y.CalendarBase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventTarget定义了一整套自定义事件、AOP的机制，通过Y.augment可以方便的赋给接受类这些方法。</span></span><br><span class=\"line\">Y.augment(Y.Node, Y.EventTarget);</span><br><span class=\"line\">Y.augment(Y.DataSource.Local, Pollable);</span><br><span class=\"line\">Y.augment(Lines, Y.Attribute);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html\">YUI OOP API</a></li>\n<li><a href=\"http://www.yuiblog.com/blog/2010/01/06/inheritance-patterns-in-yui-3/\">Inheritance Patterns in YUI 3</a></li>\n<li><a href=\"http://www.yuiblog.com/blog/2010/01/07/more-code-reuse-patterns-in-yui3/\">More code reuse patterns in YUI3</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Design_Patterns\">Design Patterns</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>很长一段时间内，我都没有搞懂YUI3 OOP模块中的<code>Y.extend</code>方法与<code>Y.augment</code>之间的区别，尽管它们的名称如此显著。现在有些时间，我相信分析源码是最好的解决方法。为了减少不必要的干扰，我简化了这两个方法，使它们仅处理类构造器。</p>\n<h2 id=\"Y-extend\"><a href=\"#Y-extend\" class=\"headerlink\" title=\"Y.extend\"></a>Y.extend</h2><p><code>Y.extend</code>方法应用的场景很简单，就是继承。我们知道，JavaScript有多种继承方式，例如原型继承、构造器继承、组合继承、寄生继承等等。YUI采取的为寄生组合继承（Parasitic combination inheritance）。</p>\n<p><code>Y.extend</code>的简化代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.extend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">r, s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sp = s.prototype, rp = Y.Object(sp);</span><br><span class=\"line\">    r.prototype = rp;</span><br><span class=\"line\"></span><br><span class=\"line\">    rp.constructor = r;</span><br><span class=\"line\">    r.superclass = sp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Object = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先获取一个<code>__proto__</code>指向父类原型的空对象<code>rp</code>，然后将其作为子类原型，这样子类实例就可以沿原型链父类原型方法。然后设置子类的<code>superclass</code>属性为父类原型，使得子类构造器可以访问到父类。</p>","more":"<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Programmer.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FrontEndProgrammer</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用父类构造器</span></span><br><span class=\"line\">    FrontEndProgrammer.superclass.constructor.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getGender = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.gender;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立类继承关系</span></span><br><span class=\"line\">Y.extend(FrontEndProgrammer, Programmer);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-augment\"><a href=\"#Y-augment\" class=\"headerlink\" title=\"Y.augment\"></a>Y.augment</h2><p>OOP中，继承是一种主要方式，但还有另一种方式同样重要，即组合(Composition)。组合不同于继承的是，不会在类之间建立关系，只将提供类（类似父类）的属性、原型属性和方法添加在接受类（类似子类）中。<code>Y.augment</code>就是YUI中一种用来组合类的方法。</p>\n<p>Y.augment的简化代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.augment = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">receiver, supplier, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rProto    = receiver.prototype,</span><br><span class=\"line\">        sProto    = supplier.prototype,</span><br><span class=\"line\">        copy,</span><br><span class=\"line\">        property;</span><br><span class=\"line\"></span><br><span class=\"line\">    args = args ? Y.Array(args) : [];</span><br><span class=\"line\"></span><br><span class=\"line\">    copy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(key <span class=\"keyword\">in</span> rProto)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class=\"line\">                rProto[key] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将方法赋给实例</span></span><br><span class=\"line\">                    <span class=\"built_in\">this</span>[key] = value;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行提供类构造器</span></span><br><span class=\"line\">                    supplier.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">                    <span class=\"comment\">// 执行提供类方法</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> value.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);                </span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rProto[key] = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (property <span class=\"keyword\">in</span> sProto) &#123;</span><br><span class=\"line\">        copy.call(<span class=\"literal\">null</span>, sProto[property], property);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> receiver;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑比较简单，将提供类原型属性处理后拷贝给接受类原型。如果拷贝的是一个方法，则使用一个代理方法，主要作用是执行一次提供类构造器，使接受类对象获得提供类构造器中添加的属性。</p>\n<p>从代码中可以发现，<code>Y.augment</code>的第三个参数<code>args</code>是传递给提供类构造器的，问题在于<code>args</code>只能在执行<code>Y.augment</code>时指定，也就是说不能在创建接受类实例时指定。这是<code>Y.augment</code>与<code>Y.extend</code>非常重要的一个区别。</p>\n<p>另外一个问题是，接受类实例在执行不同提供类原型方法时，提供类构造器会被多次执行，在提供类构造器中逻辑比较复杂时会引起显而易见的效率问题。这个问题是由于我简化代码的缘故，<a href=\"http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html#l31\">YUI源码</a>中采用了一种方法隔离技术，能够在第一次调用提供类方法时才将所有提供类方法赋给接收类实例，并保证只执行一次提供类构造器。</p>\n<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Code</span>(<span class=\"params\">language</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.language = language;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Code.prototype.getLanguage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.language;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FrontEndProgrammer</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">FrontEndProgrammer.prototype.getGender = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.gender;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组合类</span></span><br><span class=\"line\">Y.augment(FrontEndProgrammer, Code, <span class=\"string\">&#x27;JavaScript&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-extend与Y-augment区别\"><a href=\"#Y-extend与Y-augment区别\" class=\"headerlink\" title=\"Y.extend与Y.augment区别\"></a>Y.extend与Y.augment区别</h2><p><code>Y.extend</code>和<code>Y.augment</code>很好的体现了OOP两种主要方式：继承和组合。设计模式中提倡使用组合方式：Favor ‘object composition’ over ‘class inheritance’ （<a href=\"http://en.wikipedia.org/wiki/Design_Patterns\">Gang of Four</a> 1995:20）。</p>\n<p>总结一下，<code>Y.extend和</code>Y.augment`有如下区别：</p>\n<ul>\n<li><code>Y.extend</code>改变原型链，可以通过<code>instanceof</code>操作符判定子类实例与父类关系</li>\n<li><code>Y.extend</code>可以在创建子类实例时指定传递给父类的参数，<code>Y.augment</code>只能在组合类时设定</li>\n<li><code>Y.augment</code>会将提供类原型方法赋给接受类实例</li>\n</ul>\n<p>根据各自特点，可以发现，<code>Y.extend</code>更适合从属关系非常强的两个类，例如男人和人，男人的主体属性是人，附加一些胡须、喉结、力气之类的特征；<code>Y.augment</code>更适合提供类是接受类一个扩展的情况，例如程序员和工具书，工具书只是程序员用来参考的工具，而不是主要属性。</p>\n<p>以下是YUI3中的一些实际使用例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Y.Base作为YUI组件框架的核心，为继承它的子类提供了属性管理、事件、生命周期等方法。</span></span><br><span class=\"line\">Y.extend(Y.Anim, Y.Base);</span><br><span class=\"line\">Y.extend(ScrollView, Y.Widget);</span><br><span class=\"line\">Y.extend(ACListPlugin, Y.AutoCompleteList);</span><br><span class=\"line\">Y.extend(CacheOffline, Y.Cache);</span><br><span class=\"line\">Y.extend(Calendar, Y.CalendarBase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventTarget定义了一整套自定义事件、AOP的机制，通过Y.augment可以方便的赋给接受类这些方法。</span></span><br><span class=\"line\">Y.augment(Y.Node, Y.EventTarget);</span><br><span class=\"line\">Y.augment(Y.DataSource.Local, Pollable);</span><br><span class=\"line\">Y.augment(Lines, Y.Attribute);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/files/oop_js_oop.js.html\">YUI OOP API</a></li>\n<li><a href=\"http://www.yuiblog.com/blog/2010/01/06/inheritance-patterns-in-yui-3/\">Inheritance Patterns in YUI 3</a></li>\n<li><a href=\"http://www.yuiblog.com/blog/2010/01/07/more-code-reuse-patterns-in-yui3/\">More code reuse patterns in YUI3</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Design_Patterns\">Design Patterns</a></li>\n</ul>"},{"layout":"post","title":"前端中的 Pipeline","date":"2017-10-05T13:35:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [前端中的 Pipeline](https://zhuanlan.zhihu.com/p/28561932) 查看全文。\n","source":"_posts/fe-pipeline.md","raw":"---\nlayout: post\ntitle: \"前端中的 Pipeline\"\ndate: 2017-10-05 21:35\nstatus: publish\ntags: [FrontEnd, Pipeline, Middleware, Stream, Promise]\n---\n\n请移步知乎“前端之美”专栏 [前端中的 Pipeline](https://zhuanlan.zhihu.com/p/28561932) 查看全文。\n","slug":"fe-pipeline","published":1,"updated":"2021-10-05T13:19:50.200Z","comments":1,"photos":[],"link":"","_id":"cl1klgupj000j8e855q0wfyai","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/28561932\">前端中的 Pipeline</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/28561932\">前端中的 Pipeline</a> 查看全文。</p>\n"},{"layout":"post","title":"YUI事件体系之Y.Do","date":"2012-07-14T09:34:00.000Z","comments":1,"status":"publish","_content":"\nYUI团队在种种场合不断的夸耀自己的事件体系是多么强大：\n\n- YUI 3′s Event module is one of the strengths of the library  --Eric Miraglia, [YUI Theater — Luke Smith: \"Events Evolved\"](http://www.yuiblog.com/blog/2009/10/30/smith-yuiconf2009-events/)\n- YUI 3 is not all about DOM manipulation — it also contains a robust set of class/object management tools, not to mention our powerful custom events --Tilo Mitra, [10 Things I Learned While Interning at YUI](http://net.tutsplus.com/articles/general/10-things-i-learned-while-interning-at-yui/)\n- One of the strengths of the YUI App Framework is that it's integrated tightly with the rest of YUI and benefits from YUI's fantastic event system and plugin/extension infrastructure. --Ryan Grove, [How can I decided whether to choose YUI 3's MVC or Backbone for a new project?](http://www.quora.com/How-can-I-decided-whether-to-choose-YUI-3s-MVC-or-Backbone-for-a-new-project#ld_xJGMd1_3012)\n\n事实的确如此吗？就使用YUI的开发者反馈来看，应该是不错的：\n\n- AFAIK YUI 3's event system is the most sophisticated of any JavaScript framework. Am I wrong in thinking that? --[Walter Rumsby](https://twitter.com/wrumsby/status/113568040834174976)\n- I love the event system in YUI. Pure awesomeness. --[Kevin Isom](https://twitter.com/kev_nz/statuses/180472697644515328)\n- I am constantly impressed by the degree of excellence I find in working with the YUI3 framework --Andrew Wooldridge, [Cross YUI Communication and Custom Events](http://andrewwooldridge.com/blog/2011/03/08/cross-yui-communication-and-custom-events/)\n\n作为一名YUI用户，我对其事件体系的强大深有体会。从本篇文章起，我将对YUI事件机制做一个全面分析。\n\n本次我们介绍的是比较基础的两个对象`Y.EventHandle`和`Y.Do`。千里之行积于跬步，YUI整套事件机制也是从这两个对象开始构筑的。\n\n<!-- more -->\n\n## Y.EventHandle\n`Y.EventHandle`的作用很简单：注销事件/消息监听。\n\n```javascript\nY.EventHandle = function (evt, sub) {\n    this.evt = evt; // 事件对象\n    this.sub = sub; // 监听对象\n};\nY.EventHandle.detach = function () {\n    this.evt._delete(this.sub); // 执行event对象的_delete方法，注销事件/消息监听\n    return true;\n};\n```\n\n## Y.Do\n\n`Y.Do`的作用是：向对象方法前面或者后面插入其它方法(前置、后置方法)，以达到动态修改对象行为的目的。这种方式，也称作[AOP](http://en.wikipedia.org/wiki/Aspect-oriented_programming)。\n\n## 示例\n\n让我们先来看个简单的例子：\n\n```javascript\n// 例1\nYUI().use('event-custom', function (Y) {\n    var cat = {\n        eat: function () {\n            console.log('eat a fish');\n        }\n    };\n\n    cat.eat(); // output: eat a fish\n\n    var beforeHandle = Y.Do.before(function () {\n        console.log('catch a fish');\n    }, cat, 'eat');\n    var afterHandle = Y.Do.after(function () {\n        console.log('done!');\n    }, cat, 'eat');\n    cat.eat(); // output: catch a fish, eat, done!\n\n    afterHandle.detach();\n    cat.eat(); // output: catch a fish, eat\n});\n```\n\n在不修改原对象方法的基础上，可以方便的添加前置、后置方法，并且注销这些方法也很容易。`Y.Do`非常漂亮的解决了我们动态修改对象方法的需求！很难想象，如果不用`Y.Do`代码会复杂成怎样。\n\n## 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。这是多么有趣的事，就像小时候买把手枪，想不明白为什么可以射击，就砸开一看究竟。\n\n为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-do.js.html#l16)。\n\n```javascript\n// 代码版本为YUI3.4.1，YUI3.5.0对Y.Do的实现有所改进\nvar DO_BEFORE = 0,\n    DO_AFTER = 1;\nY.Do = {\n    // 缓存处理对象\n    objs: {},\n    before: function (fn, obj, sFn) {\n        return this._inject(DO_BEFORE, fn, obj, sFn);\n    },\n    after: function (fn, obj, sFn) {\n        return this._inject(DO_AFTER, fn, obj, sFn);\n    },\n    _inject: function (when, fn, obj, sFn) {\n        var id = Y.stamp(obj), o, sid;\n        if (!this.objs[id]) this.objs[id] = {};\n        o = this.objs[id];\n        if (!o[sFn]) {\n            // 创建保存对象、方法名的Method对象\n            o[sFn] = new Y.Do.Method(obj, sFn);\n            // 修改对象方法\n            obj[sFn] = function () {\n                return o[sFn].exec.apply(o[sFn], arguments);\n            };\n        }\n        sid = id + Y.stamp(fn) + sFn;\n        // 注册插入方法\n        o[sFn].register(sid, fn, when);\n\n        // 返回EventHandle对象，方便注销\n        return new Y.EventHandle(o[sFn], sid);\n    }\n}\n\nY.Do.Method = function (obj, sFn) {\n    this.obj = obj;\n    this.methodName = sFn;\n    this.method = obj[sFn];\n    this.before = {};\n    this.after = {};\n};\nY.Do.Method.prototype.register = function (sid, fn, when) {\n    if (when) {\n        this.after[sid] = fn;\n    } else {\n        this.before[sid] = fn;\n    }\n};\n// 注销插入方法\nY.Do.Method.prototype._delete = function (sid) {\n    delete this.before[sid];\n    delete this.after[sid];\n};\nY.Do.Method.prototype.exec = function () {\n    var before = this.before,\n        after = this.after,\n        i, ret;\n    // 执行插入前面的方法\n    for (i in before) {\n        if (before.hasOwnProperty(i)) {\n            ret = before[i].apply(this.obj, arguments);\n        }\n    }\n    // 执行原方法\n    ret = this.method.apply(this.obj, arguments);\n    // 执行插入后面的方法\n    for (i in after) {\n        if (after.hasOwnProperty(i)) {\n            ret = after[i].apply(this.obj, arguments);\n        }\n    }\n    return ret;\n};\n```\n\n## 适用场景\n\n### a) 动态修改对象方法\n\n请参照例1。\n\n### b) 动态修改原型方法\n\n原型也是对象，所以，另外一个适用场景就是修改原型方法。\n\n```javascript\n// 例2\nYUI().use('event-custom', function (Y) {\n    function Car(brand) {\n        this.brand = brand;\n    };\n    Car.prototype.start = function () {\n        console.log('start');\n    };\n\n    var myCar = new Car('bmw');\n    Y.Do.before(function () {\n        console.log('open the door');\n    }, Car.prototype, 'start');\n    Y.Do.after(function () {\n        console.log('the car is started!');\n    }, Car.prototype, 'start');\n\n    myCar.start(); // output: open the door, start, the car is started!\n});\n```\n\n### c) 动态修改宿主方法\n\n为宿主对象添加插件时，插件往往需要在宿主一些方法前后执行某些操作。YUI提供了一个很好的[例子](http://yuilibrary.com/yui/docs/plugin/#methods)。\n\n### d) 动态修改被扩展对象方法\n\n为对象添加扩展时，扩展对象往往需要在被扩展对象一些方法前后执行某些操作。YUI提供了一个很好的[例子](http://yuilibrary.com/yui/docs/assets/base/myextension.js.txt)。\n\n## 进阶使用\n\n由于简化代码，省略了一些细节。`Y.Do`还有很多功能，例如：可以根据前置方法返回值阻止默认方法执行、替换参数等等。下面介绍一些这样的进阶使用方式：\n\n```javascript\n// 例3\nYUI().use('event-custom', function (Y) {\n    function Car(brand, degree) {\n        this.brand = brand;\n        this.degree = degree || 0;\n    };\n    Car.prototype.shift = function (degree) {\n        console.log('change to ' + degree);\n    };\n\n    var myCar = new Car('bmw');\n    \n    // 多个前置方法\n    Y.Do.before(function (degree) {\n        console.log('prepare to change');\n    }, Car.prototype, 'shift');\n    Y.Do.before(function (degree) {\n        console.log('prepare to change again');\n    }, Car.prototype, 'shift');\n    myCar.shift(1); // output: prepare to change, prepare to change again, change to 1\n\n    // 多个后置方法\n    Y.Do.after(function (degree) {\n        console.log('already change');\n    }, Car.prototype, 'shift');\n    Y.Do.after(function (degree) {\n        console.log('already change again');\n    }, Car.prototype, 'shift');\n    myCar.shift(2); // output: ..., change to 2, already change, already change again \n\n    // 中止执行\n    Y.Do.before(function (degree) {\n        if (degree < 0) {\n            console.log('halt, too low!');\n            return new Y.Do.Halt();\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(-1); // output: ..., halt, too low! \n\n    // 阻止默认方法\n    Y.Do.before(function (degree) {\n        if (degree > 4) {\n            console.log('prevent changing, too high!');\n            return new Y.Do.Prevent();\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(5); // output: ..., prevent changing, too high!, already change, ... \n\n    // 替换参数\n    Y.Do.before(function (degree) {\n        var d = Math.floor(degree);\n        if (degree !== d) {\n            return new Y.Do.AlterArgs('degree should be a integer', [d]);\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(2.5); // output: ..., change to 2, ... \n\n    // 替换返回值\n    Y.Do.after(function (degree) {\n        if (degree === 0) {\n            return new Y.Do.AlterReturn('', 'wow, your car now has no power');\n        }\n    }, Car.prototype, 'shift');\n    var ret = myCar.shift(0); // output: ..., change to 0, ... \n    console.log(ret); // wow, your car now has no power\n});\n```\n\n## 参考\n\n- [YUILibrary-Do](http://yuilibrary.com/yui/docs/api/classes/Do.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n- [Wikipedia-AOP](http://en.wikipedia.org/wiki/Aspect-oriented_programming)\n","source":"_posts/event-do.md","raw":"---\nlayout: post\ntitle: \"YUI事件体系之Y.Do\"\ndate: 2012-07-14 17:34\ncomments: true\nstatus: publish\ntags: [YUI, Event, JavaScript]\n---\n\nYUI团队在种种场合不断的夸耀自己的事件体系是多么强大：\n\n- YUI 3′s Event module is one of the strengths of the library  --Eric Miraglia, [YUI Theater — Luke Smith: \"Events Evolved\"](http://www.yuiblog.com/blog/2009/10/30/smith-yuiconf2009-events/)\n- YUI 3 is not all about DOM manipulation — it also contains a robust set of class/object management tools, not to mention our powerful custom events --Tilo Mitra, [10 Things I Learned While Interning at YUI](http://net.tutsplus.com/articles/general/10-things-i-learned-while-interning-at-yui/)\n- One of the strengths of the YUI App Framework is that it's integrated tightly with the rest of YUI and benefits from YUI's fantastic event system and plugin/extension infrastructure. --Ryan Grove, [How can I decided whether to choose YUI 3's MVC or Backbone for a new project?](http://www.quora.com/How-can-I-decided-whether-to-choose-YUI-3s-MVC-or-Backbone-for-a-new-project#ld_xJGMd1_3012)\n\n事实的确如此吗？就使用YUI的开发者反馈来看，应该是不错的：\n\n- AFAIK YUI 3's event system is the most sophisticated of any JavaScript framework. Am I wrong in thinking that? --[Walter Rumsby](https://twitter.com/wrumsby/status/113568040834174976)\n- I love the event system in YUI. Pure awesomeness. --[Kevin Isom](https://twitter.com/kev_nz/statuses/180472697644515328)\n- I am constantly impressed by the degree of excellence I find in working with the YUI3 framework --Andrew Wooldridge, [Cross YUI Communication and Custom Events](http://andrewwooldridge.com/blog/2011/03/08/cross-yui-communication-and-custom-events/)\n\n作为一名YUI用户，我对其事件体系的强大深有体会。从本篇文章起，我将对YUI事件机制做一个全面分析。\n\n本次我们介绍的是比较基础的两个对象`Y.EventHandle`和`Y.Do`。千里之行积于跬步，YUI整套事件机制也是从这两个对象开始构筑的。\n\n<!-- more -->\n\n## Y.EventHandle\n`Y.EventHandle`的作用很简单：注销事件/消息监听。\n\n```javascript\nY.EventHandle = function (evt, sub) {\n    this.evt = evt; // 事件对象\n    this.sub = sub; // 监听对象\n};\nY.EventHandle.detach = function () {\n    this.evt._delete(this.sub); // 执行event对象的_delete方法，注销事件/消息监听\n    return true;\n};\n```\n\n## Y.Do\n\n`Y.Do`的作用是：向对象方法前面或者后面插入其它方法(前置、后置方法)，以达到动态修改对象行为的目的。这种方式，也称作[AOP](http://en.wikipedia.org/wiki/Aspect-oriented_programming)。\n\n## 示例\n\n让我们先来看个简单的例子：\n\n```javascript\n// 例1\nYUI().use('event-custom', function (Y) {\n    var cat = {\n        eat: function () {\n            console.log('eat a fish');\n        }\n    };\n\n    cat.eat(); // output: eat a fish\n\n    var beforeHandle = Y.Do.before(function () {\n        console.log('catch a fish');\n    }, cat, 'eat');\n    var afterHandle = Y.Do.after(function () {\n        console.log('done!');\n    }, cat, 'eat');\n    cat.eat(); // output: catch a fish, eat, done!\n\n    afterHandle.detach();\n    cat.eat(); // output: catch a fish, eat\n});\n```\n\n在不修改原对象方法的基础上，可以方便的添加前置、后置方法，并且注销这些方法也很容易。`Y.Do`非常漂亮的解决了我们动态修改对象方法的需求！很难想象，如果不用`Y.Do`代码会复杂成怎样。\n\n## 源代码分析\n\n接下来，让我们看看YUI的内部实现吧。这是多么有趣的事，就像小时候买把手枪，想不明白为什么可以射击，就砸开一看究竟。\n\n为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的[源码](http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-do.js.html#l16)。\n\n```javascript\n// 代码版本为YUI3.4.1，YUI3.5.0对Y.Do的实现有所改进\nvar DO_BEFORE = 0,\n    DO_AFTER = 1;\nY.Do = {\n    // 缓存处理对象\n    objs: {},\n    before: function (fn, obj, sFn) {\n        return this._inject(DO_BEFORE, fn, obj, sFn);\n    },\n    after: function (fn, obj, sFn) {\n        return this._inject(DO_AFTER, fn, obj, sFn);\n    },\n    _inject: function (when, fn, obj, sFn) {\n        var id = Y.stamp(obj), o, sid;\n        if (!this.objs[id]) this.objs[id] = {};\n        o = this.objs[id];\n        if (!o[sFn]) {\n            // 创建保存对象、方法名的Method对象\n            o[sFn] = new Y.Do.Method(obj, sFn);\n            // 修改对象方法\n            obj[sFn] = function () {\n                return o[sFn].exec.apply(o[sFn], arguments);\n            };\n        }\n        sid = id + Y.stamp(fn) + sFn;\n        // 注册插入方法\n        o[sFn].register(sid, fn, when);\n\n        // 返回EventHandle对象，方便注销\n        return new Y.EventHandle(o[sFn], sid);\n    }\n}\n\nY.Do.Method = function (obj, sFn) {\n    this.obj = obj;\n    this.methodName = sFn;\n    this.method = obj[sFn];\n    this.before = {};\n    this.after = {};\n};\nY.Do.Method.prototype.register = function (sid, fn, when) {\n    if (when) {\n        this.after[sid] = fn;\n    } else {\n        this.before[sid] = fn;\n    }\n};\n// 注销插入方法\nY.Do.Method.prototype._delete = function (sid) {\n    delete this.before[sid];\n    delete this.after[sid];\n};\nY.Do.Method.prototype.exec = function () {\n    var before = this.before,\n        after = this.after,\n        i, ret;\n    // 执行插入前面的方法\n    for (i in before) {\n        if (before.hasOwnProperty(i)) {\n            ret = before[i].apply(this.obj, arguments);\n        }\n    }\n    // 执行原方法\n    ret = this.method.apply(this.obj, arguments);\n    // 执行插入后面的方法\n    for (i in after) {\n        if (after.hasOwnProperty(i)) {\n            ret = after[i].apply(this.obj, arguments);\n        }\n    }\n    return ret;\n};\n```\n\n## 适用场景\n\n### a) 动态修改对象方法\n\n请参照例1。\n\n### b) 动态修改原型方法\n\n原型也是对象，所以，另外一个适用场景就是修改原型方法。\n\n```javascript\n// 例2\nYUI().use('event-custom', function (Y) {\n    function Car(brand) {\n        this.brand = brand;\n    };\n    Car.prototype.start = function () {\n        console.log('start');\n    };\n\n    var myCar = new Car('bmw');\n    Y.Do.before(function () {\n        console.log('open the door');\n    }, Car.prototype, 'start');\n    Y.Do.after(function () {\n        console.log('the car is started!');\n    }, Car.prototype, 'start');\n\n    myCar.start(); // output: open the door, start, the car is started!\n});\n```\n\n### c) 动态修改宿主方法\n\n为宿主对象添加插件时，插件往往需要在宿主一些方法前后执行某些操作。YUI提供了一个很好的[例子](http://yuilibrary.com/yui/docs/plugin/#methods)。\n\n### d) 动态修改被扩展对象方法\n\n为对象添加扩展时，扩展对象往往需要在被扩展对象一些方法前后执行某些操作。YUI提供了一个很好的[例子](http://yuilibrary.com/yui/docs/assets/base/myextension.js.txt)。\n\n## 进阶使用\n\n由于简化代码，省略了一些细节。`Y.Do`还有很多功能，例如：可以根据前置方法返回值阻止默认方法执行、替换参数等等。下面介绍一些这样的进阶使用方式：\n\n```javascript\n// 例3\nYUI().use('event-custom', function (Y) {\n    function Car(brand, degree) {\n        this.brand = brand;\n        this.degree = degree || 0;\n    };\n    Car.prototype.shift = function (degree) {\n        console.log('change to ' + degree);\n    };\n\n    var myCar = new Car('bmw');\n    \n    // 多个前置方法\n    Y.Do.before(function (degree) {\n        console.log('prepare to change');\n    }, Car.prototype, 'shift');\n    Y.Do.before(function (degree) {\n        console.log('prepare to change again');\n    }, Car.prototype, 'shift');\n    myCar.shift(1); // output: prepare to change, prepare to change again, change to 1\n\n    // 多个后置方法\n    Y.Do.after(function (degree) {\n        console.log('already change');\n    }, Car.prototype, 'shift');\n    Y.Do.after(function (degree) {\n        console.log('already change again');\n    }, Car.prototype, 'shift');\n    myCar.shift(2); // output: ..., change to 2, already change, already change again \n\n    // 中止执行\n    Y.Do.before(function (degree) {\n        if (degree < 0) {\n            console.log('halt, too low!');\n            return new Y.Do.Halt();\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(-1); // output: ..., halt, too low! \n\n    // 阻止默认方法\n    Y.Do.before(function (degree) {\n        if (degree > 4) {\n            console.log('prevent changing, too high!');\n            return new Y.Do.Prevent();\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(5); // output: ..., prevent changing, too high!, already change, ... \n\n    // 替换参数\n    Y.Do.before(function (degree) {\n        var d = Math.floor(degree);\n        if (degree !== d) {\n            return new Y.Do.AlterArgs('degree should be a integer', [d]);\n        }\n    }, Car.prototype, 'shift');\n    myCar.shift(2.5); // output: ..., change to 2, ... \n\n    // 替换返回值\n    Y.Do.after(function (degree) {\n        if (degree === 0) {\n            return new Y.Do.AlterReturn('', 'wow, your car now has no power');\n        }\n    }, Car.prototype, 'shift');\n    var ret = myCar.shift(0); // output: ..., change to 0, ... \n    console.log(ret); // wow, your car now has no power\n});\n```\n\n## 参考\n\n- [YUILibrary-Do](http://yuilibrary.com/yui/docs/api/classes/Do.html)\n- [YUILibrary-EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n- [Wikipedia-AOP](http://en.wikipedia.org/wiki/Aspect-oriented_programming)\n","slug":"event-do","published":1,"updated":"2021-10-04T12:57:16.035Z","photos":[],"link":"","_id":"cl1klgupj000l8e85b57860j0","content":"<p>YUI团队在种种场合不断的夸耀自己的事件体系是多么强大：</p>\n<ul>\n<li>YUI 3′s Event module is one of the strengths of the library  –Eric Miraglia, <a href=\"http://www.yuiblog.com/blog/2009/10/30/smith-yuiconf2009-events/\">YUI Theater — Luke Smith: “Events Evolved”</a></li>\n<li>YUI 3 is not all about DOM manipulation — it also contains a robust set of class/object management tools, not to mention our powerful custom events –Tilo Mitra, <a href=\"http://net.tutsplus.com/articles/general/10-things-i-learned-while-interning-at-yui/\">10 Things I Learned While Interning at YUI</a></li>\n<li>One of the strengths of the YUI App Framework is that it’s integrated tightly with the rest of YUI and benefits from YUI’s fantastic event system and plugin/extension infrastructure. –Ryan Grove, <a href=\"http://www.quora.com/How-can-I-decided-whether-to-choose-YUI-3s-MVC-or-Backbone-for-a-new-project#ld_xJGMd1_3012\">How can I decided whether to choose YUI 3’s MVC or Backbone for a new project?</a></li>\n</ul>\n<p>事实的确如此吗？就使用YUI的开发者反馈来看，应该是不错的：</p>\n<ul>\n<li>AFAIK YUI 3’s event system is the most sophisticated of any JavaScript framework. Am I wrong in thinking that? –<a href=\"https://twitter.com/wrumsby/status/113568040834174976\">Walter Rumsby</a></li>\n<li>I love the event system in YUI. Pure awesomeness. –<a href=\"https://twitter.com/kev_nz/statuses/180472697644515328\">Kevin Isom</a></li>\n<li>I am constantly impressed by the degree of excellence I find in working with the YUI3 framework –Andrew Wooldridge, <a href=\"http://andrewwooldridge.com/blog/2011/03/08/cross-yui-communication-and-custom-events/\">Cross YUI Communication and Custom Events</a></li>\n</ul>\n<p>作为一名YUI用户，我对其事件体系的强大深有体会。从本篇文章起，我将对YUI事件机制做一个全面分析。</p>\n<p>本次我们介绍的是比较基础的两个对象<code>Y.EventHandle</code>和<code>Y.Do</code>。千里之行积于跬步，YUI整套事件机制也是从这两个对象开始构筑的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Y-EventHandle\"><a href=\"#Y-EventHandle\" class=\"headerlink\" title=\"Y.EventHandle\"></a>Y.EventHandle</h2><p><code>Y.EventHandle</code>的作用很简单：注销事件/消息监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.EventHandle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt, sub</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evt = evt; <span class=\"comment\">// 事件对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sub = sub; <span class=\"comment\">// 监听对象</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.EventHandle.detach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evt._delete(<span class=\"built_in\">this</span>.sub); <span class=\"comment\">// 执行event对象的_delete方法，注销事件/消息监听</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-Do\"><a href=\"#Y-Do\" class=\"headerlink\" title=\"Y.Do\"></a>Y.Do</h2><p><code>Y.Do</code>的作用是：向对象方法前面或者后面插入其它方法(前置、后置方法)，以达到动态修改对象行为的目的。这种方式，也称作<a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">AOP</a>。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>让我们先来看个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cat = &#123;</span><br><span class=\"line\">        <span class=\"attr\">eat</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;eat a fish&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: eat a fish</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> beforeHandle = Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;catch a fish&#x27;</span>);</span><br><span class=\"line\">    &#125;, cat, <span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> afterHandle = Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done!&#x27;</span>);</span><br><span class=\"line\">    &#125;, cat, <span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: catch a fish, eat, done!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    afterHandle.detach();</span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: catch a fish, eat</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在不修改原对象方法的基础上，可以方便的添加前置、后置方法，并且注销这些方法也很容易。<code>Y.Do</code>非常漂亮的解决了我们动态修改对象方法的需求！很难想象，如果不用<code>Y.Do</code>代码会复杂成怎样。</p>\n<h2 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h2><p>接下来，让我们看看YUI的内部实现吧。这是多么有趣的事，就像小时候买把手枪，想不明白为什么可以射击，就砸开一看究竟。</p>\n<p>为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-do.js.html#l16\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码版本为YUI3.4.1，YUI3.5.0对Y.Do的实现有所改进</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> DO_BEFORE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    DO_AFTER = <span class=\"number\">1</span>;</span><br><span class=\"line\">Y.Do = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存处理对象</span></span><br><span class=\"line\">    <span class=\"attr\">objs</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">before</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._inject(DO_BEFORE, fn, obj, sFn);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._inject(DO_AFTER, fn, obj, sFn);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">_inject</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">when, fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> id = Y.stamp(obj), o, sid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.objs[id]) <span class=\"built_in\">this</span>.objs[id] = &#123;&#125;;</span><br><span class=\"line\">        o = <span class=\"built_in\">this</span>.objs[id];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!o[sFn]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建保存对象、方法名的Method对象</span></span><br><span class=\"line\">            o[sFn] = <span class=\"keyword\">new</span> Y.Do.Method(obj, sFn);</span><br><span class=\"line\">            <span class=\"comment\">// 修改对象方法</span></span><br><span class=\"line\">            obj[sFn] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o[sFn].exec.apply(o[sFn], <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sid = id + Y.stamp(fn) + sFn;</span><br><span class=\"line\">        <span class=\"comment\">// 注册插入方法</span></span><br><span class=\"line\">        o[sFn].register(sid, fn, when);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回EventHandle对象，方便注销</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.EventHandle(o[sFn], sid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Do.Method = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodName = sFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.method = obj[sFn];</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.before = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.after = &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Do.Method.prototype.register = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sid, fn, when</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (when) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.after[sid] = fn;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.before[sid] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 注销插入方法</span></span><br><span class=\"line\">Y.Do.Method.prototype._delete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sid</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.before[sid];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.after[sid];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Do.Method.prototype.exec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> before = <span class=\"built_in\">this</span>.before,</span><br><span class=\"line\">        after = <span class=\"built_in\">this</span>.after,</span><br><span class=\"line\">        i, ret;</span><br><span class=\"line\">    <span class=\"comment\">// 执行插入前面的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> before) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (before.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            ret = before[i].apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行原方法</span></span><br><span class=\"line\">    ret = <span class=\"built_in\">this</span>.method.apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 执行插入后面的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> after) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (after.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            ret = after[i].apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><h3 id=\"a-动态修改对象方法\"><a href=\"#a-动态修改对象方法\" class=\"headerlink\" title=\"a) 动态修改对象方法\"></a>a) 动态修改对象方法</h3><p>请参照例1。</p>\n<h3 id=\"b-动态修改原型方法\"><a href=\"#b-动态修改原型方法\" class=\"headerlink\" title=\"b) 动态修改原型方法\"></a>b) 动态修改原型方法</h3><p>原型也是对象，所以，另外一个适用场景就是修改原型方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">brand</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Car.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">&#x27;bmw&#x27;</span>);</span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;open the door&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;the car is started!&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    myCar.start(); <span class=\"comment\">// output: open the door, start, the car is started!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"c-动态修改宿主方法\"><a href=\"#c-动态修改宿主方法\" class=\"headerlink\" title=\"c) 动态修改宿主方法\"></a>c) 动态修改宿主方法</h3><p>为宿主对象添加插件时，插件往往需要在宿主一些方法前后执行某些操作。YUI提供了一个很好的<a href=\"http://yuilibrary.com/yui/docs/plugin/#methods\">例子</a>。</p>\n<h3 id=\"d-动态修改被扩展对象方法\"><a href=\"#d-动态修改被扩展对象方法\" class=\"headerlink\" title=\"d) 动态修改被扩展对象方法\"></a>d) 动态修改被扩展对象方法</h3><p>为对象添加扩展时，扩展对象往往需要在被扩展对象一些方法前后执行某些操作。YUI提供了一个很好的<a href=\"http://yuilibrary.com/yui/docs/assets/base/myextension.js.txt\">例子</a>。</p>\n<h2 id=\"进阶使用\"><a href=\"#进阶使用\" class=\"headerlink\" title=\"进阶使用\"></a>进阶使用</h2><p>由于简化代码，省略了一些细节。<code>Y.Do</code>还有很多功能，例如：可以根据前置方法返回值阻止默认方法执行、替换参数等等。下面介绍一些这样的进阶使用方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">brand, degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.degree = degree || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Car.prototype.shift = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;change to &#x27;</span> + degree);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">&#x27;bmw&#x27;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 多个前置方法</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prepare to change&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prepare to change again&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">1</span>); <span class=\"comment\">// output: prepare to change, prepare to change again, change to 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个后置方法</span></span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;already change&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;already change again&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">2</span>); <span class=\"comment\">// output: ..., change to 2, already change, already change again </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中止执行</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;halt, too low!&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.Halt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(-<span class=\"number\">1</span>); <span class=\"comment\">// output: ..., halt, too low! </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻止默认方法</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prevent changing, too high!&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.Prevent();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">5</span>); <span class=\"comment\">// output: ..., prevent changing, too high!, already change, ... </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 替换参数</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> d = <span class=\"built_in\">Math</span>.floor(degree);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree !== d) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.AlterArgs(<span class=\"string\">&#x27;degree should be a integer&#x27;</span>, [d]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">2.5</span>); <span class=\"comment\">// output: ..., change to 2, ... </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 替换返回值</span></span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.AlterReturn(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;wow, your car now has no power&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = myCar.shift(<span class=\"number\">0</span>); <span class=\"comment\">// output: ..., change to 0, ... </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(ret); <span class=\"comment\">// wow, your car now has no power</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/classes/Do.html\">YUILibrary-Do</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">Wikipedia-AOP</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>YUI团队在种种场合不断的夸耀自己的事件体系是多么强大：</p>\n<ul>\n<li>YUI 3′s Event module is one of the strengths of the library  –Eric Miraglia, <a href=\"http://www.yuiblog.com/blog/2009/10/30/smith-yuiconf2009-events/\">YUI Theater — Luke Smith: “Events Evolved”</a></li>\n<li>YUI 3 is not all about DOM manipulation — it also contains a robust set of class/object management tools, not to mention our powerful custom events –Tilo Mitra, <a href=\"http://net.tutsplus.com/articles/general/10-things-i-learned-while-interning-at-yui/\">10 Things I Learned While Interning at YUI</a></li>\n<li>One of the strengths of the YUI App Framework is that it’s integrated tightly with the rest of YUI and benefits from YUI’s fantastic event system and plugin/extension infrastructure. –Ryan Grove, <a href=\"http://www.quora.com/How-can-I-decided-whether-to-choose-YUI-3s-MVC-or-Backbone-for-a-new-project#ld_xJGMd1_3012\">How can I decided whether to choose YUI 3’s MVC or Backbone for a new project?</a></li>\n</ul>\n<p>事实的确如此吗？就使用YUI的开发者反馈来看，应该是不错的：</p>\n<ul>\n<li>AFAIK YUI 3’s event system is the most sophisticated of any JavaScript framework. Am I wrong in thinking that? –<a href=\"https://twitter.com/wrumsby/status/113568040834174976\">Walter Rumsby</a></li>\n<li>I love the event system in YUI. Pure awesomeness. –<a href=\"https://twitter.com/kev_nz/statuses/180472697644515328\">Kevin Isom</a></li>\n<li>I am constantly impressed by the degree of excellence I find in working with the YUI3 framework –Andrew Wooldridge, <a href=\"http://andrewwooldridge.com/blog/2011/03/08/cross-yui-communication-and-custom-events/\">Cross YUI Communication and Custom Events</a></li>\n</ul>\n<p>作为一名YUI用户，我对其事件体系的强大深有体会。从本篇文章起，我将对YUI事件机制做一个全面分析。</p>\n<p>本次我们介绍的是比较基础的两个对象<code>Y.EventHandle</code>和<code>Y.Do</code>。千里之行积于跬步，YUI整套事件机制也是从这两个对象开始构筑的。</p>","more":"<h2 id=\"Y-EventHandle\"><a href=\"#Y-EventHandle\" class=\"headerlink\" title=\"Y.EventHandle\"></a>Y.EventHandle</h2><p><code>Y.EventHandle</code>的作用很简单：注销事件/消息监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y.EventHandle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt, sub</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evt = evt; <span class=\"comment\">// 事件对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sub = sub; <span class=\"comment\">// 监听对象</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.EventHandle.detach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evt._delete(<span class=\"built_in\">this</span>.sub); <span class=\"comment\">// 执行event对象的_delete方法，注销事件/消息监听</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Y-Do\"><a href=\"#Y-Do\" class=\"headerlink\" title=\"Y.Do\"></a>Y.Do</h2><p><code>Y.Do</code>的作用是：向对象方法前面或者后面插入其它方法(前置、后置方法)，以达到动态修改对象行为的目的。这种方式，也称作<a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">AOP</a>。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>让我们先来看个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cat = &#123;</span><br><span class=\"line\">        <span class=\"attr\">eat</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;eat a fish&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: eat a fish</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> beforeHandle = Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;catch a fish&#x27;</span>);</span><br><span class=\"line\">    &#125;, cat, <span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> afterHandle = Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done!&#x27;</span>);</span><br><span class=\"line\">    &#125;, cat, <span class=\"string\">&#x27;eat&#x27;</span>);</span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: catch a fish, eat, done!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    afterHandle.detach();</span><br><span class=\"line\">    cat.eat(); <span class=\"comment\">// output: catch a fish, eat</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在不修改原对象方法的基础上，可以方便的添加前置、后置方法，并且注销这些方法也很容易。<code>Y.Do</code>非常漂亮的解决了我们动态修改对象方法的需求！很难想象，如果不用<code>Y.Do</code>代码会复杂成怎样。</p>\n<h2 id=\"源代码分析\"><a href=\"#源代码分析\" class=\"headerlink\" title=\"源代码分析\"></a>源代码分析</h2><p>接下来，让我们看看YUI的内部实现吧。这是多么有趣的事，就像小时候买把手枪，想不明白为什么可以射击，就砸开一看究竟。</p>\n<p>为了更容易的看懂代码的核心，我做了适当的简化，感兴趣的朋友可以去看未删节的<a href=\"http://yuilibrary.com/yui/docs/api/files/event-custom_js_event-do.js.html#l16\">源码</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码版本为YUI3.4.1，YUI3.5.0对Y.Do的实现有所改进</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> DO_BEFORE = <span class=\"number\">0</span>,</span><br><span class=\"line\">    DO_AFTER = <span class=\"number\">1</span>;</span><br><span class=\"line\">Y.Do = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存处理对象</span></span><br><span class=\"line\">    <span class=\"attr\">objs</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">before</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._inject(DO_BEFORE, fn, obj, sFn);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">after</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._inject(DO_AFTER, fn, obj, sFn);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">_inject</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">when, fn, obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> id = Y.stamp(obj), o, sid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.objs[id]) <span class=\"built_in\">this</span>.objs[id] = &#123;&#125;;</span><br><span class=\"line\">        o = <span class=\"built_in\">this</span>.objs[id];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!o[sFn]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建保存对象、方法名的Method对象</span></span><br><span class=\"line\">            o[sFn] = <span class=\"keyword\">new</span> Y.Do.Method(obj, sFn);</span><br><span class=\"line\">            <span class=\"comment\">// 修改对象方法</span></span><br><span class=\"line\">            obj[sFn] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o[sFn].exec.apply(o[sFn], <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sid = id + Y.stamp(fn) + sFn;</span><br><span class=\"line\">        <span class=\"comment\">// 注册插入方法</span></span><br><span class=\"line\">        o[sFn].register(sid, fn, when);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回EventHandle对象，方便注销</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.EventHandle(o[sFn], sid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Y.Do.Method = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, sFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodName = sFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.method = obj[sFn];</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.before = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.after = &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Do.Method.prototype.register = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sid, fn, when</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (when) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.after[sid] = fn;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.before[sid] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 注销插入方法</span></span><br><span class=\"line\">Y.Do.Method.prototype._delete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sid</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.before[sid];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.after[sid];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.Do.Method.prototype.exec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> before = <span class=\"built_in\">this</span>.before,</span><br><span class=\"line\">        after = <span class=\"built_in\">this</span>.after,</span><br><span class=\"line\">        i, ret;</span><br><span class=\"line\">    <span class=\"comment\">// 执行插入前面的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> before) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (before.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            ret = before[i].apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行原方法</span></span><br><span class=\"line\">    ret = <span class=\"built_in\">this</span>.method.apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 执行插入后面的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> after) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (after.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            ret = after[i].apply(<span class=\"built_in\">this</span>.obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><h3 id=\"a-动态修改对象方法\"><a href=\"#a-动态修改对象方法\" class=\"headerlink\" title=\"a) 动态修改对象方法\"></a>a) 动态修改对象方法</h3><p>请参照例1。</p>\n<h3 id=\"b-动态修改原型方法\"><a href=\"#b-动态修改原型方法\" class=\"headerlink\" title=\"b) 动态修改原型方法\"></a>b) 动态修改原型方法</h3><p>原型也是对象，所以，另外一个适用场景就是修改原型方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">brand</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Car.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">&#x27;bmw&#x27;</span>);</span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;open the door&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;the car is started!&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    myCar.start(); <span class=\"comment\">// output: open the door, start, the car is started!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"c-动态修改宿主方法\"><a href=\"#c-动态修改宿主方法\" class=\"headerlink\" title=\"c) 动态修改宿主方法\"></a>c) 动态修改宿主方法</h3><p>为宿主对象添加插件时，插件往往需要在宿主一些方法前后执行某些操作。YUI提供了一个很好的<a href=\"http://yuilibrary.com/yui/docs/plugin/#methods\">例子</a>。</p>\n<h3 id=\"d-动态修改被扩展对象方法\"><a href=\"#d-动态修改被扩展对象方法\" class=\"headerlink\" title=\"d) 动态修改被扩展对象方法\"></a>d) 动态修改被扩展对象方法</h3><p>为对象添加扩展时，扩展对象往往需要在被扩展对象一些方法前后执行某些操作。YUI提供了一个很好的<a href=\"http://yuilibrary.com/yui/docs/assets/base/myextension.js.txt\">例子</a>。</p>\n<h2 id=\"进阶使用\"><a href=\"#进阶使用\" class=\"headerlink\" title=\"进阶使用\"></a>进阶使用</h2><p>由于简化代码，省略了一些细节。<code>Y.Do</code>还有很多功能，例如：可以根据前置方法返回值阻止默认方法执行、替换参数等等。下面介绍一些这样的进阶使用方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;event-custom&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">brand, degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.brand = brand;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.degree = degree || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Car.prototype.shift = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;change to &#x27;</span> + degree);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">&#x27;bmw&#x27;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 多个前置方法</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prepare to change&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prepare to change again&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">1</span>); <span class=\"comment\">// output: prepare to change, prepare to change again, change to 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个后置方法</span></span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;already change&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;already change again&#x27;</span>);</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">2</span>); <span class=\"comment\">// output: ..., change to 2, already change, already change again </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中止执行</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;halt, too low!&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.Halt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(-<span class=\"number\">1</span>); <span class=\"comment\">// output: ..., halt, too low! </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻止默认方法</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prevent changing, too high!&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.Prevent();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">5</span>); <span class=\"comment\">// output: ..., prevent changing, too high!, already change, ... </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 替换参数</span></span><br><span class=\"line\">    Y.Do.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> d = <span class=\"built_in\">Math</span>.floor(degree);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree !== d) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.AlterArgs(<span class=\"string\">&#x27;degree should be a integer&#x27;</span>, [d]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    myCar.shift(<span class=\"number\">2.5</span>); <span class=\"comment\">// output: ..., change to 2, ... </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 替换返回值</span></span><br><span class=\"line\">    Y.Do.after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">degree</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (degree === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Y.Do.AlterReturn(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;wow, your car now has no power&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, Car.prototype, <span class=\"string\">&#x27;shift&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = myCar.shift(<span class=\"number\">0</span>); <span class=\"comment\">// output: ..., change to 0, ... </span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(ret); <span class=\"comment\">// wow, your car now has no power</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://yuilibrary.com/yui/docs/api/classes/Do.html\">YUILibrary-Do</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUILibrary-EventTarget</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">Wikipedia-AOP</a></li>\n</ul>"},{"layout":"post","title":"前端组件化开发实践","date":"2015-06-29T03:07:00.000Z","comments":1,"status":"publish","author":"springuper@gmail.com","_content":"\n### 前言\n\n一位计算机前辈曾说过：\n\n    Controlling complexity is the essence of computer programming.\n    \n随着前端开发复杂度的日益提升，组件化开发应运而生，并随着 FIS、React 等优秀框架的出现遍地开花。这一过程同样发生在美团，面临业务规模的快速发展和工程师团队的不断扩张，我们历经引入组件化解决资源整合问题、逐步增强组件功能促进开发效率、重新打造新一代组件化方案适应全栈开发和共享共建等阶段，努力“controlling complexity”。本文将介绍我们组件化开发的实践过程。\n\n\n### 组件化 1.0：资源重组\n\n在美团早期，前端资源是按照页面或者类似业务页面集合的形式进行组织的。例如 order.js 对应订单相关页面的交互，account.css 对应账户相关页面的样式。这种方式在过去的较长一段时间内，持续支撑了整个项目的正常推进，功勋卓著。\n\n<center><img src=\"/images/frontend-component-practice/legacy-flow.png\" alt=\"legacy-flow\" width=\"500\"></center>\n\n\n随着业务规模的增加和开发团队的扩张，这套机制逐渐显示出它的一些不足：\n\n1. **资源冗余**\n  页面的逐渐增加，交互的逐渐复杂化，导致对应的 css 和 js 都有大幅度增长，进而出现为了依赖某个 js 中的一个函数，需要加载整个模块，或者为了使用某个 css 中的部分样式依赖整个 css，冗余资源较多\n2. **对应关系不直观**\n  没有显而易见的对应规则，导致的一个问题是修改某个业务模块的 css 或者 js 时，几乎只能依靠 grep。靠人来维护页面模块 html、css 和 js 之间的依赖关系，容易犯错，常常出现内容已经删除但是 css 或 js 还存在的问题\n3. **难于单元测试**\n  以页面为最小粒度进行资源整合，不同功能的业务模块相互影响，复杂度太高，自动化测试难以推进\n\n2013 年开始，在调研了 FIS、BEM 等方案之后，结合美团开发框架的实际，我们初步实现了一套轻量级的组件化开发方案。主要的改进是：\n\n- 以页面功能组件为单位聚合前端资源\n- 自动加载符合约定的 css、js 资源\n- 将业务数据到渲染数据的转换过程独立出来\n\n<center><img src=\"/images/frontend-component-practice/component-flow.png\" alt=\"component-flow\" width=\"500\"></center>\n\n举例来说，美团顶部的搜索框就被实现为一个组件。\n\n<center><img src=\"/images/frontend-component-practice/smart-box.png\" alt=\"smart-box\" width=\"500\"></center>\n\n<!--more-->\n\n代码构成：\n\n```bash\nwww/component/smart-box/\n├── smart-box.js    # 交互\n├── smart-box.php   # 渲染数据生产、组件配置\n├── smart-box.scss  # 样式\n├── smart-box.tpl   # 内容\n└── test\n    ├── default.js  # 自动化测试\n    └── default.php # 单测页面\n```\n\n调用组件变得十足简单：\n\n```php\necho View::useComponent('smart-box', [\n    'keyword' => $keyword\n]);\n```\n\n对比之前，可以看到组件化的一些特点：\n\n1. **按需加载**\n  只加载必要的前端资源\n2. **对应关系非常清晰**\n  组件所需要的前端资源都在同一目录，职责明确且唯一，对应关系显著\n3. **易于测试**\n  组件是具备独立展现和交互的最小单元，可利用 Phantom 等工具自动化测试\n\n此外，由于前端资源集中进行调度，组件化也为高阶性能优化提供了空间。例如实现组件级别的 BigRender、通过数据分析进行资源的合并加载等等。\n\n### 组件化 2.0：趋于成熟\n\n组件化 1.0 上线后，由于简单易用，很快得到工程师的认可，并开始在各项业务中应用起来。新的需求接踵而来，一直持续到 2014 年底，这个阶段我们称之为组件化 2.0。下面介绍下主要的几个改进。\n\n#### Lifecycle\n\n组件在高内聚的同时，往往需要暴露一些接口供外界调用，从而能够适应复杂的页面需求，例如提交订单页面需要在支付密码组件启动完成后绑定提交时的检查。Web Components、React 等都选择了生命周期事件/方法，我们也是一样。\n\n组件的生命周期：\n\n<center><img src=\"/images/frontend-component-practice/component-lifecycle.png\" alt=\"component-lifecycle\" width=\"800\"></center>\n\n一个组件的完整生命周期包括：\n\n- init，初始化组件根节点和配置\n- fetch，加载 css 和 js 资源\n- render，内容渲染，默认的渲染内容方式是 BigRender\n- ready，进行数据绑定等操作\n- update，数据更新\n- destroy，解除所有事件监听，删除所有组件节点\n\n组件提供 pause、resume 方法以方便进行生命周期控制。各个阶段使用 Promise 串行进行，异步的管理更清晰。使用自定义语义事件，在修改默认行为、组件间通信上充分利用了 YUI 强大的自定义事件体系，有效降低了开发维护成本。\n\n举个例子，页面初始化时组件的启动过程实际也是借助生命周期实现的：\n\n```js\nvar afterLoadList = [];\nY.all('[data-component]').each(function (node) {\n    var component = new Y.mt.Component(node);\n    // 绑定 init 生命周期事件，在 init 默认行为完成后执行回调\n    component.after('init', function (e) {\n        // 如果配置了延迟启动\n        if (e.config.afterLoad) {\n            // 暂停组件生命周期\n            e.component.pause();\n            // 压入延迟启动数组\n            afterLoadList.push(e.component);\n        }\n    });\n    // 开始进入生命周期\n    component.start();\n});\n \nY.on('load', function () {\n    // 在页面 load 事件发生时恢复组件生命周期\n    afterLoadList.forEach(function (component) {\n        component.resume();\n    });\n});\n```\n\n回过头来看，引入生命周期除了带来扩展性外，更重要的是理顺了组件的各个阶段，有助于更好的理解和运用。\n\n\n#### Data Binding\n\n数据绑定是我们期盼已久的功能，将 View 和 ViewModel 之间的交互自动化无疑会节省工程师的大量时间。在组件化减少关注点和降低复杂度后，实现数据绑定变得更加可能。\n\n我们最终实现的数据绑定方案主要参考了 Angular，通过在 html 节点上添加特定的属性声明绑定逻辑，js 扫描这些内容并进行相应的渲染和事件绑定。当数据发生变化时，对应的内容全部重新渲染。\n\n```html\n<ul class=\"addressList\">\n    <li\n        mt-bind-repeat=\"addr in addrList\"\n        mt-bind-html=\"addr.text\"\n    >\n    </li>\n</ul>\n\n<script>\nY.use(['mt-bind', 'mt-scope'], function () {\n    Y.mt.bind.init(document.body);\n    var scope = Y.one('.addressList').getScope();\n    // 将 scope.addrList 设置为一个数组，DOM 上将自动渲染其内容   \n    scope.$set('addrList', [\n        { text: \"first address\" },\n        { text: \"second address\" }\n    ]);\n});\n</script>\n```\n\n使用属性声明绑定逻辑的好处是可以同时支持后端渲染，这对于美团团购这样的偏展现型业务是非常必要的，用户可以很快看到页面内容。\n\n#### Flux\n\n实现数据绑定后，我们不得不面对另外一个问题：如何协同多个组件间的数据。因为某个组件的数据变化，很有可能引起其他组件的变化。例如当修改购买数量，总金额会变化，而总金额超过 500 后，还需要展示大额消费提醒。\n\n为了解决这个问题，我们引入了 Flux，使用全局消息总线的思路进行跨组件交互。\n\n例如因为交互复杂而一直让我们非常头疼的项目购买页，在应用组件 + Flux 重构后，各模块之间的互动更加清晰：\n\n<center><img src=\"/images/frontend-component-practice/component-flux.png\" alt=\"component-flux\" width=\"600\"></center>\n\n其他方面的改进还有很多，包括引入模板引擎 LightnCandy 约束模板逻辑、支持组件任意嵌套、支持异步加载并自动初始化等。\n\n随着组件化 2.0 的逐步完善，基本已经可以从容应对日常开发，在效率和质量方面都上了一个台阶。\n\n\n### 组件化 3.0：重启征程\n\n时间的车轮滚滚前行，2014 年底，我们遇到一些新的机遇和挑战：\n\n- 基于 Node 的全栈开发模式开始应用，前后端渲染有了更多的可能性\n- YUI 停止维护，需要一套新的资源管理方案\n- 新业务不断增加，需要找到一种组件共享的方式，避免重复造轮子\n\n结合之前的实践，以及在这一过程中逐渐积累的对业内方案的认知，我们提出了新的组件化方案：\n\n- 基于 React 开发页面组件，使用 NPM 进行分发，方便共建共享\n- 基于 Browserify 二次开发，建设资源打包工具 Reduce，方便浏览器加载\n- 建设适应组件化开发模式的工程化开发方案 Turbo，方便工程师将组件应用于业务开发中\n\n#### React\n\n在组件化 2.0 的过程中，我们发现很多功能和 React 重合，例如 Data Binding、Lifecycle、前后端渲染，甚至直接借鉴的 Flux。除此之外，React 的函数式编程思想、增量更新、兼容性良好的事件体系也让我们非常向往。借着前端全栈开发的契机，我们开始考虑基于 React 进行组件化 3.0 的建设。\n\n#### NPM + Reduce\n\nNPM + Reduce 构成了我们新的资源管理方案，其中：\n\n- NPM 负责组件的发布和安装。可以认为是“分”的过程，粒度越小，重用的可能性越大\n- Reduce 负责将页面资源进行打包。可以认为是“合”的过程，让浏览器更快地加载\n\n一个典型的组件包：\n\n```bash\nsmart-box/\n├── package.json    # 组件包元信息\n├── smart-box.jsx   # React Component\n├── smart-box.scss  # 样式\n└── test\n    └── main.js     # 测试\n```\n\nNPM 默认只支持 js 文件的管理，我们对 NPM 中的 package.json 进行了扩展，增加了 style 字段，以使打包工具 Reduce 也能够对 css 和 css 中引用的 image、font 进行识别和处理：\n\n```js\n{\n    \"style\": \"./smart-box.scss\"\n}\n```\n\n只要在页面中 require 了 smart-box，经过 Reduce 打包后，js、css 甚至图片、字体，都会出现在浏览器中。\n\n```js\nvar SmartBox = require('@mtfe/smart-box');\n// 页面\nvar IndexPage = React.createClass({\n    render: function () {\n        return (\n            <Header>\n                <SmartBox keyword={ this.props.keyword } />\n            </Header>\n            ...\n        );\n    }\n});\nmodule.exports = IndexPage;\n```\n\n整体思路和组件化 1.0 如出一辙，却又那么不同。\n\n#### Turbo\n\n单单解决分发和打包的问题还不够，业务开发过程如果变得繁琐、难以 Debug、性能低下的话，恐怕不会受到工程师欢迎。\n\n为了解决这些问题，我们在 Node 框架的基础上，提供了一系列中间件和开发工具，逐步构建对组件友好的前端工程化方案 Turbo。主要有：\n\n- 支持前后端同构渲染，让用户更早看到内容\n- 简化 Flux 流程，数据流更加清晰易维护\n- 引入 ImmutableJS，保证 Store 以外的数据不可变\n- 采用 cursor 机制，保证数据修改/获取同步\n- 支持 Hot Module Replacement，改进开发流自动化\n\n通过这些改进，一线工程师可以方便的使用各种组件，专注在业务本身上。开发框架层面的支持也反过来促进了组件化的发展，大家更乐于使用一系列组件来构建页面功能。\n\n### 小结\n\n发现痛点、分析调研、应用改进的解决问题思路在组件化开发实践中不断运用。历经三个大版本的演进，组件化开发模式有效缓解了业务发展带来的复杂度提升的压力，并培养工程师具备小而美的工程思想，形成共建共享的良好氛围。毫无疑问，组件化这种“分而治之”的思想将会长久地影响和促进前端开发模式。我们现在已经准备好，迎接新的机遇和挑战，用技术的不断革新提升工程师的幸福感。\n","source":"_posts/frontend-component-practice.md","raw":"---\nlayout: post\ntitle: \"前端组件化开发实践\"\ndate: 2015-06-29 11:07\ncomments: true\nstatus: publish\nauthor: springuper@gmail.com\ntags: [front-end, component, reduce, turbo]\n---\n\n### 前言\n\n一位计算机前辈曾说过：\n\n    Controlling complexity is the essence of computer programming.\n    \n随着前端开发复杂度的日益提升，组件化开发应运而生，并随着 FIS、React 等优秀框架的出现遍地开花。这一过程同样发生在美团，面临业务规模的快速发展和工程师团队的不断扩张，我们历经引入组件化解决资源整合问题、逐步增强组件功能促进开发效率、重新打造新一代组件化方案适应全栈开发和共享共建等阶段，努力“controlling complexity”。本文将介绍我们组件化开发的实践过程。\n\n\n### 组件化 1.0：资源重组\n\n在美团早期，前端资源是按照页面或者类似业务页面集合的形式进行组织的。例如 order.js 对应订单相关页面的交互，account.css 对应账户相关页面的样式。这种方式在过去的较长一段时间内，持续支撑了整个项目的正常推进，功勋卓著。\n\n<center><img src=\"/images/frontend-component-practice/legacy-flow.png\" alt=\"legacy-flow\" width=\"500\"></center>\n\n\n随着业务规模的增加和开发团队的扩张，这套机制逐渐显示出它的一些不足：\n\n1. **资源冗余**\n  页面的逐渐增加，交互的逐渐复杂化，导致对应的 css 和 js 都有大幅度增长，进而出现为了依赖某个 js 中的一个函数，需要加载整个模块，或者为了使用某个 css 中的部分样式依赖整个 css，冗余资源较多\n2. **对应关系不直观**\n  没有显而易见的对应规则，导致的一个问题是修改某个业务模块的 css 或者 js 时，几乎只能依靠 grep。靠人来维护页面模块 html、css 和 js 之间的依赖关系，容易犯错，常常出现内容已经删除但是 css 或 js 还存在的问题\n3. **难于单元测试**\n  以页面为最小粒度进行资源整合，不同功能的业务模块相互影响，复杂度太高，自动化测试难以推进\n\n2013 年开始，在调研了 FIS、BEM 等方案之后，结合美团开发框架的实际，我们初步实现了一套轻量级的组件化开发方案。主要的改进是：\n\n- 以页面功能组件为单位聚合前端资源\n- 自动加载符合约定的 css、js 资源\n- 将业务数据到渲染数据的转换过程独立出来\n\n<center><img src=\"/images/frontend-component-practice/component-flow.png\" alt=\"component-flow\" width=\"500\"></center>\n\n举例来说，美团顶部的搜索框就被实现为一个组件。\n\n<center><img src=\"/images/frontend-component-practice/smart-box.png\" alt=\"smart-box\" width=\"500\"></center>\n\n<!--more-->\n\n代码构成：\n\n```bash\nwww/component/smart-box/\n├── smart-box.js    # 交互\n├── smart-box.php   # 渲染数据生产、组件配置\n├── smart-box.scss  # 样式\n├── smart-box.tpl   # 内容\n└── test\n    ├── default.js  # 自动化测试\n    └── default.php # 单测页面\n```\n\n调用组件变得十足简单：\n\n```php\necho View::useComponent('smart-box', [\n    'keyword' => $keyword\n]);\n```\n\n对比之前，可以看到组件化的一些特点：\n\n1. **按需加载**\n  只加载必要的前端资源\n2. **对应关系非常清晰**\n  组件所需要的前端资源都在同一目录，职责明确且唯一，对应关系显著\n3. **易于测试**\n  组件是具备独立展现和交互的最小单元，可利用 Phantom 等工具自动化测试\n\n此外，由于前端资源集中进行调度，组件化也为高阶性能优化提供了空间。例如实现组件级别的 BigRender、通过数据分析进行资源的合并加载等等。\n\n### 组件化 2.0：趋于成熟\n\n组件化 1.0 上线后，由于简单易用，很快得到工程师的认可，并开始在各项业务中应用起来。新的需求接踵而来，一直持续到 2014 年底，这个阶段我们称之为组件化 2.0。下面介绍下主要的几个改进。\n\n#### Lifecycle\n\n组件在高内聚的同时，往往需要暴露一些接口供外界调用，从而能够适应复杂的页面需求，例如提交订单页面需要在支付密码组件启动完成后绑定提交时的检查。Web Components、React 等都选择了生命周期事件/方法，我们也是一样。\n\n组件的生命周期：\n\n<center><img src=\"/images/frontend-component-practice/component-lifecycle.png\" alt=\"component-lifecycle\" width=\"800\"></center>\n\n一个组件的完整生命周期包括：\n\n- init，初始化组件根节点和配置\n- fetch，加载 css 和 js 资源\n- render，内容渲染，默认的渲染内容方式是 BigRender\n- ready，进行数据绑定等操作\n- update，数据更新\n- destroy，解除所有事件监听，删除所有组件节点\n\n组件提供 pause、resume 方法以方便进行生命周期控制。各个阶段使用 Promise 串行进行，异步的管理更清晰。使用自定义语义事件，在修改默认行为、组件间通信上充分利用了 YUI 强大的自定义事件体系，有效降低了开发维护成本。\n\n举个例子，页面初始化时组件的启动过程实际也是借助生命周期实现的：\n\n```js\nvar afterLoadList = [];\nY.all('[data-component]').each(function (node) {\n    var component = new Y.mt.Component(node);\n    // 绑定 init 生命周期事件，在 init 默认行为完成后执行回调\n    component.after('init', function (e) {\n        // 如果配置了延迟启动\n        if (e.config.afterLoad) {\n            // 暂停组件生命周期\n            e.component.pause();\n            // 压入延迟启动数组\n            afterLoadList.push(e.component);\n        }\n    });\n    // 开始进入生命周期\n    component.start();\n});\n \nY.on('load', function () {\n    // 在页面 load 事件发生时恢复组件生命周期\n    afterLoadList.forEach(function (component) {\n        component.resume();\n    });\n});\n```\n\n回过头来看，引入生命周期除了带来扩展性外，更重要的是理顺了组件的各个阶段，有助于更好的理解和运用。\n\n\n#### Data Binding\n\n数据绑定是我们期盼已久的功能，将 View 和 ViewModel 之间的交互自动化无疑会节省工程师的大量时间。在组件化减少关注点和降低复杂度后，实现数据绑定变得更加可能。\n\n我们最终实现的数据绑定方案主要参考了 Angular，通过在 html 节点上添加特定的属性声明绑定逻辑，js 扫描这些内容并进行相应的渲染和事件绑定。当数据发生变化时，对应的内容全部重新渲染。\n\n```html\n<ul class=\"addressList\">\n    <li\n        mt-bind-repeat=\"addr in addrList\"\n        mt-bind-html=\"addr.text\"\n    >\n    </li>\n</ul>\n\n<script>\nY.use(['mt-bind', 'mt-scope'], function () {\n    Y.mt.bind.init(document.body);\n    var scope = Y.one('.addressList').getScope();\n    // 将 scope.addrList 设置为一个数组，DOM 上将自动渲染其内容   \n    scope.$set('addrList', [\n        { text: \"first address\" },\n        { text: \"second address\" }\n    ]);\n});\n</script>\n```\n\n使用属性声明绑定逻辑的好处是可以同时支持后端渲染，这对于美团团购这样的偏展现型业务是非常必要的，用户可以很快看到页面内容。\n\n#### Flux\n\n实现数据绑定后，我们不得不面对另外一个问题：如何协同多个组件间的数据。因为某个组件的数据变化，很有可能引起其他组件的变化。例如当修改购买数量，总金额会变化，而总金额超过 500 后，还需要展示大额消费提醒。\n\n为了解决这个问题，我们引入了 Flux，使用全局消息总线的思路进行跨组件交互。\n\n例如因为交互复杂而一直让我们非常头疼的项目购买页，在应用组件 + Flux 重构后，各模块之间的互动更加清晰：\n\n<center><img src=\"/images/frontend-component-practice/component-flux.png\" alt=\"component-flux\" width=\"600\"></center>\n\n其他方面的改进还有很多，包括引入模板引擎 LightnCandy 约束模板逻辑、支持组件任意嵌套、支持异步加载并自动初始化等。\n\n随着组件化 2.0 的逐步完善，基本已经可以从容应对日常开发，在效率和质量方面都上了一个台阶。\n\n\n### 组件化 3.0：重启征程\n\n时间的车轮滚滚前行，2014 年底，我们遇到一些新的机遇和挑战：\n\n- 基于 Node 的全栈开发模式开始应用，前后端渲染有了更多的可能性\n- YUI 停止维护，需要一套新的资源管理方案\n- 新业务不断增加，需要找到一种组件共享的方式，避免重复造轮子\n\n结合之前的实践，以及在这一过程中逐渐积累的对业内方案的认知，我们提出了新的组件化方案：\n\n- 基于 React 开发页面组件，使用 NPM 进行分发，方便共建共享\n- 基于 Browserify 二次开发，建设资源打包工具 Reduce，方便浏览器加载\n- 建设适应组件化开发模式的工程化开发方案 Turbo，方便工程师将组件应用于业务开发中\n\n#### React\n\n在组件化 2.0 的过程中，我们发现很多功能和 React 重合，例如 Data Binding、Lifecycle、前后端渲染，甚至直接借鉴的 Flux。除此之外，React 的函数式编程思想、增量更新、兼容性良好的事件体系也让我们非常向往。借着前端全栈开发的契机，我们开始考虑基于 React 进行组件化 3.0 的建设。\n\n#### NPM + Reduce\n\nNPM + Reduce 构成了我们新的资源管理方案，其中：\n\n- NPM 负责组件的发布和安装。可以认为是“分”的过程，粒度越小，重用的可能性越大\n- Reduce 负责将页面资源进行打包。可以认为是“合”的过程，让浏览器更快地加载\n\n一个典型的组件包：\n\n```bash\nsmart-box/\n├── package.json    # 组件包元信息\n├── smart-box.jsx   # React Component\n├── smart-box.scss  # 样式\n└── test\n    └── main.js     # 测试\n```\n\nNPM 默认只支持 js 文件的管理，我们对 NPM 中的 package.json 进行了扩展，增加了 style 字段，以使打包工具 Reduce 也能够对 css 和 css 中引用的 image、font 进行识别和处理：\n\n```js\n{\n    \"style\": \"./smart-box.scss\"\n}\n```\n\n只要在页面中 require 了 smart-box，经过 Reduce 打包后，js、css 甚至图片、字体，都会出现在浏览器中。\n\n```js\nvar SmartBox = require('@mtfe/smart-box');\n// 页面\nvar IndexPage = React.createClass({\n    render: function () {\n        return (\n            <Header>\n                <SmartBox keyword={ this.props.keyword } />\n            </Header>\n            ...\n        );\n    }\n});\nmodule.exports = IndexPage;\n```\n\n整体思路和组件化 1.0 如出一辙，却又那么不同。\n\n#### Turbo\n\n单单解决分发和打包的问题还不够，业务开发过程如果变得繁琐、难以 Debug、性能低下的话，恐怕不会受到工程师欢迎。\n\n为了解决这些问题，我们在 Node 框架的基础上，提供了一系列中间件和开发工具，逐步构建对组件友好的前端工程化方案 Turbo。主要有：\n\n- 支持前后端同构渲染，让用户更早看到内容\n- 简化 Flux 流程，数据流更加清晰易维护\n- 引入 ImmutableJS，保证 Store 以外的数据不可变\n- 采用 cursor 机制，保证数据修改/获取同步\n- 支持 Hot Module Replacement，改进开发流自动化\n\n通过这些改进，一线工程师可以方便的使用各种组件，专注在业务本身上。开发框架层面的支持也反过来促进了组件化的发展，大家更乐于使用一系列组件来构建页面功能。\n\n### 小结\n\n发现痛点、分析调研、应用改进的解决问题思路在组件化开发实践中不断运用。历经三个大版本的演进，组件化开发模式有效缓解了业务发展带来的复杂度提升的压力，并培养工程师具备小而美的工程思想，形成共建共享的良好氛围。毫无疑问，组件化这种“分而治之”的思想将会长久地影响和促进前端开发模式。我们现在已经准备好，迎接新的机遇和挑战，用技术的不断革新提升工程师的幸福感。\n","slug":"frontend-component-practice","published":1,"updated":"2021-11-25T11:00:14.648Z","photos":[],"link":"","_id":"cl1klgupk000o8e85gl3a7hsn","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一位计算机前辈曾说过：</p>\n<pre><code>Controlling complexity is the essence of computer programming.\n</code></pre>\n<p>随着前端开发复杂度的日益提升，组件化开发应运而生，并随着 FIS、React 等优秀框架的出现遍地开花。这一过程同样发生在美团，面临业务规模的快速发展和工程师团队的不断扩张，我们历经引入组件化解决资源整合问题、逐步增强组件功能促进开发效率、重新打造新一代组件化方案适应全栈开发和共享共建等阶段，努力“controlling complexity”。本文将介绍我们组件化开发的实践过程。</p>\n<h3 id=\"组件化-1-0：资源重组\"><a href=\"#组件化-1-0：资源重组\" class=\"headerlink\" title=\"组件化 1.0：资源重组\"></a>组件化 1.0：资源重组</h3><p>在美团早期，前端资源是按照页面或者类似业务页面集合的形式进行组织的。例如 order.js 对应订单相关页面的交互，account.css 对应账户相关页面的样式。这种方式在过去的较长一段时间内，持续支撑了整个项目的正常推进，功勋卓著。</p>\n<center><img src=\"/images/frontend-component-practice/legacy-flow.png\" alt=\"legacy-flow\" width=\"500\"></center>\n\n\n<p>随着业务规模的增加和开发团队的扩张，这套机制逐渐显示出它的一些不足：</p>\n<ol>\n<li><strong>资源冗余</strong>\n页面的逐渐增加，交互的逐渐复杂化，导致对应的 css 和 js 都有大幅度增长，进而出现为了依赖某个 js 中的一个函数，需要加载整个模块，或者为了使用某个 css 中的部分样式依赖整个 css，冗余资源较多</li>\n<li><strong>对应关系不直观</strong>\n没有显而易见的对应规则，导致的一个问题是修改某个业务模块的 css 或者 js 时，几乎只能依靠 grep。靠人来维护页面模块 html、css 和 js 之间的依赖关系，容易犯错，常常出现内容已经删除但是 css 或 js 还存在的问题</li>\n<li><strong>难于单元测试</strong>\n以页面为最小粒度进行资源整合，不同功能的业务模块相互影响，复杂度太高，自动化测试难以推进</li>\n</ol>\n<p>2013 年开始，在调研了 FIS、BEM 等方案之后，结合美团开发框架的实际，我们初步实现了一套轻量级的组件化开发方案。主要的改进是：</p>\n<ul>\n<li>以页面功能组件为单位聚合前端资源</li>\n<li>自动加载符合约定的 css、js 资源</li>\n<li>将业务数据到渲染数据的转换过程独立出来</li>\n</ul>\n<center><img src=\"/images/frontend-component-practice/component-flow.png\" alt=\"component-flow\" width=\"500\"></center>\n\n<p>举例来说，美团顶部的搜索框就被实现为一个组件。</p>\n<center><img src=\"/images/frontend-component-practice/smart-box.png\" alt=\"smart-box\" width=\"500\"></center>\n\n<span id=\"more\"></span>\n\n<p>代码构成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www/component/smart-box/</span><br><span class=\"line\">├── smart-box.js    <span class=\"comment\"># 交互</span></span><br><span class=\"line\">├── smart-box.php   <span class=\"comment\"># 渲染数据生产、组件配置</span></span><br><span class=\"line\">├── smart-box.scss  <span class=\"comment\"># 样式</span></span><br><span class=\"line\">├── smart-box.tpl   <span class=\"comment\"># 内容</span></span><br><span class=\"line\">└── <span class=\"built_in\">test</span></span><br><span class=\"line\">    ├── default.js  <span class=\"comment\"># 自动化测试</span></span><br><span class=\"line\">    └── default.php <span class=\"comment\"># 单测页面</span></span><br></pre></td></tr></table></figure>\n\n<p>调用组件变得十足简单：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span> View::useComponent(<span class=\"string\">&#x27;smart-box&#x27;</span>, [</span><br><span class=\"line\">    <span class=\"string\">&#x27;keyword&#x27;</span> =&gt; <span class=\"variable\">$keyword</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>对比之前，可以看到组件化的一些特点：</p>\n<ol>\n<li><strong>按需加载</strong>\n只加载必要的前端资源</li>\n<li><strong>对应关系非常清晰</strong>\n组件所需要的前端资源都在同一目录，职责明确且唯一，对应关系显著</li>\n<li><strong>易于测试</strong>\n组件是具备独立展现和交互的最小单元，可利用 Phantom 等工具自动化测试</li>\n</ol>\n<p>此外，由于前端资源集中进行调度，组件化也为高阶性能优化提供了空间。例如实现组件级别的 BigRender、通过数据分析进行资源的合并加载等等。</p>\n<h3 id=\"组件化-2-0：趋于成熟\"><a href=\"#组件化-2-0：趋于成熟\" class=\"headerlink\" title=\"组件化 2.0：趋于成熟\"></a>组件化 2.0：趋于成熟</h3><p>组件化 1.0 上线后，由于简单易用，很快得到工程师的认可，并开始在各项业务中应用起来。新的需求接踵而来，一直持续到 2014 年底，这个阶段我们称之为组件化 2.0。下面介绍下主要的几个改进。</p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p>组件在高内聚的同时，往往需要暴露一些接口供外界调用，从而能够适应复杂的页面需求，例如提交订单页面需要在支付密码组件启动完成后绑定提交时的检查。Web Components、React 等都选择了生命周期事件/方法，我们也是一样。</p>\n<p>组件的生命周期：</p>\n<center><img src=\"/images/frontend-component-practice/component-lifecycle.png\" alt=\"component-lifecycle\" width=\"800\"></center>\n\n<p>一个组件的完整生命周期包括：</p>\n<ul>\n<li>init，初始化组件根节点和配置</li>\n<li>fetch，加载 css 和 js 资源</li>\n<li>render，内容渲染，默认的渲染内容方式是 BigRender</li>\n<li>ready，进行数据绑定等操作</li>\n<li>update，数据更新</li>\n<li>destroy，解除所有事件监听，删除所有组件节点</li>\n</ul>\n<p>组件提供 pause、resume 方法以方便进行生命周期控制。各个阶段使用 Promise 串行进行，异步的管理更清晰。使用自定义语义事件，在修改默认行为、组件间通信上充分利用了 YUI 强大的自定义事件体系，有效降低了开发维护成本。</p>\n<p>举个例子，页面初始化时组件的启动过程实际也是借助生命周期实现的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> afterLoadList = [];</span><br><span class=\"line\">Y.all(<span class=\"string\">&#x27;[data-component]&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> Y.mt.Component(node);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 init 生命周期事件，在 init 默认行为完成后执行回调</span></span><br><span class=\"line\">    component.after(<span class=\"string\">&#x27;init&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果配置了延迟启动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.config.afterLoad) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 暂停组件生命周期</span></span><br><span class=\"line\">            e.component.pause();</span><br><span class=\"line\">            <span class=\"comment\">// 压入延迟启动数组</span></span><br><span class=\"line\">            afterLoadList.push(e.component);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 开始进入生命周期</span></span><br><span class=\"line\">    component.start();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">Y.on(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在页面 load 事件发生时恢复组件生命周期</span></span><br><span class=\"line\">    afterLoadList.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">        component.resume();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>回过头来看，引入生命周期除了带来扩展性外，更重要的是理顺了组件的各个阶段，有助于更好的理解和运用。</p>\n<h4 id=\"Data-Binding\"><a href=\"#Data-Binding\" class=\"headerlink\" title=\"Data Binding\"></a>Data Binding</h4><p>数据绑定是我们期盼已久的功能，将 View 和 ViewModel 之间的交互自动化无疑会节省工程师的大量时间。在组件化减少关注点和降低复杂度后，实现数据绑定变得更加可能。</p>\n<p>我们最终实现的数据绑定方案主要参考了 Angular，通过在 html 节点上添加特定的属性声明绑定逻辑，js 扫描这些内容并进行相应的渲染和事件绑定。当数据发生变化时，对应的内容全部重新渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;addressList&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">mt-bind-repeat</span>=<span class=\"string\">&quot;addr in addrList&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">mt-bind-html</span>=<span class=\"string\">&quot;addr.text&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">Y.use([<span class=\"string\">&#x27;mt-bind&#x27;</span>, <span class=\"string\">&#x27;mt-scope&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    Y.mt.bind.init(<span class=\"built_in\">document</span>.body);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scope = Y.one(<span class=\"string\">&#x27;.addressList&#x27;</span>).getScope();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将 scope.addrList 设置为一个数组，DOM 上将自动渲染其内容   </span></span></span><br><span class=\"line\"><span class=\"javascript\">    scope.$set(<span class=\"string\">&#x27;addrList&#x27;</span>, [</span></span><br><span class=\"line\"><span class=\"javascript\">        &#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;first address&quot;</span> &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">        &#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;second address&quot;</span> &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    ]);</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用属性声明绑定逻辑的好处是可以同时支持后端渲染，这对于美团团购这样的偏展现型业务是非常必要的，用户可以很快看到页面内容。</p>\n<h4 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h4><p>实现数据绑定后，我们不得不面对另外一个问题：如何协同多个组件间的数据。因为某个组件的数据变化，很有可能引起其他组件的变化。例如当修改购买数量，总金额会变化，而总金额超过 500 后，还需要展示大额消费提醒。</p>\n<p>为了解决这个问题，我们引入了 Flux，使用全局消息总线的思路进行跨组件交互。</p>\n<p>例如因为交互复杂而一直让我们非常头疼的项目购买页，在应用组件 + Flux 重构后，各模块之间的互动更加清晰：</p>\n<center><img src=\"/images/frontend-component-practice/component-flux.png\" alt=\"component-flux\" width=\"600\"></center>\n\n<p>其他方面的改进还有很多，包括引入模板引擎 LightnCandy 约束模板逻辑、支持组件任意嵌套、支持异步加载并自动初始化等。</p>\n<p>随着组件化 2.0 的逐步完善，基本已经可以从容应对日常开发，在效率和质量方面都上了一个台阶。</p>\n<h3 id=\"组件化-3-0：重启征程\"><a href=\"#组件化-3-0：重启征程\" class=\"headerlink\" title=\"组件化 3.0：重启征程\"></a>组件化 3.0：重启征程</h3><p>时间的车轮滚滚前行，2014 年底，我们遇到一些新的机遇和挑战：</p>\n<ul>\n<li>基于 Node 的全栈开发模式开始应用，前后端渲染有了更多的可能性</li>\n<li>YUI 停止维护，需要一套新的资源管理方案</li>\n<li>新业务不断增加，需要找到一种组件共享的方式，避免重复造轮子</li>\n</ul>\n<p>结合之前的实践，以及在这一过程中逐渐积累的对业内方案的认知，我们提出了新的组件化方案：</p>\n<ul>\n<li>基于 React 开发页面组件，使用 NPM 进行分发，方便共建共享</li>\n<li>基于 Browserify 二次开发，建设资源打包工具 Reduce，方便浏览器加载</li>\n<li>建设适应组件化开发模式的工程化开发方案 Turbo，方便工程师将组件应用于业务开发中</li>\n</ul>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>在组件化 2.0 的过程中，我们发现很多功能和 React 重合，例如 Data Binding、Lifecycle、前后端渲染，甚至直接借鉴的 Flux。除此之外，React 的函数式编程思想、增量更新、兼容性良好的事件体系也让我们非常向往。借着前端全栈开发的契机，我们开始考虑基于 React 进行组件化 3.0 的建设。</p>\n<h4 id=\"NPM-Reduce\"><a href=\"#NPM-Reduce\" class=\"headerlink\" title=\"NPM + Reduce\"></a>NPM + Reduce</h4><p>NPM + Reduce 构成了我们新的资源管理方案，其中：</p>\n<ul>\n<li>NPM 负责组件的发布和安装。可以认为是“分”的过程，粒度越小，重用的可能性越大</li>\n<li>Reduce 负责将页面资源进行打包。可以认为是“合”的过程，让浏览器更快地加载</li>\n</ul>\n<p>一个典型的组件包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smart-box/</span><br><span class=\"line\">├── package.json    <span class=\"comment\"># 组件包元信息</span></span><br><span class=\"line\">├── smart-box.jsx   <span class=\"comment\"># React Component</span></span><br><span class=\"line\">├── smart-box.scss  <span class=\"comment\"># 样式</span></span><br><span class=\"line\">└── <span class=\"built_in\">test</span></span><br><span class=\"line\">    └── main.js     <span class=\"comment\"># 测试</span></span><br></pre></td></tr></table></figure>\n\n<p>NPM 默认只支持 js 文件的管理，我们对 NPM 中的 package.json 进行了扩展，增加了 style 字段，以使打包工具 Reduce 也能够对 css 和 css 中引用的 image、font 进行识别和处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;style&quot;</span>: <span class=\"string\">&quot;./smart-box.scss&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要在页面中 require 了 smart-box，经过 Reduce 打包后，js、css 甚至图片、字体，都会出现在浏览器中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> SmartBox = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@mtfe/smart-box&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> IndexPage = React.createClass(&#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">SmartBox</span> <span class=\"attr\">keyword</span>=<span class=\"string\">&#123;</span> <span class=\"attr\">this.props.keyword</span> &#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Header</span>&gt;</span></span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = IndexPage;</span><br></pre></td></tr></table></figure>\n\n<p>整体思路和组件化 1.0 如出一辙，却又那么不同。</p>\n<h4 id=\"Turbo\"><a href=\"#Turbo\" class=\"headerlink\" title=\"Turbo\"></a>Turbo</h4><p>单单解决分发和打包的问题还不够，业务开发过程如果变得繁琐、难以 Debug、性能低下的话，恐怕不会受到工程师欢迎。</p>\n<p>为了解决这些问题，我们在 Node 框架的基础上，提供了一系列中间件和开发工具，逐步构建对组件友好的前端工程化方案 Turbo。主要有：</p>\n<ul>\n<li>支持前后端同构渲染，让用户更早看到内容</li>\n<li>简化 Flux 流程，数据流更加清晰易维护</li>\n<li>引入 ImmutableJS，保证 Store 以外的数据不可变</li>\n<li>采用 cursor 机制，保证数据修改/获取同步</li>\n<li>支持 Hot Module Replacement，改进开发流自动化</li>\n</ul>\n<p>通过这些改进，一线工程师可以方便的使用各种组件，专注在业务本身上。开发框架层面的支持也反过来促进了组件化的发展，大家更乐于使用一系列组件来构建页面功能。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>发现痛点、分析调研、应用改进的解决问题思路在组件化开发实践中不断运用。历经三个大版本的演进，组件化开发模式有效缓解了业务发展带来的复杂度提升的压力，并培养工程师具备小而美的工程思想，形成共建共享的良好氛围。毫无疑问，组件化这种“分而治之”的思想将会长久地影响和促进前端开发模式。我们现在已经准备好，迎接新的机遇和挑战，用技术的不断革新提升工程师的幸福感。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一位计算机前辈曾说过：</p>\n<pre><code>Controlling complexity is the essence of computer programming.\n</code></pre>\n<p>随着前端开发复杂度的日益提升，组件化开发应运而生，并随着 FIS、React 等优秀框架的出现遍地开花。这一过程同样发生在美团，面临业务规模的快速发展和工程师团队的不断扩张，我们历经引入组件化解决资源整合问题、逐步增强组件功能促进开发效率、重新打造新一代组件化方案适应全栈开发和共享共建等阶段，努力“controlling complexity”。本文将介绍我们组件化开发的实践过程。</p>\n<h3 id=\"组件化-1-0：资源重组\"><a href=\"#组件化-1-0：资源重组\" class=\"headerlink\" title=\"组件化 1.0：资源重组\"></a>组件化 1.0：资源重组</h3><p>在美团早期，前端资源是按照页面或者类似业务页面集合的形式进行组织的。例如 order.js 对应订单相关页面的交互，account.css 对应账户相关页面的样式。这种方式在过去的较长一段时间内，持续支撑了整个项目的正常推进，功勋卓著。</p>\n<center><img src=\"/images/frontend-component-practice/legacy-flow.png\" alt=\"legacy-flow\" width=\"500\"></center>\n\n\n<p>随着业务规模的增加和开发团队的扩张，这套机制逐渐显示出它的一些不足：</p>\n<ol>\n<li><strong>资源冗余</strong>\n页面的逐渐增加，交互的逐渐复杂化，导致对应的 css 和 js 都有大幅度增长，进而出现为了依赖某个 js 中的一个函数，需要加载整个模块，或者为了使用某个 css 中的部分样式依赖整个 css，冗余资源较多</li>\n<li><strong>对应关系不直观</strong>\n没有显而易见的对应规则，导致的一个问题是修改某个业务模块的 css 或者 js 时，几乎只能依靠 grep。靠人来维护页面模块 html、css 和 js 之间的依赖关系，容易犯错，常常出现内容已经删除但是 css 或 js 还存在的问题</li>\n<li><strong>难于单元测试</strong>\n以页面为最小粒度进行资源整合，不同功能的业务模块相互影响，复杂度太高，自动化测试难以推进</li>\n</ol>\n<p>2013 年开始，在调研了 FIS、BEM 等方案之后，结合美团开发框架的实际，我们初步实现了一套轻量级的组件化开发方案。主要的改进是：</p>\n<ul>\n<li>以页面功能组件为单位聚合前端资源</li>\n<li>自动加载符合约定的 css、js 资源</li>\n<li>将业务数据到渲染数据的转换过程独立出来</li>\n</ul>\n<center><img src=\"/images/frontend-component-practice/component-flow.png\" alt=\"component-flow\" width=\"500\"></center>\n\n<p>举例来说，美团顶部的搜索框就被实现为一个组件。</p>\n<center><img src=\"/images/frontend-component-practice/smart-box.png\" alt=\"smart-box\" width=\"500\"></center>","more":"<p>代码构成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www/component/smart-box/</span><br><span class=\"line\">├── smart-box.js    <span class=\"comment\"># 交互</span></span><br><span class=\"line\">├── smart-box.php   <span class=\"comment\"># 渲染数据生产、组件配置</span></span><br><span class=\"line\">├── smart-box.scss  <span class=\"comment\"># 样式</span></span><br><span class=\"line\">├── smart-box.tpl   <span class=\"comment\"># 内容</span></span><br><span class=\"line\">└── <span class=\"built_in\">test</span></span><br><span class=\"line\">    ├── default.js  <span class=\"comment\"># 自动化测试</span></span><br><span class=\"line\">    └── default.php <span class=\"comment\"># 单测页面</span></span><br></pre></td></tr></table></figure>\n\n<p>调用组件变得十足简单：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span> View::useComponent(<span class=\"string\">&#x27;smart-box&#x27;</span>, [</span><br><span class=\"line\">    <span class=\"string\">&#x27;keyword&#x27;</span> =&gt; <span class=\"variable\">$keyword</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>对比之前，可以看到组件化的一些特点：</p>\n<ol>\n<li><strong>按需加载</strong>\n只加载必要的前端资源</li>\n<li><strong>对应关系非常清晰</strong>\n组件所需要的前端资源都在同一目录，职责明确且唯一，对应关系显著</li>\n<li><strong>易于测试</strong>\n组件是具备独立展现和交互的最小单元，可利用 Phantom 等工具自动化测试</li>\n</ol>\n<p>此外，由于前端资源集中进行调度，组件化也为高阶性能优化提供了空间。例如实现组件级别的 BigRender、通过数据分析进行资源的合并加载等等。</p>\n<h3 id=\"组件化-2-0：趋于成熟\"><a href=\"#组件化-2-0：趋于成熟\" class=\"headerlink\" title=\"组件化 2.0：趋于成熟\"></a>组件化 2.0：趋于成熟</h3><p>组件化 1.0 上线后，由于简单易用，很快得到工程师的认可，并开始在各项业务中应用起来。新的需求接踵而来，一直持续到 2014 年底，这个阶段我们称之为组件化 2.0。下面介绍下主要的几个改进。</p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p>组件在高内聚的同时，往往需要暴露一些接口供外界调用，从而能够适应复杂的页面需求，例如提交订单页面需要在支付密码组件启动完成后绑定提交时的检查。Web Components、React 等都选择了生命周期事件/方法，我们也是一样。</p>\n<p>组件的生命周期：</p>\n<center><img src=\"/images/frontend-component-practice/component-lifecycle.png\" alt=\"component-lifecycle\" width=\"800\"></center>\n\n<p>一个组件的完整生命周期包括：</p>\n<ul>\n<li>init，初始化组件根节点和配置</li>\n<li>fetch，加载 css 和 js 资源</li>\n<li>render，内容渲染，默认的渲染内容方式是 BigRender</li>\n<li>ready，进行数据绑定等操作</li>\n<li>update，数据更新</li>\n<li>destroy，解除所有事件监听，删除所有组件节点</li>\n</ul>\n<p>组件提供 pause、resume 方法以方便进行生命周期控制。各个阶段使用 Promise 串行进行，异步的管理更清晰。使用自定义语义事件，在修改默认行为、组件间通信上充分利用了 YUI 强大的自定义事件体系，有效降低了开发维护成本。</p>\n<p>举个例子，页面初始化时组件的启动过程实际也是借助生命周期实现的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> afterLoadList = [];</span><br><span class=\"line\">Y.all(<span class=\"string\">&#x27;[data-component]&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> Y.mt.Component(node);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定 init 生命周期事件，在 init 默认行为完成后执行回调</span></span><br><span class=\"line\">    component.after(<span class=\"string\">&#x27;init&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果配置了延迟启动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.config.afterLoad) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 暂停组件生命周期</span></span><br><span class=\"line\">            e.component.pause();</span><br><span class=\"line\">            <span class=\"comment\">// 压入延迟启动数组</span></span><br><span class=\"line\">            afterLoadList.push(e.component);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 开始进入生命周期</span></span><br><span class=\"line\">    component.start();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">Y.on(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在页面 load 事件发生时恢复组件生命周期</span></span><br><span class=\"line\">    afterLoadList.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">        component.resume();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>回过头来看，引入生命周期除了带来扩展性外，更重要的是理顺了组件的各个阶段，有助于更好的理解和运用。</p>\n<h4 id=\"Data-Binding\"><a href=\"#Data-Binding\" class=\"headerlink\" title=\"Data Binding\"></a>Data Binding</h4><p>数据绑定是我们期盼已久的功能，将 View 和 ViewModel 之间的交互自动化无疑会节省工程师的大量时间。在组件化减少关注点和降低复杂度后，实现数据绑定变得更加可能。</p>\n<p>我们最终实现的数据绑定方案主要参考了 Angular，通过在 html 节点上添加特定的属性声明绑定逻辑，js 扫描这些内容并进行相应的渲染和事件绑定。当数据发生变化时，对应的内容全部重新渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;addressList&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">mt-bind-repeat</span>=<span class=\"string\">&quot;addr in addrList&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">mt-bind-html</span>=<span class=\"string\">&quot;addr.text&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">Y.use([<span class=\"string\">&#x27;mt-bind&#x27;</span>, <span class=\"string\">&#x27;mt-scope&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    Y.mt.bind.init(<span class=\"built_in\">document</span>.body);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scope = Y.one(<span class=\"string\">&#x27;.addressList&#x27;</span>).getScope();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将 scope.addrList 设置为一个数组，DOM 上将自动渲染其内容   </span></span></span><br><span class=\"line\"><span class=\"javascript\">    scope.$set(<span class=\"string\">&#x27;addrList&#x27;</span>, [</span></span><br><span class=\"line\"><span class=\"javascript\">        &#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;first address&quot;</span> &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">        &#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;second address&quot;</span> &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    ]);</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用属性声明绑定逻辑的好处是可以同时支持后端渲染，这对于美团团购这样的偏展现型业务是非常必要的，用户可以很快看到页面内容。</p>\n<h4 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h4><p>实现数据绑定后，我们不得不面对另外一个问题：如何协同多个组件间的数据。因为某个组件的数据变化，很有可能引起其他组件的变化。例如当修改购买数量，总金额会变化，而总金额超过 500 后，还需要展示大额消费提醒。</p>\n<p>为了解决这个问题，我们引入了 Flux，使用全局消息总线的思路进行跨组件交互。</p>\n<p>例如因为交互复杂而一直让我们非常头疼的项目购买页，在应用组件 + Flux 重构后，各模块之间的互动更加清晰：</p>\n<center><img src=\"/images/frontend-component-practice/component-flux.png\" alt=\"component-flux\" width=\"600\"></center>\n\n<p>其他方面的改进还有很多，包括引入模板引擎 LightnCandy 约束模板逻辑、支持组件任意嵌套、支持异步加载并自动初始化等。</p>\n<p>随着组件化 2.0 的逐步完善，基本已经可以从容应对日常开发，在效率和质量方面都上了一个台阶。</p>\n<h3 id=\"组件化-3-0：重启征程\"><a href=\"#组件化-3-0：重启征程\" class=\"headerlink\" title=\"组件化 3.0：重启征程\"></a>组件化 3.0：重启征程</h3><p>时间的车轮滚滚前行，2014 年底，我们遇到一些新的机遇和挑战：</p>\n<ul>\n<li>基于 Node 的全栈开发模式开始应用，前后端渲染有了更多的可能性</li>\n<li>YUI 停止维护，需要一套新的资源管理方案</li>\n<li>新业务不断增加，需要找到一种组件共享的方式，避免重复造轮子</li>\n</ul>\n<p>结合之前的实践，以及在这一过程中逐渐积累的对业内方案的认知，我们提出了新的组件化方案：</p>\n<ul>\n<li>基于 React 开发页面组件，使用 NPM 进行分发，方便共建共享</li>\n<li>基于 Browserify 二次开发，建设资源打包工具 Reduce，方便浏览器加载</li>\n<li>建设适应组件化开发模式的工程化开发方案 Turbo，方便工程师将组件应用于业务开发中</li>\n</ul>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>在组件化 2.0 的过程中，我们发现很多功能和 React 重合，例如 Data Binding、Lifecycle、前后端渲染，甚至直接借鉴的 Flux。除此之外，React 的函数式编程思想、增量更新、兼容性良好的事件体系也让我们非常向往。借着前端全栈开发的契机，我们开始考虑基于 React 进行组件化 3.0 的建设。</p>\n<h4 id=\"NPM-Reduce\"><a href=\"#NPM-Reduce\" class=\"headerlink\" title=\"NPM + Reduce\"></a>NPM + Reduce</h4><p>NPM + Reduce 构成了我们新的资源管理方案，其中：</p>\n<ul>\n<li>NPM 负责组件的发布和安装。可以认为是“分”的过程，粒度越小，重用的可能性越大</li>\n<li>Reduce 负责将页面资源进行打包。可以认为是“合”的过程，让浏览器更快地加载</li>\n</ul>\n<p>一个典型的组件包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smart-box/</span><br><span class=\"line\">├── package.json    <span class=\"comment\"># 组件包元信息</span></span><br><span class=\"line\">├── smart-box.jsx   <span class=\"comment\"># React Component</span></span><br><span class=\"line\">├── smart-box.scss  <span class=\"comment\"># 样式</span></span><br><span class=\"line\">└── <span class=\"built_in\">test</span></span><br><span class=\"line\">    └── main.js     <span class=\"comment\"># 测试</span></span><br></pre></td></tr></table></figure>\n\n<p>NPM 默认只支持 js 文件的管理，我们对 NPM 中的 package.json 进行了扩展，增加了 style 字段，以使打包工具 Reduce 也能够对 css 和 css 中引用的 image、font 进行识别和处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;style&quot;</span>: <span class=\"string\">&quot;./smart-box.scss&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要在页面中 require 了 smart-box，经过 Reduce 打包后，js、css 甚至图片、字体，都会出现在浏览器中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> SmartBox = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@mtfe/smart-box&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> IndexPage = React.createClass(&#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">SmartBox</span> <span class=\"attr\">keyword</span>=<span class=\"string\">&#123;</span> <span class=\"attr\">this.props.keyword</span> &#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Header</span>&gt;</span></span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = IndexPage;</span><br></pre></td></tr></table></figure>\n\n<p>整体思路和组件化 1.0 如出一辙，却又那么不同。</p>\n<h4 id=\"Turbo\"><a href=\"#Turbo\" class=\"headerlink\" title=\"Turbo\"></a>Turbo</h4><p>单单解决分发和打包的问题还不够，业务开发过程如果变得繁琐、难以 Debug、性能低下的话，恐怕不会受到工程师欢迎。</p>\n<p>为了解决这些问题，我们在 Node 框架的基础上，提供了一系列中间件和开发工具，逐步构建对组件友好的前端工程化方案 Turbo。主要有：</p>\n<ul>\n<li>支持前后端同构渲染，让用户更早看到内容</li>\n<li>简化 Flux 流程，数据流更加清晰易维护</li>\n<li>引入 ImmutableJS，保证 Store 以外的数据不可变</li>\n<li>采用 cursor 机制，保证数据修改/获取同步</li>\n<li>支持 Hot Module Replacement，改进开发流自动化</li>\n</ul>\n<p>通过这些改进，一线工程师可以方便的使用各种组件，专注在业务本身上。开发框架层面的支持也反过来促进了组件化的发展，大家更乐于使用一系列组件来构建页面功能。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>发现痛点、分析调研、应用改进的解决问题思路在组件化开发实践中不断运用。历经三个大版本的演进，组件化开发模式有效缓解了业务发展带来的复杂度提升的压力，并培养工程师具备小而美的工程思想，形成共建共享的良好氛围。毫无疑问，组件化这种“分而治之”的思想将会长久地影响和促进前端开发模式。我们现在已经准备好，迎接新的机遇和挑战，用技术的不断革新提升工程师的幸福感。</p>"},{"layout":"post","title":"前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete","date":"2022-03-21T11:34:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete](https://zhuanlan.zhihu.com/p/473437861) 查看全文。\n\n\n","source":"_posts/frontend-frp-2nd.md","raw":"---\nlayout: post\ntitle: \"前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete\"\ndate: 2022-03-21 19:34:00\nstatus: publish\ntags: [Functional Programming, Functional Reactive Programming, RxJS]\n---\n\n请移步知乎“前端之美”专栏 [前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete](https://zhuanlan.zhihu.com/p/473437861) 查看全文。\n\n\n","slug":"frontend-frp-2nd","published":1,"updated":"2022-03-26T03:33:13.290Z","comments":1,"photos":[],"link":"","_id":"cl1klgupl000p8e854cfq5w0p","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/473437861\">前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/473437861\">前端中的 Functional Reactive Programming（二）- 进阶版 AutoComplete</a> 查看全文。</p>\n"},{"layout":"post","title":"Hire Slow","date":"2022-04-04T00:51:04.000Z","status":"publish","_content":"\n我曾亲眼见证过这样一个事情：\n\n一个内部工具团队，因为业务增长太快压力山大，某个时间点 lead 在招聘方面做出了妥协，放水招进来一个看起来还凑合的工程师。\n过了一小段时间，团队里其他人慢慢开始离职。有几个是我非常熟悉的伙伴，平时跟他们沟通不少，大家普遍的一些感触是：我怎么和这样的人一起工作。\n再后来，团队雪崩式解散，部门领导不得不抽调其他资源维系业务运转。\n\n有一次我也跟原来的 lead 闲聊，当谈到为什么当初招那个人的时候，他坦言：业务太多了，内部服务开发又不招人喜欢，没办法。\n\n这些年来，随着团队管理经验的逐步积累，我越来越意识到师傅曾经教给我们的那句话的重要性：“Hire slow，fire fast”。今天我们就先聊一下前半句：Hire slow。\n\n<!--more-->\n\n\n## 业务压力大 => 不得不降低标准招人？\n\n这是一个很自然的想法，没有人就没有资源迭代旧服务和开发新服务，要不然怎么办？\n\n问题就在于这儿，作为团队负责人，切忌**把自己逼得只有一个选择**。\n\n认真思考下，真的就没有别的办法了吗？譬如，是否可以尝试：\n\n- 开源\n  - 跟上级 lead 充分沟通，争取临时借调兄弟组资源等方式\n  - 请求倾斜招聘资源，并推动内推、猎头等多种形式举荐人才\n  - 尝试引入外包或者临时工等外部资源\n- 节流\n  - 精简需求，把钢用到刀刃上\n  - 采购 SaaS 服务或者基于成熟开源方案快速开发\n- 提效\n  - 培养团队成员的核心技能，重点是开发能力和沟通能力，让他们成长更为快速一些，早日担当大任\n  - 积累可复用的方案、框架、中间件等，提升工程效率\n\n这里只是列出一些可能的办法，实际大家可能还能想出更多。\n\n其实 lead 除了在开源节流方面做得不是很理想外，还有一个认知上的误区：\n\n> 内部服务开发又不招人喜欢\n\n也许他本心也是这么认为的，但笔者不敢苟同。\n内部系统确实有一定的局限性：用户少，需求杂，工期短，反馈多。\n基本都是围绕 CRUD，做得好没人说，有问题挨批评，经常吃力不讨好。这些都是现实问题。\n\n但跳出这个层面来看，内部系统其实某种程度上是公司成败的“秘密武器”：\n\n\n- 内部系统对于降本增效有极大的促进作用\n  <p style=\"margin: 0 0 0.2rem 1.4rem\">\n  一个好用的内部系统，实际上是围绕组织结构来深度定制的，取舍得当的话，往往可以对业务和组织的不断演进产生深远影响。\n美团早期在快速上单方面做的一系列结构化深度改进让整个运营团队的效率提升了一大截，成功在千团大战等激烈竞争中脱颖而出。\n  </p>\n- 内部系统可以充分挖掘用户、业务的痛点，以及大家的正向反馈\n  <p style=\"margin: 0 0 0.2rem 1.4rem\">\n  用户可以轻易触达，业务也比较方便深入调研，这都是难得的差异化优势。另外，lead 要去注意抓一些用户或者数据方面的正向反馈，\n  以此来给团队带来更多荣誉感和正向激励，让大家明白自己做的事情的价值\n  </p>\n\n类似人的五官一样，没有哪个是可以或缺的，内部系统也很重要，让团队理解自己团队的价值是 lead 的最为重要的职责之一。\n\n\n## 降低标准招人的后果\n\n那实在是没有办法的情况下，不得不降低标准招人的话，会有什么后果呢？\n\nNetflix 创始人 Hastings 在“不拘一格”一书中提到了平庸的工程师带来的一些负面影响：\n\n- 消耗管理者的精力，使他们没有时间把精力放在优秀员工身上\n- 团队讨论的质量得不到保证，拉低团队整体智商\n- 强迫他人国绕着他们开展工作，致使工作效率低下\n- 排挤其他追求卓越的员工\n- 向团队表明你接受平庸，从而使问题更加严重\n\n最大的问题在于：劣币驱除良币，其他的优秀工程师其实并不缺乏好机会，一旦他们确信团队水平在逐渐变差，那么离开是迟早的事。\n长此以往，团队只剩下一群次等工程师，交付能力愈加堪忧，撤职跑路也就为时不远了。\n\n因此，原则上，绝不能优先考虑在招聘标准方面做出让步，这应该是所有尝试都失败的情况下才不得已而为之，仅限于短期手段的无奈之举。\n\n\n## 招聘速度过快还有更多问题\n\nHire slow 除了说不要降低标准招人以外，还有一个内涵就是：不要招聘过快。\n\n初听起来这是反直觉的，业务发展快，团队招人也很顺利，那么快速招兵买马应当是自然之举。\n但事实并不是这样，和机器可以轻易水平扩容不同，工程师毕竟是人，平时工作的相当比例的时间其实是在沟通协作，扩张过快容易产生一系列问题：\n\n- 没有足够资源指导新人适应团队，任其自生自灭导致成长不稳定\n- 过分多样化的人员背景导致内耗加大，很多项目推进效率低下，争论不已\n- 团队优秀文化迅速稀释，认同感凝聚感逐步淡化\n\n正如 Brooks 在“人月神话”中提到的，粗暴加人对于项目进度有可能是负面而非正面影响。\n\n建设团队，需要“结硬寨，打呆仗”，稳扎稳打，才能在永葆精华的同时，有序提升组织能力。\n","source":"_posts/hire-slow.md","raw":"---\nlayout: post\ntitle: \"Hire Slow\"\ndate: 2022-04-04 08:51:04\nstatus: publish\ntags:\n  - Recruitment\n  - Organization\n---\n\n我曾亲眼见证过这样一个事情：\n\n一个内部工具团队，因为业务增长太快压力山大，某个时间点 lead 在招聘方面做出了妥协，放水招进来一个看起来还凑合的工程师。\n过了一小段时间，团队里其他人慢慢开始离职。有几个是我非常熟悉的伙伴，平时跟他们沟通不少，大家普遍的一些感触是：我怎么和这样的人一起工作。\n再后来，团队雪崩式解散，部门领导不得不抽调其他资源维系业务运转。\n\n有一次我也跟原来的 lead 闲聊，当谈到为什么当初招那个人的时候，他坦言：业务太多了，内部服务开发又不招人喜欢，没办法。\n\n这些年来，随着团队管理经验的逐步积累，我越来越意识到师傅曾经教给我们的那句话的重要性：“Hire slow，fire fast”。今天我们就先聊一下前半句：Hire slow。\n\n<!--more-->\n\n\n## 业务压力大 => 不得不降低标准招人？\n\n这是一个很自然的想法，没有人就没有资源迭代旧服务和开发新服务，要不然怎么办？\n\n问题就在于这儿，作为团队负责人，切忌**把自己逼得只有一个选择**。\n\n认真思考下，真的就没有别的办法了吗？譬如，是否可以尝试：\n\n- 开源\n  - 跟上级 lead 充分沟通，争取临时借调兄弟组资源等方式\n  - 请求倾斜招聘资源，并推动内推、猎头等多种形式举荐人才\n  - 尝试引入外包或者临时工等外部资源\n- 节流\n  - 精简需求，把钢用到刀刃上\n  - 采购 SaaS 服务或者基于成熟开源方案快速开发\n- 提效\n  - 培养团队成员的核心技能，重点是开发能力和沟通能力，让他们成长更为快速一些，早日担当大任\n  - 积累可复用的方案、框架、中间件等，提升工程效率\n\n这里只是列出一些可能的办法，实际大家可能还能想出更多。\n\n其实 lead 除了在开源节流方面做得不是很理想外，还有一个认知上的误区：\n\n> 内部服务开发又不招人喜欢\n\n也许他本心也是这么认为的，但笔者不敢苟同。\n内部系统确实有一定的局限性：用户少，需求杂，工期短，反馈多。\n基本都是围绕 CRUD，做得好没人说，有问题挨批评，经常吃力不讨好。这些都是现实问题。\n\n但跳出这个层面来看，内部系统其实某种程度上是公司成败的“秘密武器”：\n\n\n- 内部系统对于降本增效有极大的促进作用\n  <p style=\"margin: 0 0 0.2rem 1.4rem\">\n  一个好用的内部系统，实际上是围绕组织结构来深度定制的，取舍得当的话，往往可以对业务和组织的不断演进产生深远影响。\n美团早期在快速上单方面做的一系列结构化深度改进让整个运营团队的效率提升了一大截，成功在千团大战等激烈竞争中脱颖而出。\n  </p>\n- 内部系统可以充分挖掘用户、业务的痛点，以及大家的正向反馈\n  <p style=\"margin: 0 0 0.2rem 1.4rem\">\n  用户可以轻易触达，业务也比较方便深入调研，这都是难得的差异化优势。另外，lead 要去注意抓一些用户或者数据方面的正向反馈，\n  以此来给团队带来更多荣誉感和正向激励，让大家明白自己做的事情的价值\n  </p>\n\n类似人的五官一样，没有哪个是可以或缺的，内部系统也很重要，让团队理解自己团队的价值是 lead 的最为重要的职责之一。\n\n\n## 降低标准招人的后果\n\n那实在是没有办法的情况下，不得不降低标准招人的话，会有什么后果呢？\n\nNetflix 创始人 Hastings 在“不拘一格”一书中提到了平庸的工程师带来的一些负面影响：\n\n- 消耗管理者的精力，使他们没有时间把精力放在优秀员工身上\n- 团队讨论的质量得不到保证，拉低团队整体智商\n- 强迫他人国绕着他们开展工作，致使工作效率低下\n- 排挤其他追求卓越的员工\n- 向团队表明你接受平庸，从而使问题更加严重\n\n最大的问题在于：劣币驱除良币，其他的优秀工程师其实并不缺乏好机会，一旦他们确信团队水平在逐渐变差，那么离开是迟早的事。\n长此以往，团队只剩下一群次等工程师，交付能力愈加堪忧，撤职跑路也就为时不远了。\n\n因此，原则上，绝不能优先考虑在招聘标准方面做出让步，这应该是所有尝试都失败的情况下才不得已而为之，仅限于短期手段的无奈之举。\n\n\n## 招聘速度过快还有更多问题\n\nHire slow 除了说不要降低标准招人以外，还有一个内涵就是：不要招聘过快。\n\n初听起来这是反直觉的，业务发展快，团队招人也很顺利，那么快速招兵买马应当是自然之举。\n但事实并不是这样，和机器可以轻易水平扩容不同，工程师毕竟是人，平时工作的相当比例的时间其实是在沟通协作，扩张过快容易产生一系列问题：\n\n- 没有足够资源指导新人适应团队，任其自生自灭导致成长不稳定\n- 过分多样化的人员背景导致内耗加大，很多项目推进效率低下，争论不已\n- 团队优秀文化迅速稀释，认同感凝聚感逐步淡化\n\n正如 Brooks 在“人月神话”中提到的，粗暴加人对于项目进度有可能是负面而非正面影响。\n\n建设团队，需要“结硬寨，打呆仗”，稳扎稳打，才能在永葆精华的同时，有序提升组织能力。\n","slug":"hire-slow","published":1,"updated":"2022-04-04T10:46:27.654Z","comments":1,"photos":[],"link":"","_id":"cl1klgupl000q8e85e1rk0lh1","content":"<p>我曾亲眼见证过这样一个事情：</p>\n<p>一个内部工具团队，因为业务增长太快压力山大，某个时间点 lead 在招聘方面做出了妥协，放水招进来一个看起来还凑合的工程师。\n过了一小段时间，团队里其他人慢慢开始离职。有几个是我非常熟悉的伙伴，平时跟他们沟通不少，大家普遍的一些感触是：我怎么和这样的人一起工作。\n再后来，团队雪崩式解散，部门领导不得不抽调其他资源维系业务运转。</p>\n<p>有一次我也跟原来的 lead 闲聊，当谈到为什么当初招那个人的时候，他坦言：业务太多了，内部服务开发又不招人喜欢，没办法。</p>\n<p>这些年来，随着团队管理经验的逐步积累，我越来越意识到师傅曾经教给我们的那句话的重要性：“Hire slow，fire fast”。今天我们就先聊一下前半句：Hire slow。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"业务压力大-gt-不得不降低标准招人？\"><a href=\"#业务压力大-gt-不得不降低标准招人？\" class=\"headerlink\" title=\"业务压力大 =&gt; 不得不降低标准招人？\"></a>业务压力大 =&gt; 不得不降低标准招人？</h2><p>这是一个很自然的想法，没有人就没有资源迭代旧服务和开发新服务，要不然怎么办？</p>\n<p>问题就在于这儿，作为团队负责人，切忌<strong>把自己逼得只有一个选择</strong>。</p>\n<p>认真思考下，真的就没有别的办法了吗？譬如，是否可以尝试：</p>\n<ul>\n<li>开源<ul>\n<li>跟上级 lead 充分沟通，争取临时借调兄弟组资源等方式</li>\n<li>请求倾斜招聘资源，并推动内推、猎头等多种形式举荐人才</li>\n<li>尝试引入外包或者临时工等外部资源</li>\n</ul>\n</li>\n<li>节流<ul>\n<li>精简需求，把钢用到刀刃上</li>\n<li>采购 SaaS 服务或者基于成熟开源方案快速开发</li>\n</ul>\n</li>\n<li>提效<ul>\n<li>培养团队成员的核心技能，重点是开发能力和沟通能力，让他们成长更为快速一些，早日担当大任</li>\n<li>积累可复用的方案、框架、中间件等，提升工程效率</li>\n</ul>\n</li>\n</ul>\n<p>这里只是列出一些可能的办法，实际大家可能还能想出更多。</p>\n<p>其实 lead 除了在开源节流方面做得不是很理想外，还有一个认知上的误区：</p>\n<blockquote>\n<p>内部服务开发又不招人喜欢</p>\n</blockquote>\n<p>也许他本心也是这么认为的，但笔者不敢苟同。\n内部系统确实有一定的局限性：用户少，需求杂，工期短，反馈多。\n基本都是围绕 CRUD，做得好没人说，有问题挨批评，经常吃力不讨好。这些都是现实问题。</p>\n<p>但跳出这个层面来看，内部系统其实某种程度上是公司成败的“秘密武器”：</p>\n<ul>\n<li>内部系统对于降本增效有极大的促进作用<p style=\"margin: 0 0 0.2rem 1.4rem\">\n一个好用的内部系统，实际上是围绕组织结构来深度定制的，取舍得当的话，往往可以对业务和组织的不断演进产生深远影响。\n美团早期在快速上单方面做的一系列结构化深度改进让整个运营团队的效率提升了一大截，成功在千团大战等激烈竞争中脱颖而出。\n</p></li>\n<li>内部系统可以充分挖掘用户、业务的痛点，以及大家的正向反馈<p style=\"margin: 0 0 0.2rem 1.4rem\">\n用户可以轻易触达，业务也比较方便深入调研，这都是难得的差异化优势。另外，lead 要去注意抓一些用户或者数据方面的正向反馈，\n以此来给团队带来更多荣誉感和正向激励，让大家明白自己做的事情的价值\n</p></li>\n</ul>\n<p>类似人的五官一样，没有哪个是可以或缺的，内部系统也很重要，让团队理解自己团队的价值是 lead 的最为重要的职责之一。</p>\n<h2 id=\"降低标准招人的后果\"><a href=\"#降低标准招人的后果\" class=\"headerlink\" title=\"降低标准招人的后果\"></a>降低标准招人的后果</h2><p>那实在是没有办法的情况下，不得不降低标准招人的话，会有什么后果呢？</p>\n<p>Netflix 创始人 Hastings 在“不拘一格”一书中提到了平庸的工程师带来的一些负面影响：</p>\n<ul>\n<li>消耗管理者的精力，使他们没有时间把精力放在优秀员工身上</li>\n<li>团队讨论的质量得不到保证，拉低团队整体智商</li>\n<li>强迫他人国绕着他们开展工作，致使工作效率低下</li>\n<li>排挤其他追求卓越的员工</li>\n<li>向团队表明你接受平庸，从而使问题更加严重</li>\n</ul>\n<p>最大的问题在于：劣币驱除良币，其他的优秀工程师其实并不缺乏好机会，一旦他们确信团队水平在逐渐变差，那么离开是迟早的事。\n长此以往，团队只剩下一群次等工程师，交付能力愈加堪忧，撤职跑路也就为时不远了。</p>\n<p>因此，原则上，绝不能优先考虑在招聘标准方面做出让步，这应该是所有尝试都失败的情况下才不得已而为之，仅限于短期手段的无奈之举。</p>\n<h2 id=\"招聘速度过快还有更多问题\"><a href=\"#招聘速度过快还有更多问题\" class=\"headerlink\" title=\"招聘速度过快还有更多问题\"></a>招聘速度过快还有更多问题</h2><p>Hire slow 除了说不要降低标准招人以外，还有一个内涵就是：不要招聘过快。</p>\n<p>初听起来这是反直觉的，业务发展快，团队招人也很顺利，那么快速招兵买马应当是自然之举。\n但事实并不是这样，和机器可以轻易水平扩容不同，工程师毕竟是人，平时工作的相当比例的时间其实是在沟通协作，扩张过快容易产生一系列问题：</p>\n<ul>\n<li>没有足够资源指导新人适应团队，任其自生自灭导致成长不稳定</li>\n<li>过分多样化的人员背景导致内耗加大，很多项目推进效率低下，争论不已</li>\n<li>团队优秀文化迅速稀释，认同感凝聚感逐步淡化</li>\n</ul>\n<p>正如 Brooks 在“人月神话”中提到的，粗暴加人对于项目进度有可能是负面而非正面影响。</p>\n<p>建设团队，需要“结硬寨，打呆仗”，稳扎稳打，才能在永葆精华的同时，有序提升组织能力。</p>\n","site":{"data":{}},"excerpt":"<p>我曾亲眼见证过这样一个事情：</p>\n<p>一个内部工具团队，因为业务增长太快压力山大，某个时间点 lead 在招聘方面做出了妥协，放水招进来一个看起来还凑合的工程师。\n过了一小段时间，团队里其他人慢慢开始离职。有几个是我非常熟悉的伙伴，平时跟他们沟通不少，大家普遍的一些感触是：我怎么和这样的人一起工作。\n再后来，团队雪崩式解散，部门领导不得不抽调其他资源维系业务运转。</p>\n<p>有一次我也跟原来的 lead 闲聊，当谈到为什么当初招那个人的时候，他坦言：业务太多了，内部服务开发又不招人喜欢，没办法。</p>\n<p>这些年来，随着团队管理经验的逐步积累，我越来越意识到师傅曾经教给我们的那句话的重要性：“Hire slow，fire fast”。今天我们就先聊一下前半句：Hire slow。</p>","more":"<h2 id=\"业务压力大-gt-不得不降低标准招人？\"><a href=\"#业务压力大-gt-不得不降低标准招人？\" class=\"headerlink\" title=\"业务压力大 =&gt; 不得不降低标准招人？\"></a>业务压力大 =&gt; 不得不降低标准招人？</h2><p>这是一个很自然的想法，没有人就没有资源迭代旧服务和开发新服务，要不然怎么办？</p>\n<p>问题就在于这儿，作为团队负责人，切忌<strong>把自己逼得只有一个选择</strong>。</p>\n<p>认真思考下，真的就没有别的办法了吗？譬如，是否可以尝试：</p>\n<ul>\n<li>开源<ul>\n<li>跟上级 lead 充分沟通，争取临时借调兄弟组资源等方式</li>\n<li>请求倾斜招聘资源，并推动内推、猎头等多种形式举荐人才</li>\n<li>尝试引入外包或者临时工等外部资源</li>\n</ul>\n</li>\n<li>节流<ul>\n<li>精简需求，把钢用到刀刃上</li>\n<li>采购 SaaS 服务或者基于成熟开源方案快速开发</li>\n</ul>\n</li>\n<li>提效<ul>\n<li>培养团队成员的核心技能，重点是开发能力和沟通能力，让他们成长更为快速一些，早日担当大任</li>\n<li>积累可复用的方案、框架、中间件等，提升工程效率</li>\n</ul>\n</li>\n</ul>\n<p>这里只是列出一些可能的办法，实际大家可能还能想出更多。</p>\n<p>其实 lead 除了在开源节流方面做得不是很理想外，还有一个认知上的误区：</p>\n<blockquote>\n<p>内部服务开发又不招人喜欢</p>\n</blockquote>\n<p>也许他本心也是这么认为的，但笔者不敢苟同。\n内部系统确实有一定的局限性：用户少，需求杂，工期短，反馈多。\n基本都是围绕 CRUD，做得好没人说，有问题挨批评，经常吃力不讨好。这些都是现实问题。</p>\n<p>但跳出这个层面来看，内部系统其实某种程度上是公司成败的“秘密武器”：</p>\n<ul>\n<li>内部系统对于降本增效有极大的促进作用<p style=\"margin: 0 0 0.2rem 1.4rem\">\n一个好用的内部系统，实际上是围绕组织结构来深度定制的，取舍得当的话，往往可以对业务和组织的不断演进产生深远影响。\n美团早期在快速上单方面做的一系列结构化深度改进让整个运营团队的效率提升了一大截，成功在千团大战等激烈竞争中脱颖而出。\n</p></li>\n<li>内部系统可以充分挖掘用户、业务的痛点，以及大家的正向反馈<p style=\"margin: 0 0 0.2rem 1.4rem\">\n用户可以轻易触达，业务也比较方便深入调研，这都是难得的差异化优势。另外，lead 要去注意抓一些用户或者数据方面的正向反馈，\n以此来给团队带来更多荣誉感和正向激励，让大家明白自己做的事情的价值\n</p></li>\n</ul>\n<p>类似人的五官一样，没有哪个是可以或缺的，内部系统也很重要，让团队理解自己团队的价值是 lead 的最为重要的职责之一。</p>\n<h2 id=\"降低标准招人的后果\"><a href=\"#降低标准招人的后果\" class=\"headerlink\" title=\"降低标准招人的后果\"></a>降低标准招人的后果</h2><p>那实在是没有办法的情况下，不得不降低标准招人的话，会有什么后果呢？</p>\n<p>Netflix 创始人 Hastings 在“不拘一格”一书中提到了平庸的工程师带来的一些负面影响：</p>\n<ul>\n<li>消耗管理者的精力，使他们没有时间把精力放在优秀员工身上</li>\n<li>团队讨论的质量得不到保证，拉低团队整体智商</li>\n<li>强迫他人国绕着他们开展工作，致使工作效率低下</li>\n<li>排挤其他追求卓越的员工</li>\n<li>向团队表明你接受平庸，从而使问题更加严重</li>\n</ul>\n<p>最大的问题在于：劣币驱除良币，其他的优秀工程师其实并不缺乏好机会，一旦他们确信团队水平在逐渐变差，那么离开是迟早的事。\n长此以往，团队只剩下一群次等工程师，交付能力愈加堪忧，撤职跑路也就为时不远了。</p>\n<p>因此，原则上，绝不能优先考虑在招聘标准方面做出让步，这应该是所有尝试都失败的情况下才不得已而为之，仅限于短期手段的无奈之举。</p>\n<h2 id=\"招聘速度过快还有更多问题\"><a href=\"#招聘速度过快还有更多问题\" class=\"headerlink\" title=\"招聘速度过快还有更多问题\"></a>招聘速度过快还有更多问题</h2><p>Hire slow 除了说不要降低标准招人以外，还有一个内涵就是：不要招聘过快。</p>\n<p>初听起来这是反直觉的，业务发展快，团队招人也很顺利，那么快速招兵买马应当是自然之举。\n但事实并不是这样，和机器可以轻易水平扩容不同，工程师毕竟是人，平时工作的相当比例的时间其实是在沟通协作，扩张过快容易产生一系列问题：</p>\n<ul>\n<li>没有足够资源指导新人适应团队，任其自生自灭导致成长不稳定</li>\n<li>过分多样化的人员背景导致内耗加大，很多项目推进效率低下，争论不已</li>\n<li>团队优秀文化迅速稀释，认同感凝聚感逐步淡化</li>\n</ul>\n<p>正如 Brooks 在“人月神话”中提到的，粗暴加人对于项目进度有可能是负面而非正面影响。</p>\n<p>建设团队，需要“结硬寨，打呆仗”，稳扎稳打，才能在永葆精华的同时，有序提升组织能力。</p>"},{"layout":"post","title":"前端中的 Functional Reactive Programming","date":"2022-01-18T02:10:23.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [前端中的 Functional Reactive Programming](https://zhuanlan.zhihu.com/p/77687564) 查看全文。\n","source":"_posts/frontend-frp.md","raw":"---\nlayout: post\ntitle: \"前端中的 Functional Reactive Programming\"\ndate: 2022-01-18 10:10:23\nstatus: publish\ntags: [Functional Programming, Functional Reactive Programming, RxJS]\n---\n\n请移步知乎“前端之美”专栏 [前端中的 Functional Reactive Programming](https://zhuanlan.zhihu.com/p/77687564) 查看全文。\n","slug":"frontend-frp","published":1,"updated":"2022-01-19T13:23:16.603Z","comments":1,"photos":[],"link":"","_id":"cl1klgupm000s8e85doqv6ewz","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/77687564\">前端中的 Functional Reactive Programming</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/77687564\">前端中的 Functional Reactive Programming</a> 查看全文。</p>\n"},{"layout":"post","title":"Javascript核心概念","date":"2011-12-28T15:49:00.000Z","status":"publish","_content":"\n<div style=\"text-align: center;\"><iframe src=\"http://www.slideshare.net/slideshow/embed_code/10708244\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" width=\"425\" height=\"355\"></iframe></div>\n\n<div style=\"text-align: center;\"><a href=\"/assets/the-core-of-javascript.key_.zip\">keynote下载</a> | <a href=\"/assets/the-core-of-javascript.pdf.zip\">pdf下载</a></div>\n\n<!-- more -->\n\n## Notes\n\n1. 这次分享一些Javascript或者说ECMAScript中的一些比较基础的知识点。这些东西在我们日常的开发和调试中发挥着非常重要而又容易被忽略的作用。希望这次分享能够让大家有一个更深入的认识。\n\n2. 对于我们所使用的核心技术，我们要做到知其然知其所以然。这是一个非常重要的态度，只有这样，我们才能更好的理解这些技术背后蕴涵的思想，运作机制，以及优点缺陷，才能免于陷入缤纷表现的漩涡，能够做到透过现象看本质。\n\n3. 每个人的精力都是有限的，尤其是我这种愚钝的人，所以，把你的精力放在最值得放的一些地方，而不是处处留芳。\n\n4. 这次我们主要分享这几个知识点：原型链. 构造器. 执行上下文. 变量对象. 作用域链. 闭包和This\n\n5. 对象是一切的基础，我们从这里起步，用一个个对象构建前端的摩天大楼！对象实际非常简单，它就是一个容器，可以以键值对的形式储藏信息，例如姓名. 性别。对象有一个非常重要的内部属性__proto__，指向它的原型对象，以实现方法. 属性的复用或着说继承。\n\n6. 我们写过这样的代码，那它是如何执行的呢？事实上，这里涉及到一个属性查找的问题。[]对象本身没有hasOwnProperty这个方法，于是继续查找__proto__属性指向Array prototype是否有该方法，依然查找失败，于是继续查找Array prototype对象的__proto__属性指向的对象...最终找到Object.prototype上有这个方法，执行的结果为true。每个对象通过__proto__属性与自己的原型对象建立联系，而且这个过程是可以延续的，这就是js里原型链的概念。通过这个例子，我们知道：原型链在JS中的作用是查找对象的属性/方法。\n\n7. 原型链除了方法的复用还有什么作用呢？一个重要的例子就是instanceof操作符。instanceof操作符就是通过判断第二个操作数的原型对象是否在第一个操作数原型链上来进行判别。\n\n8. 接下来的一个疑问是：这些对象是怎么得来的呢？答案是构造器。\n\n9. 构造器，在JS中也就是函数。这里展示下函数的创建过程。这里需要注意的几点是：\n\n    - [[Class]]：因为typeof不准确，现在各个js库都是根据这个属性来判别对象类型的（Object.prototype.toString.call(obj)）\n    - [[Prototype]]：因为函数也是一个对象，所以也有指向自己原型的内部属性\n    - [[Call]]：在执行函数时调用，会产生一个新的执行上下文\n    - [[Construct]]：在函数作为构造器调用时调用（通过new操作符）\n    - [[Scope]]：保存函数的作用域\n    - length：函数期望参数数目\n    - prototype：用来为构造器创建对象设置[[prototype]]\n\n10. 制造对象通过函数对象的内部属性[[Construct]]进行。\n\n    - 创建一个原生对象，这个对象是”纯洁的“\n    - 添加这个原生对象的内部属性[[Class]]，这个属性是用来判定对象类型的\n    - 然后添加这个原生对象的内部属性[[Prototype]]，也记做__proto__\n    - 执行函数对象代码，其中的this设置为刚刚创建的原生对象。记执行代码返回值为R\n    - 如果R为对象，则返回R，否则返回创建的原生对象O\n\n11. 一个简单的例子。\n\n12. 只要记住一点：构造器的prototype属性是用来为创建对象设置__proto__属性的，构造器作为对象也有自身的__proto__属性，指向的是Function.prototype对象。\n\n13. JS中的代码可以划分为三种类型：全局代码. 函数代码和eval代码。eval这个方法我们要尽量少的使用，因为不单有创建一个新解析器的开销，还有安全性方面的问题。\n\n14. 每种类型的代码在执行时都会在相应类型的上下文中，我们称之为执行上下文。\n\n15-31. 这个例子简单展示了执行上下文栈的运行过程。\n\n32. 接下来我们详细了解一下执行上下文。执行上下文也可以理解为一个对象，主要的属性有三个：变量对象. 作用域链和thisValue。\n\n    - 变量对象是一个保存当前代码中所有变量. 函数声明等的对象\n    - 作用域链是由执行上下文的变量对象和所有父级作用域构成的，可以理解为一个数组\n    - thisValue用来指明当前代码中this所代表的值\n\n33. 变量对象根据执行上下文的不同有一些差异:\n\n    - 在全局执行上下文中，变量对象就是全局对象本身，而this也是指向全局对象的，所以它们三个相等。这个特性非常重要，因为我们可以通过访问全局对象来获得变量对象中储存的变量，这也是唯一可以访问变量对象的情形\n    - 在函数执行上下文中，变量对象增加了arguments对象和行参等，这被称为活动对象。我们是不能直接访问到活动对象的\n\n34. 全局变量对象的一个例子。\n\n35. 活动对象的一个例子。注意arguments对象是一个array-like的对象而不是一个array。\n\n36. 代码的执行过程分为两步，首先进入执行上下文，主要是初始化上下文中的三个属性：变量对象. 作用域链和thisValue，然后开始执行代码。\n\n37. 在进入执行上下文阶段，初始化变量对象的过程是非常值得注意，因为在这个过程中，函数中所有形参. 变量声明. 函数声明都会被保存至变量对象中，进而影响作用域链，最终影响到变量的查找。初始化变量分为三步，这其中要注意的是：\n\n    - 所有函数声明都会将函数名添加为变量对象的一个属性，函数对象为该属性的值，所以我们可以将函数定义在任何位置。为了主体逻辑更加清晰，一般我们都将函数声明放在靠后的位置\n    - 所有变量声明的变量名都会作为变量对象的一个属性，其值为undefined。在执行代码阶段，解析器其实不会理会var的。为了防止忘记声明变量，所以建议在函数开始时声明所有局部变量\n    - 变量对象属性之间的覆盖问题。函数声明的函数名可以覆盖之前所有VO属性，变量声明的变量只能覆盖之前的重名变量\n\n38. 声明可以不被覆盖，但是语句仍然会执行。在本例中，形参x没有被变量x覆盖，但执行var x ＝ 10之后x的值仍然会变化。形参y会被函数声明y覆盖。\n\n39. 一个作用域链的例子。\n\n40. 作用域链的几个特性，静态作用域的概念非常重要，函数在声明的时候即已确定自身的作用域链内容([[Scope]])。\n\n41. 闭包实现的基础有两个方面：\n\n    - 函数是一级对象，可以像普通对象一样赋值给变量. 作为函数返回值. 作为参数传递给函数\n    - 函数对象会保存声明时的作用域链，也就是函数具有静态作用域\n\n    这两个特性使得JS中每个函数都是一个闭包，为这种语言增加了无限的变化和魔力。\n\n42. 函数作为返回值，或者称为自底向上的闭包。\n\n43. 函数作为参数，或者称为自上到下的闭包。\n\n44. this在进入执行上下文阶段被赋值，在全局执行上下文中就是全局对象，在函数执行上下文中会随着函数的调用方式不同有所变化。\n\n45. 本文主要参考了Dmitry Soshnikov的ECMA-262-3 in detail系列文章，我本人获益匪浅。\n\n46. 谢谢大家。\n\n## 参考\n\n- [The Core](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)\n- [ECMA-262-3 in detail](http://dmitrysoshnikov.com/tag/ecma-262-3/)\n- [Annotated ECMAScript 5.1](http://es5.github.com/)\n","source":"_posts/javascript-the-core.md","raw":"---\nlayout: post\ntitle: \"Javascript核心概念\"\ndate: 2011-12-28 23:49\nstatus: publish\ntags: [Closure, Execution Context, Prototype Chain]\n---\n\n<div style=\"text-align: center;\"><iframe src=\"http://www.slideshare.net/slideshow/embed_code/10708244\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" width=\"425\" height=\"355\"></iframe></div>\n\n<div style=\"text-align: center;\"><a href=\"/assets/the-core-of-javascript.key_.zip\">keynote下载</a> | <a href=\"/assets/the-core-of-javascript.pdf.zip\">pdf下载</a></div>\n\n<!-- more -->\n\n## Notes\n\n1. 这次分享一些Javascript或者说ECMAScript中的一些比较基础的知识点。这些东西在我们日常的开发和调试中发挥着非常重要而又容易被忽略的作用。希望这次分享能够让大家有一个更深入的认识。\n\n2. 对于我们所使用的核心技术，我们要做到知其然知其所以然。这是一个非常重要的态度，只有这样，我们才能更好的理解这些技术背后蕴涵的思想，运作机制，以及优点缺陷，才能免于陷入缤纷表现的漩涡，能够做到透过现象看本质。\n\n3. 每个人的精力都是有限的，尤其是我这种愚钝的人，所以，把你的精力放在最值得放的一些地方，而不是处处留芳。\n\n4. 这次我们主要分享这几个知识点：原型链. 构造器. 执行上下文. 变量对象. 作用域链. 闭包和This\n\n5. 对象是一切的基础，我们从这里起步，用一个个对象构建前端的摩天大楼！对象实际非常简单，它就是一个容器，可以以键值对的形式储藏信息，例如姓名. 性别。对象有一个非常重要的内部属性__proto__，指向它的原型对象，以实现方法. 属性的复用或着说继承。\n\n6. 我们写过这样的代码，那它是如何执行的呢？事实上，这里涉及到一个属性查找的问题。[]对象本身没有hasOwnProperty这个方法，于是继续查找__proto__属性指向Array prototype是否有该方法，依然查找失败，于是继续查找Array prototype对象的__proto__属性指向的对象...最终找到Object.prototype上有这个方法，执行的结果为true。每个对象通过__proto__属性与自己的原型对象建立联系，而且这个过程是可以延续的，这就是js里原型链的概念。通过这个例子，我们知道：原型链在JS中的作用是查找对象的属性/方法。\n\n7. 原型链除了方法的复用还有什么作用呢？一个重要的例子就是instanceof操作符。instanceof操作符就是通过判断第二个操作数的原型对象是否在第一个操作数原型链上来进行判别。\n\n8. 接下来的一个疑问是：这些对象是怎么得来的呢？答案是构造器。\n\n9. 构造器，在JS中也就是函数。这里展示下函数的创建过程。这里需要注意的几点是：\n\n    - [[Class]]：因为typeof不准确，现在各个js库都是根据这个属性来判别对象类型的（Object.prototype.toString.call(obj)）\n    - [[Prototype]]：因为函数也是一个对象，所以也有指向自己原型的内部属性\n    - [[Call]]：在执行函数时调用，会产生一个新的执行上下文\n    - [[Construct]]：在函数作为构造器调用时调用（通过new操作符）\n    - [[Scope]]：保存函数的作用域\n    - length：函数期望参数数目\n    - prototype：用来为构造器创建对象设置[[prototype]]\n\n10. 制造对象通过函数对象的内部属性[[Construct]]进行。\n\n    - 创建一个原生对象，这个对象是”纯洁的“\n    - 添加这个原生对象的内部属性[[Class]]，这个属性是用来判定对象类型的\n    - 然后添加这个原生对象的内部属性[[Prototype]]，也记做__proto__\n    - 执行函数对象代码，其中的this设置为刚刚创建的原生对象。记执行代码返回值为R\n    - 如果R为对象，则返回R，否则返回创建的原生对象O\n\n11. 一个简单的例子。\n\n12. 只要记住一点：构造器的prototype属性是用来为创建对象设置__proto__属性的，构造器作为对象也有自身的__proto__属性，指向的是Function.prototype对象。\n\n13. JS中的代码可以划分为三种类型：全局代码. 函数代码和eval代码。eval这个方法我们要尽量少的使用，因为不单有创建一个新解析器的开销，还有安全性方面的问题。\n\n14. 每种类型的代码在执行时都会在相应类型的上下文中，我们称之为执行上下文。\n\n15-31. 这个例子简单展示了执行上下文栈的运行过程。\n\n32. 接下来我们详细了解一下执行上下文。执行上下文也可以理解为一个对象，主要的属性有三个：变量对象. 作用域链和thisValue。\n\n    - 变量对象是一个保存当前代码中所有变量. 函数声明等的对象\n    - 作用域链是由执行上下文的变量对象和所有父级作用域构成的，可以理解为一个数组\n    - thisValue用来指明当前代码中this所代表的值\n\n33. 变量对象根据执行上下文的不同有一些差异:\n\n    - 在全局执行上下文中，变量对象就是全局对象本身，而this也是指向全局对象的，所以它们三个相等。这个特性非常重要，因为我们可以通过访问全局对象来获得变量对象中储存的变量，这也是唯一可以访问变量对象的情形\n    - 在函数执行上下文中，变量对象增加了arguments对象和行参等，这被称为活动对象。我们是不能直接访问到活动对象的\n\n34. 全局变量对象的一个例子。\n\n35. 活动对象的一个例子。注意arguments对象是一个array-like的对象而不是一个array。\n\n36. 代码的执行过程分为两步，首先进入执行上下文，主要是初始化上下文中的三个属性：变量对象. 作用域链和thisValue，然后开始执行代码。\n\n37. 在进入执行上下文阶段，初始化变量对象的过程是非常值得注意，因为在这个过程中，函数中所有形参. 变量声明. 函数声明都会被保存至变量对象中，进而影响作用域链，最终影响到变量的查找。初始化变量分为三步，这其中要注意的是：\n\n    - 所有函数声明都会将函数名添加为变量对象的一个属性，函数对象为该属性的值，所以我们可以将函数定义在任何位置。为了主体逻辑更加清晰，一般我们都将函数声明放在靠后的位置\n    - 所有变量声明的变量名都会作为变量对象的一个属性，其值为undefined。在执行代码阶段，解析器其实不会理会var的。为了防止忘记声明变量，所以建议在函数开始时声明所有局部变量\n    - 变量对象属性之间的覆盖问题。函数声明的函数名可以覆盖之前所有VO属性，变量声明的变量只能覆盖之前的重名变量\n\n38. 声明可以不被覆盖，但是语句仍然会执行。在本例中，形参x没有被变量x覆盖，但执行var x ＝ 10之后x的值仍然会变化。形参y会被函数声明y覆盖。\n\n39. 一个作用域链的例子。\n\n40. 作用域链的几个特性，静态作用域的概念非常重要，函数在声明的时候即已确定自身的作用域链内容([[Scope]])。\n\n41. 闭包实现的基础有两个方面：\n\n    - 函数是一级对象，可以像普通对象一样赋值给变量. 作为函数返回值. 作为参数传递给函数\n    - 函数对象会保存声明时的作用域链，也就是函数具有静态作用域\n\n    这两个特性使得JS中每个函数都是一个闭包，为这种语言增加了无限的变化和魔力。\n\n42. 函数作为返回值，或者称为自底向上的闭包。\n\n43. 函数作为参数，或者称为自上到下的闭包。\n\n44. this在进入执行上下文阶段被赋值，在全局执行上下文中就是全局对象，在函数执行上下文中会随着函数的调用方式不同有所变化。\n\n45. 本文主要参考了Dmitry Soshnikov的ECMA-262-3 in detail系列文章，我本人获益匪浅。\n\n46. 谢谢大家。\n\n## 参考\n\n- [The Core](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)\n- [ECMA-262-3 in detail](http://dmitrysoshnikov.com/tag/ecma-262-3/)\n- [Annotated ECMAScript 5.1](http://es5.github.com/)\n","slug":"javascript-the-core","published":1,"updated":"2021-10-04T12:57:16.037Z","comments":1,"photos":[],"link":"","_id":"cl1klgupm000t8e85a5gwhkir","content":"<div style=\"text-align: center;\"><iframe src=\"http://www.slideshare.net/slideshow/embed_code/10708244\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" width=\"425\" height=\"355\"></iframe></div>\n\n<div style=\"text-align: center;\"><a href=\"/assets/the-core-of-javascript.key_.zip\">keynote下载</a> | <a href=\"/assets/the-core-of-javascript.pdf.zip\">pdf下载</a></div>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes\"></a>Notes</h2><ol>\n<li><p>这次分享一些Javascript或者说ECMAScript中的一些比较基础的知识点。这些东西在我们日常的开发和调试中发挥着非常重要而又容易被忽略的作用。希望这次分享能够让大家有一个更深入的认识。</p>\n</li>\n<li><p>对于我们所使用的核心技术，我们要做到知其然知其所以然。这是一个非常重要的态度，只有这样，我们才能更好的理解这些技术背后蕴涵的思想，运作机制，以及优点缺陷，才能免于陷入缤纷表现的漩涡，能够做到透过现象看本质。</p>\n</li>\n<li><p>每个人的精力都是有限的，尤其是我这种愚钝的人，所以，把你的精力放在最值得放的一些地方，而不是处处留芳。</p>\n</li>\n<li><p>这次我们主要分享这几个知识点：原型链. 构造器. 执行上下文. 变量对象. 作用域链. 闭包和This</p>\n</li>\n<li><p>对象是一切的基础，我们从这里起步，用一个个对象构建前端的摩天大楼！对象实际非常简单，它就是一个容器，可以以键值对的形式储藏信息，例如姓名. 性别。对象有一个非常重要的内部属性__proto__，指向它的原型对象，以实现方法. 属性的复用或着说继承。</p>\n</li>\n<li><p>我们写过这样的代码，那它是如何执行的呢？事实上，这里涉及到一个属性查找的问题。[]对象本身没有hasOwnProperty这个方法，于是继续查找__proto__属性指向Array prototype是否有该方法，依然查找失败，于是继续查找Array prototype对象的__proto__属性指向的对象…最终找到Object.prototype上有这个方法，执行的结果为true。每个对象通过__proto__属性与自己的原型对象建立联系，而且这个过程是可以延续的，这就是js里原型链的概念。通过这个例子，我们知道：原型链在JS中的作用是查找对象的属性/方法。</p>\n</li>\n<li><p>原型链除了方法的复用还有什么作用呢？一个重要的例子就是instanceof操作符。instanceof操作符就是通过判断第二个操作数的原型对象是否在第一个操作数原型链上来进行判别。</p>\n</li>\n<li><p>接下来的一个疑问是：这些对象是怎么得来的呢？答案是构造器。</p>\n</li>\n<li><p>构造器，在JS中也就是函数。这里展示下函数的创建过程。这里需要注意的几点是：</p>\n<ul>\n<li>[[Class]]：因为typeof不准确，现在各个js库都是根据这个属性来判别对象类型的（Object.prototype.toString.call(obj)）</li>\n<li>[[Prototype]]：因为函数也是一个对象，所以也有指向自己原型的内部属性</li>\n<li>[[Call]]：在执行函数时调用，会产生一个新的执行上下文</li>\n<li>[[Construct]]：在函数作为构造器调用时调用（通过new操作符）</li>\n<li>[[Scope]]：保存函数的作用域</li>\n<li>length：函数期望参数数目</li>\n<li>prototype：用来为构造器创建对象设置[[prototype]]</li>\n</ul>\n</li>\n<li><p>制造对象通过函数对象的内部属性[[Construct]]进行。</p>\n<ul>\n<li>创建一个原生对象，这个对象是”纯洁的“</li>\n<li>添加这个原生对象的内部属性[[Class]]，这个属性是用来判定对象类型的</li>\n<li>然后添加这个原生对象的内部属性[[Prototype]]，也记做__proto__</li>\n<li>执行函数对象代码，其中的this设置为刚刚创建的原生对象。记执行代码返回值为R</li>\n<li>如果R为对象，则返回R，否则返回创建的原生对象O</li>\n</ul>\n</li>\n<li><p>一个简单的例子。</p>\n</li>\n<li><p>只要记住一点：构造器的prototype属性是用来为创建对象设置__proto__属性的，构造器作为对象也有自身的__proto__属性，指向的是Function.prototype对象。</p>\n</li>\n<li><p>JS中的代码可以划分为三种类型：全局代码. 函数代码和eval代码。eval这个方法我们要尽量少的使用，因为不单有创建一个新解析器的开销，还有安全性方面的问题。</p>\n</li>\n<li><p>每种类型的代码在执行时都会在相应类型的上下文中，我们称之为执行上下文。</p>\n</li>\n</ol>\n<p>15-31. 这个例子简单展示了执行上下文栈的运行过程。</p>\n<ol start=\"32\">\n<li><p>接下来我们详细了解一下执行上下文。执行上下文也可以理解为一个对象，主要的属性有三个：变量对象. 作用域链和thisValue。</p>\n<ul>\n<li>变量对象是一个保存当前代码中所有变量. 函数声明等的对象</li>\n<li>作用域链是由执行上下文的变量对象和所有父级作用域构成的，可以理解为一个数组</li>\n<li>thisValue用来指明当前代码中this所代表的值</li>\n</ul>\n</li>\n<li><p>变量对象根据执行上下文的不同有一些差异:</p>\n<ul>\n<li>在全局执行上下文中，变量对象就是全局对象本身，而this也是指向全局对象的，所以它们三个相等。这个特性非常重要，因为我们可以通过访问全局对象来获得变量对象中储存的变量，这也是唯一可以访问变量对象的情形</li>\n<li>在函数执行上下文中，变量对象增加了arguments对象和行参等，这被称为活动对象。我们是不能直接访问到活动对象的</li>\n</ul>\n</li>\n<li><p>全局变量对象的一个例子。</p>\n</li>\n<li><p>活动对象的一个例子。注意arguments对象是一个array-like的对象而不是一个array。</p>\n</li>\n<li><p>代码的执行过程分为两步，首先进入执行上下文，主要是初始化上下文中的三个属性：变量对象. 作用域链和thisValue，然后开始执行代码。</p>\n</li>\n<li><p>在进入执行上下文阶段，初始化变量对象的过程是非常值得注意，因为在这个过程中，函数中所有形参. 变量声明. 函数声明都会被保存至变量对象中，进而影响作用域链，最终影响到变量的查找。初始化变量分为三步，这其中要注意的是：</p>\n<ul>\n<li>所有函数声明都会将函数名添加为变量对象的一个属性，函数对象为该属性的值，所以我们可以将函数定义在任何位置。为了主体逻辑更加清晰，一般我们都将函数声明放在靠后的位置</li>\n<li>所有变量声明的变量名都会作为变量对象的一个属性，其值为undefined。在执行代码阶段，解析器其实不会理会var的。为了防止忘记声明变量，所以建议在函数开始时声明所有局部变量</li>\n<li>变量对象属性之间的覆盖问题。函数声明的函数名可以覆盖之前所有VO属性，变量声明的变量只能覆盖之前的重名变量</li>\n</ul>\n</li>\n<li><p>声明可以不被覆盖，但是语句仍然会执行。在本例中，形参x没有被变量x覆盖，但执行var x ＝ 10之后x的值仍然会变化。形参y会被函数声明y覆盖。</p>\n</li>\n<li><p>一个作用域链的例子。</p>\n</li>\n<li><p>作用域链的几个特性，静态作用域的概念非常重要，函数在声明的时候即已确定自身的作用域链内容([[Scope]])。</p>\n</li>\n<li><p>闭包实现的基础有两个方面：</p>\n<ul>\n<li>函数是一级对象，可以像普通对象一样赋值给变量. 作为函数返回值. 作为参数传递给函数</li>\n<li>函数对象会保存声明时的作用域链，也就是函数具有静态作用域</li>\n</ul>\n<p>这两个特性使得JS中每个函数都是一个闭包，为这种语言增加了无限的变化和魔力。</p>\n</li>\n<li><p>函数作为返回值，或者称为自底向上的闭包。</p>\n</li>\n<li><p>函数作为参数，或者称为自上到下的闭包。</p>\n</li>\n<li><p>this在进入执行上下文阶段被赋值，在全局执行上下文中就是全局对象，在函数执行上下文中会随着函数的调用方式不同有所变化。</p>\n</li>\n<li><p>本文主要参考了Dmitry Soshnikov的ECMA-262-3 in detail系列文章，我本人获益匪浅。</p>\n</li>\n<li><p>谢谢大家。</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">The Core</a></li>\n<li><a href=\"http://dmitrysoshnikov.com/tag/ecma-262-3/\">ECMA-262-3 in detail</a></li>\n<li><a href=\"http://es5.github.com/\">Annotated ECMAScript 5.1</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<div style=\"text-align: center;\"><iframe src=\"http://www.slideshare.net/slideshow/embed_code/10708244\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" width=\"425\" height=\"355\"></iframe></div>\n\n<div style=\"text-align: center;\"><a href=\"/assets/the-core-of-javascript.key_.zip\">keynote下载</a> | <a href=\"/assets/the-core-of-javascript.pdf.zip\">pdf下载</a></div>","more":"<h2 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes\"></a>Notes</h2><ol>\n<li><p>这次分享一些Javascript或者说ECMAScript中的一些比较基础的知识点。这些东西在我们日常的开发和调试中发挥着非常重要而又容易被忽略的作用。希望这次分享能够让大家有一个更深入的认识。</p>\n</li>\n<li><p>对于我们所使用的核心技术，我们要做到知其然知其所以然。这是一个非常重要的态度，只有这样，我们才能更好的理解这些技术背后蕴涵的思想，运作机制，以及优点缺陷，才能免于陷入缤纷表现的漩涡，能够做到透过现象看本质。</p>\n</li>\n<li><p>每个人的精力都是有限的，尤其是我这种愚钝的人，所以，把你的精力放在最值得放的一些地方，而不是处处留芳。</p>\n</li>\n<li><p>这次我们主要分享这几个知识点：原型链. 构造器. 执行上下文. 变量对象. 作用域链. 闭包和This</p>\n</li>\n<li><p>对象是一切的基础，我们从这里起步，用一个个对象构建前端的摩天大楼！对象实际非常简单，它就是一个容器，可以以键值对的形式储藏信息，例如姓名. 性别。对象有一个非常重要的内部属性__proto__，指向它的原型对象，以实现方法. 属性的复用或着说继承。</p>\n</li>\n<li><p>我们写过这样的代码，那它是如何执行的呢？事实上，这里涉及到一个属性查找的问题。[]对象本身没有hasOwnProperty这个方法，于是继续查找__proto__属性指向Array prototype是否有该方法，依然查找失败，于是继续查找Array prototype对象的__proto__属性指向的对象…最终找到Object.prototype上有这个方法，执行的结果为true。每个对象通过__proto__属性与自己的原型对象建立联系，而且这个过程是可以延续的，这就是js里原型链的概念。通过这个例子，我们知道：原型链在JS中的作用是查找对象的属性/方法。</p>\n</li>\n<li><p>原型链除了方法的复用还有什么作用呢？一个重要的例子就是instanceof操作符。instanceof操作符就是通过判断第二个操作数的原型对象是否在第一个操作数原型链上来进行判别。</p>\n</li>\n<li><p>接下来的一个疑问是：这些对象是怎么得来的呢？答案是构造器。</p>\n</li>\n<li><p>构造器，在JS中也就是函数。这里展示下函数的创建过程。这里需要注意的几点是：</p>\n<ul>\n<li>[[Class]]：因为typeof不准确，现在各个js库都是根据这个属性来判别对象类型的（Object.prototype.toString.call(obj)）</li>\n<li>[[Prototype]]：因为函数也是一个对象，所以也有指向自己原型的内部属性</li>\n<li>[[Call]]：在执行函数时调用，会产生一个新的执行上下文</li>\n<li>[[Construct]]：在函数作为构造器调用时调用（通过new操作符）</li>\n<li>[[Scope]]：保存函数的作用域</li>\n<li>length：函数期望参数数目</li>\n<li>prototype：用来为构造器创建对象设置[[prototype]]</li>\n</ul>\n</li>\n<li><p>制造对象通过函数对象的内部属性[[Construct]]进行。</p>\n<ul>\n<li>创建一个原生对象，这个对象是”纯洁的“</li>\n<li>添加这个原生对象的内部属性[[Class]]，这个属性是用来判定对象类型的</li>\n<li>然后添加这个原生对象的内部属性[[Prototype]]，也记做__proto__</li>\n<li>执行函数对象代码，其中的this设置为刚刚创建的原生对象。记执行代码返回值为R</li>\n<li>如果R为对象，则返回R，否则返回创建的原生对象O</li>\n</ul>\n</li>\n<li><p>一个简单的例子。</p>\n</li>\n<li><p>只要记住一点：构造器的prototype属性是用来为创建对象设置__proto__属性的，构造器作为对象也有自身的__proto__属性，指向的是Function.prototype对象。</p>\n</li>\n<li><p>JS中的代码可以划分为三种类型：全局代码. 函数代码和eval代码。eval这个方法我们要尽量少的使用，因为不单有创建一个新解析器的开销，还有安全性方面的问题。</p>\n</li>\n<li><p>每种类型的代码在执行时都会在相应类型的上下文中，我们称之为执行上下文。</p>\n</li>\n</ol>\n<p>15-31. 这个例子简单展示了执行上下文栈的运行过程。</p>\n<ol start=\"32\">\n<li><p>接下来我们详细了解一下执行上下文。执行上下文也可以理解为一个对象，主要的属性有三个：变量对象. 作用域链和thisValue。</p>\n<ul>\n<li>变量对象是一个保存当前代码中所有变量. 函数声明等的对象</li>\n<li>作用域链是由执行上下文的变量对象和所有父级作用域构成的，可以理解为一个数组</li>\n<li>thisValue用来指明当前代码中this所代表的值</li>\n</ul>\n</li>\n<li><p>变量对象根据执行上下文的不同有一些差异:</p>\n<ul>\n<li>在全局执行上下文中，变量对象就是全局对象本身，而this也是指向全局对象的，所以它们三个相等。这个特性非常重要，因为我们可以通过访问全局对象来获得变量对象中储存的变量，这也是唯一可以访问变量对象的情形</li>\n<li>在函数执行上下文中，变量对象增加了arguments对象和行参等，这被称为活动对象。我们是不能直接访问到活动对象的</li>\n</ul>\n</li>\n<li><p>全局变量对象的一个例子。</p>\n</li>\n<li><p>活动对象的一个例子。注意arguments对象是一个array-like的对象而不是一个array。</p>\n</li>\n<li><p>代码的执行过程分为两步，首先进入执行上下文，主要是初始化上下文中的三个属性：变量对象. 作用域链和thisValue，然后开始执行代码。</p>\n</li>\n<li><p>在进入执行上下文阶段，初始化变量对象的过程是非常值得注意，因为在这个过程中，函数中所有形参. 变量声明. 函数声明都会被保存至变量对象中，进而影响作用域链，最终影响到变量的查找。初始化变量分为三步，这其中要注意的是：</p>\n<ul>\n<li>所有函数声明都会将函数名添加为变量对象的一个属性，函数对象为该属性的值，所以我们可以将函数定义在任何位置。为了主体逻辑更加清晰，一般我们都将函数声明放在靠后的位置</li>\n<li>所有变量声明的变量名都会作为变量对象的一个属性，其值为undefined。在执行代码阶段，解析器其实不会理会var的。为了防止忘记声明变量，所以建议在函数开始时声明所有局部变量</li>\n<li>变量对象属性之间的覆盖问题。函数声明的函数名可以覆盖之前所有VO属性，变量声明的变量只能覆盖之前的重名变量</li>\n</ul>\n</li>\n<li><p>声明可以不被覆盖，但是语句仍然会执行。在本例中，形参x没有被变量x覆盖，但执行var x ＝ 10之后x的值仍然会变化。形参y会被函数声明y覆盖。</p>\n</li>\n<li><p>一个作用域链的例子。</p>\n</li>\n<li><p>作用域链的几个特性，静态作用域的概念非常重要，函数在声明的时候即已确定自身的作用域链内容([[Scope]])。</p>\n</li>\n<li><p>闭包实现的基础有两个方面：</p>\n<ul>\n<li>函数是一级对象，可以像普通对象一样赋值给变量. 作为函数返回值. 作为参数传递给函数</li>\n<li>函数对象会保存声明时的作用域链，也就是函数具有静态作用域</li>\n</ul>\n<p>这两个特性使得JS中每个函数都是一个闭包，为这种语言增加了无限的变化和魔力。</p>\n</li>\n<li><p>函数作为返回值，或者称为自底向上的闭包。</p>\n</li>\n<li><p>函数作为参数，或者称为自上到下的闭包。</p>\n</li>\n<li><p>this在进入执行上下文阶段被赋值，在全局执行上下文中就是全局对象，在函数执行上下文中会随着函数的调用方式不同有所变化。</p>\n</li>\n<li><p>本文主要参考了Dmitry Soshnikov的ECMA-262-3 in detail系列文章，我本人获益匪浅。</p>\n</li>\n<li><p>谢谢大家。</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">The Core</a></li>\n<li><a href=\"http://dmitrysoshnikov.com/tag/ecma-262-3/\">ECMA-262-3 in detail</a></li>\n<li><a href=\"http://es5.github.com/\">Annotated ECMAScript 5.1</a></li>\n</ul>"},{"layout":"post","title":"面试是双向的","date":"2022-01-31T07:34:13.000Z","status":"publish","_content":"\n2018 年一段真实的对话：\n\n- 小 A：你好！非常抱歉，我考虑再三，决定还是加入另外一家公司\n- 我：（内心有点小崩溃，但是还想再抢救一下）嗯嗯，替你感到高兴！不过方便再问一下，你最期望在下一份工作中得到什么呢？\n- 小 A：主要还是想在技术方面有一些成长吧\n- 我：（感觉我们还是有点竞争力）面试是双向的，可以的话，我建议你再比较下两边的面试体验，看下哪边的工程师技术更好些\n- 小 A：ok，那我再考虑一下\n\n几天后：\n\n- 小 A：我觉得还是你们这边技术方面更好些，所以我改变了主意，准备加入你们\n\n后来小 A 入职后，成长速度的确非常非常好，业余爱好也是一个没落下，说是事业爱好双丰收也不为过。\n类似的“话术”后面我也用过几次，在候选人的几个选项比较接近时，成功率还是蛮高的。\n\n<!--more-->\n\n## 在面试候选人的同时，候选人也在考察面试官\n\n一般人理解面试官总是高人一等的，牢牢把握着面试中的主动权。究其根本，这种先入为主的偏见其实往往来源于层级分明的公司文化中：\n\n- 一切问题，老大说了算\n- 高 P 总是掌握着更多的资源和决策权\n- 新来的是龙得盘着点，是虎得卧着点，轮不到你 BB\n\n在这种文化中，人才是不太那么受重视的。面试的时候，既然你是过来讨口饭吃，那么居高临下去审视你当然就是理所当然的了。面试中也因此出现各种乱象：\n\n- 侧重寻找不足而非挖掘亮点\n- 代码可以不写，但是一定要能说\n- 偏好算法、脑筋急转弯，轻视工程实践、问题解决能力\n- 迟到、早退、和候选人没有实质互动\n- 简单粗暴不专业，被质疑的时候气急败坏\n\n面试作为候选人和公司进行深入交流的重要窗口，其实不只是面试官们在评估候选人是不是适合特定岗位，与此同时，候选人其实也在通过面试体验来审视这家公司是不是适合自己：\n\n- 面试官一般是将来的团队骨干，他们是不是足够资深，自己跟着他们混有没有前途？\n- 面试官对自己从事的工作是不是眼中有光，激情投入？\n- 当自己遇到了困惑，或者情绪上有些紧张的时候，面试官是不是在引导和调整自己的状态，以更好地体现出自己的真实水平？如果是的话，那么这会是一个很 supportive 的团队\n- 面试体验一定程度上体现出了公司的文化，自己是不是喜欢接下来三年五年在这样的文化里工作？\n\n简而言之，候选人会去考虑自己是不是想和这样一批人共事。\n\n## 如何更好适应双向的面试？\n\n作为如此重要的双方交流窗口，如何确保面试能够筛选出我们需要的人才，同时也能够提升候选人的体验和评价呢？我有如下几点思考。\n\n### 营造舒适平等的面试氛围\n\n先说舒适。\n\n很多候选人在面试开始的时候，或者遇到了一些挑战，都会有一些紧张。实话实话，我自己为数不多的面试里，就好多次比较紧张，导致没有发挥出应有水平。因此，在面试刚刚开始的时候，最好有一些举措让整个氛围热络起来：\n\n- 给候选人倒杯水，然后聊下今天来的路上堵不堵\n- 简单评价下简历上的一些亮点，譬如拿过很多次奖学金、ACM 排名等等，表达对候选人的认可\n- 面试官自我介绍下，同时也介绍下该轮面试的主要流程\n\n基本就是套套近乎，为接下来的面试主题做些铺垫，帮助对方进入状态。\n\n在面试中间如果发现候选人还是非常紧张，不太在状态，可以给一点小提示，或者其它的合理方式帮助对方降压。如果还是很难调整过来，可以再约面试。\n\n另外一点也很重要：平等。\n\n能够进入面试流程的候选人基本也是有货的，作为招聘方，既然我们希望能够招揽人才，那么就不要抱着高人一等的态度。反过来，对于一些非常出色的候选人，也大可不必太过谦卑，双方有利益共同点才是真正稳固的合作。\n\n我们应该总是秉持一种平等的心态去沟通和交流。正如在后面的工作中一样，团队负责人只是一个协助大家发挥自身所长的角色而已。具体实践中有很多可以体现的点：\n\n- 沟通方式比较专业、和睦、不卑不亢\n- 一些问题点候选人有疑问的时候，面试官应该与其交流，而非单纯让其自己考虑，冷眼相对\n- 最后预留一些时间，一般五分钟左右，专门回答候选人的问题\n\n通过营造这样一个愉悦的氛围，搭建好一个候选人能够高水平发挥的舞台，为接下来面试提供良好的基础。\n\n### 努力挖掘相关方向的亮点\n\n好的面试题应该是怎样的？\n\n不同的人有不同的解答。实践中，我们也发现很多人感慨“面试造火箭，入职扭螺丝”，面试内容和实际工作大相径庭。既然这么多人吐槽，那么显然这不太像好的面试题。还有一些候选人比较喜欢“应试”，刷题几百道后，面试 so easy，然而这样的技能在实际工作中真得有用吗？\n\n目前我对好面试题的理解是这样的：\n\n- 来源于相关领域实践，但有一定拔高\n- 有较好的层次性，很容易想到一些解决办法，且有多种层层递进的进阶方案\n- 能够让有才华的候选人举一反三，融会贯通\n\n譬如说前端的一个架构能力考核面试中，可以出一个题目：如何做一个微博首页。这是一个非常开放的题目，需要候选人去考虑实际场景、核心要求、团队结构、现有技术栈等去权衡各种方案的利弊。每当候选人有了一定的见解后，面试官可以选择一些要点继续深挖，直到逼近候选人的极限为止。如果遇到难得的高水平人才，我们可以继续讨论有所关联的类似产品但不同场景、不同产品类似场景等多种方案，看对方是否融会贯通，高屋建瓴。\n\n另外，相比于挖掘对方的缺点，一种更好的方式还是抓亮点。我们需要知道候选人的不足，但这些不是能够提升我们团队能力的关键。构建一个高绩效团队和木桶理论不太相关，团队在某个方面的天花板更大程度地体现在大家的专长上。因此，抓亮点是关键所在。准确地抓亮点是设计面试题目的目标，如果面试题目和实际问题相去甚远、没有任何层次只是闭合性问题、没有一通百通而只适用特定领域，那么这样的题目就不能达成抓亮点的目标。\n\n### 专业的全流程体验\n\n面试整个流程不只有面试官，还有人力部门、当地主管等等众多角色参与。某个环节掉链子的话，也会对面试体验有一定程度负面影响。譬如：\n\n- 某个新手面试官上来就引用编程语言问题晾了候选人一会儿。这可能需要更多事前培训和传帮带流程\n- 约好的面试时间发现会议室被占用。这可能需要公司办公系统方面的支持\n- Offer 沟通流程过长。这可能需要决策人员和 HR 团队的紧密配合\n\n没有完美的流程，任何事情不可能一蹴而就。本着招贤纳士的根本目标，不断优化和完善全流程体验，才会赢得越来越多候选人的芳心。\n\n## 写在最后\n\n人才是公司最宝贵的资源，面试是招揽人才最为重要的渠道。打造高水平的面试体验难度很大，但是非常物有所值。期望我的一点思考能够对你有所帮助，也欢迎一起探讨面试的相关问题。\n\n\n\n\n","source":"_posts/interview-is-bidirectional.md","raw":"---\nlayout: post\ntitle: \"面试是双向的\"\ndate: 2022-01-31 15:34:13\nstatus: publish\ntags: [Interview]\n---\n\n2018 年一段真实的对话：\n\n- 小 A：你好！非常抱歉，我考虑再三，决定还是加入另外一家公司\n- 我：（内心有点小崩溃，但是还想再抢救一下）嗯嗯，替你感到高兴！不过方便再问一下，你最期望在下一份工作中得到什么呢？\n- 小 A：主要还是想在技术方面有一些成长吧\n- 我：（感觉我们还是有点竞争力）面试是双向的，可以的话，我建议你再比较下两边的面试体验，看下哪边的工程师技术更好些\n- 小 A：ok，那我再考虑一下\n\n几天后：\n\n- 小 A：我觉得还是你们这边技术方面更好些，所以我改变了主意，准备加入你们\n\n后来小 A 入职后，成长速度的确非常非常好，业余爱好也是一个没落下，说是事业爱好双丰收也不为过。\n类似的“话术”后面我也用过几次，在候选人的几个选项比较接近时，成功率还是蛮高的。\n\n<!--more-->\n\n## 在面试候选人的同时，候选人也在考察面试官\n\n一般人理解面试官总是高人一等的，牢牢把握着面试中的主动权。究其根本，这种先入为主的偏见其实往往来源于层级分明的公司文化中：\n\n- 一切问题，老大说了算\n- 高 P 总是掌握着更多的资源和决策权\n- 新来的是龙得盘着点，是虎得卧着点，轮不到你 BB\n\n在这种文化中，人才是不太那么受重视的。面试的时候，既然你是过来讨口饭吃，那么居高临下去审视你当然就是理所当然的了。面试中也因此出现各种乱象：\n\n- 侧重寻找不足而非挖掘亮点\n- 代码可以不写，但是一定要能说\n- 偏好算法、脑筋急转弯，轻视工程实践、问题解决能力\n- 迟到、早退、和候选人没有实质互动\n- 简单粗暴不专业，被质疑的时候气急败坏\n\n面试作为候选人和公司进行深入交流的重要窗口，其实不只是面试官们在评估候选人是不是适合特定岗位，与此同时，候选人其实也在通过面试体验来审视这家公司是不是适合自己：\n\n- 面试官一般是将来的团队骨干，他们是不是足够资深，自己跟着他们混有没有前途？\n- 面试官对自己从事的工作是不是眼中有光，激情投入？\n- 当自己遇到了困惑，或者情绪上有些紧张的时候，面试官是不是在引导和调整自己的状态，以更好地体现出自己的真实水平？如果是的话，那么这会是一个很 supportive 的团队\n- 面试体验一定程度上体现出了公司的文化，自己是不是喜欢接下来三年五年在这样的文化里工作？\n\n简而言之，候选人会去考虑自己是不是想和这样一批人共事。\n\n## 如何更好适应双向的面试？\n\n作为如此重要的双方交流窗口，如何确保面试能够筛选出我们需要的人才，同时也能够提升候选人的体验和评价呢？我有如下几点思考。\n\n### 营造舒适平等的面试氛围\n\n先说舒适。\n\n很多候选人在面试开始的时候，或者遇到了一些挑战，都会有一些紧张。实话实话，我自己为数不多的面试里，就好多次比较紧张，导致没有发挥出应有水平。因此，在面试刚刚开始的时候，最好有一些举措让整个氛围热络起来：\n\n- 给候选人倒杯水，然后聊下今天来的路上堵不堵\n- 简单评价下简历上的一些亮点，譬如拿过很多次奖学金、ACM 排名等等，表达对候选人的认可\n- 面试官自我介绍下，同时也介绍下该轮面试的主要流程\n\n基本就是套套近乎，为接下来的面试主题做些铺垫，帮助对方进入状态。\n\n在面试中间如果发现候选人还是非常紧张，不太在状态，可以给一点小提示，或者其它的合理方式帮助对方降压。如果还是很难调整过来，可以再约面试。\n\n另外一点也很重要：平等。\n\n能够进入面试流程的候选人基本也是有货的，作为招聘方，既然我们希望能够招揽人才，那么就不要抱着高人一等的态度。反过来，对于一些非常出色的候选人，也大可不必太过谦卑，双方有利益共同点才是真正稳固的合作。\n\n我们应该总是秉持一种平等的心态去沟通和交流。正如在后面的工作中一样，团队负责人只是一个协助大家发挥自身所长的角色而已。具体实践中有很多可以体现的点：\n\n- 沟通方式比较专业、和睦、不卑不亢\n- 一些问题点候选人有疑问的时候，面试官应该与其交流，而非单纯让其自己考虑，冷眼相对\n- 最后预留一些时间，一般五分钟左右，专门回答候选人的问题\n\n通过营造这样一个愉悦的氛围，搭建好一个候选人能够高水平发挥的舞台，为接下来面试提供良好的基础。\n\n### 努力挖掘相关方向的亮点\n\n好的面试题应该是怎样的？\n\n不同的人有不同的解答。实践中，我们也发现很多人感慨“面试造火箭，入职扭螺丝”，面试内容和实际工作大相径庭。既然这么多人吐槽，那么显然这不太像好的面试题。还有一些候选人比较喜欢“应试”，刷题几百道后，面试 so easy，然而这样的技能在实际工作中真得有用吗？\n\n目前我对好面试题的理解是这样的：\n\n- 来源于相关领域实践，但有一定拔高\n- 有较好的层次性，很容易想到一些解决办法，且有多种层层递进的进阶方案\n- 能够让有才华的候选人举一反三，融会贯通\n\n譬如说前端的一个架构能力考核面试中，可以出一个题目：如何做一个微博首页。这是一个非常开放的题目，需要候选人去考虑实际场景、核心要求、团队结构、现有技术栈等去权衡各种方案的利弊。每当候选人有了一定的见解后，面试官可以选择一些要点继续深挖，直到逼近候选人的极限为止。如果遇到难得的高水平人才，我们可以继续讨论有所关联的类似产品但不同场景、不同产品类似场景等多种方案，看对方是否融会贯通，高屋建瓴。\n\n另外，相比于挖掘对方的缺点，一种更好的方式还是抓亮点。我们需要知道候选人的不足，但这些不是能够提升我们团队能力的关键。构建一个高绩效团队和木桶理论不太相关，团队在某个方面的天花板更大程度地体现在大家的专长上。因此，抓亮点是关键所在。准确地抓亮点是设计面试题目的目标，如果面试题目和实际问题相去甚远、没有任何层次只是闭合性问题、没有一通百通而只适用特定领域，那么这样的题目就不能达成抓亮点的目标。\n\n### 专业的全流程体验\n\n面试整个流程不只有面试官，还有人力部门、当地主管等等众多角色参与。某个环节掉链子的话，也会对面试体验有一定程度负面影响。譬如：\n\n- 某个新手面试官上来就引用编程语言问题晾了候选人一会儿。这可能需要更多事前培训和传帮带流程\n- 约好的面试时间发现会议室被占用。这可能需要公司办公系统方面的支持\n- Offer 沟通流程过长。这可能需要决策人员和 HR 团队的紧密配合\n\n没有完美的流程，任何事情不可能一蹴而就。本着招贤纳士的根本目标，不断优化和完善全流程体验，才会赢得越来越多候选人的芳心。\n\n## 写在最后\n\n人才是公司最宝贵的资源，面试是招揽人才最为重要的渠道。打造高水平的面试体验难度很大，但是非常物有所值。期望我的一点思考能够对你有所帮助，也欢迎一起探讨面试的相关问题。\n\n\n\n\n","slug":"interview-is-bidirectional","published":1,"updated":"2022-01-31T09:16:34.468Z","comments":1,"photos":[],"link":"","_id":"cl1klgupo000v8e85ae5a4pdp","content":"<p>2018 年一段真实的对话：</p>\n<ul>\n<li>小 A：你好！非常抱歉，我考虑再三，决定还是加入另外一家公司</li>\n<li>我：（内心有点小崩溃，但是还想再抢救一下）嗯嗯，替你感到高兴！不过方便再问一下，你最期望在下一份工作中得到什么呢？</li>\n<li>小 A：主要还是想在技术方面有一些成长吧</li>\n<li>我：（感觉我们还是有点竞争力）面试是双向的，可以的话，我建议你再比较下两边的面试体验，看下哪边的工程师技术更好些</li>\n<li>小 A：ok，那我再考虑一下</li>\n</ul>\n<p>几天后：</p>\n<ul>\n<li>小 A：我觉得还是你们这边技术方面更好些，所以我改变了主意，准备加入你们</li>\n</ul>\n<p>后来小 A 入职后，成长速度的确非常非常好，业余爱好也是一个没落下，说是事业爱好双丰收也不为过。\n类似的“话术”后面我也用过几次，在候选人的几个选项比较接近时，成功率还是蛮高的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"在面试候选人的同时，候选人也在考察面试官\"><a href=\"#在面试候选人的同时，候选人也在考察面试官\" class=\"headerlink\" title=\"在面试候选人的同时，候选人也在考察面试官\"></a>在面试候选人的同时，候选人也在考察面试官</h2><p>一般人理解面试官总是高人一等的，牢牢把握着面试中的主动权。究其根本，这种先入为主的偏见其实往往来源于层级分明的公司文化中：</p>\n<ul>\n<li>一切问题，老大说了算</li>\n<li>高 P 总是掌握着更多的资源和决策权</li>\n<li>新来的是龙得盘着点，是虎得卧着点，轮不到你 BB</li>\n</ul>\n<p>在这种文化中，人才是不太那么受重视的。面试的时候，既然你是过来讨口饭吃，那么居高临下去审视你当然就是理所当然的了。面试中也因此出现各种乱象：</p>\n<ul>\n<li>侧重寻找不足而非挖掘亮点</li>\n<li>代码可以不写，但是一定要能说</li>\n<li>偏好算法、脑筋急转弯，轻视工程实践、问题解决能力</li>\n<li>迟到、早退、和候选人没有实质互动</li>\n<li>简单粗暴不专业，被质疑的时候气急败坏</li>\n</ul>\n<p>面试作为候选人和公司进行深入交流的重要窗口，其实不只是面试官们在评估候选人是不是适合特定岗位，与此同时，候选人其实也在通过面试体验来审视这家公司是不是适合自己：</p>\n<ul>\n<li>面试官一般是将来的团队骨干，他们是不是足够资深，自己跟着他们混有没有前途？</li>\n<li>面试官对自己从事的工作是不是眼中有光，激情投入？</li>\n<li>当自己遇到了困惑，或者情绪上有些紧张的时候，面试官是不是在引导和调整自己的状态，以更好地体现出自己的真实水平？如果是的话，那么这会是一个很 supportive 的团队</li>\n<li>面试体验一定程度上体现出了公司的文化，自己是不是喜欢接下来三年五年在这样的文化里工作？</li>\n</ul>\n<p>简而言之，候选人会去考虑自己是不是想和这样一批人共事。</p>\n<h2 id=\"如何更好适应双向的面试？\"><a href=\"#如何更好适应双向的面试？\" class=\"headerlink\" title=\"如何更好适应双向的面试？\"></a>如何更好适应双向的面试？</h2><p>作为如此重要的双方交流窗口，如何确保面试能够筛选出我们需要的人才，同时也能够提升候选人的体验和评价呢？我有如下几点思考。</p>\n<h3 id=\"营造舒适平等的面试氛围\"><a href=\"#营造舒适平等的面试氛围\" class=\"headerlink\" title=\"营造舒适平等的面试氛围\"></a>营造舒适平等的面试氛围</h3><p>先说舒适。</p>\n<p>很多候选人在面试开始的时候，或者遇到了一些挑战，都会有一些紧张。实话实话，我自己为数不多的面试里，就好多次比较紧张，导致没有发挥出应有水平。因此，在面试刚刚开始的时候，最好有一些举措让整个氛围热络起来：</p>\n<ul>\n<li>给候选人倒杯水，然后聊下今天来的路上堵不堵</li>\n<li>简单评价下简历上的一些亮点，譬如拿过很多次奖学金、ACM 排名等等，表达对候选人的认可</li>\n<li>面试官自我介绍下，同时也介绍下该轮面试的主要流程</li>\n</ul>\n<p>基本就是套套近乎，为接下来的面试主题做些铺垫，帮助对方进入状态。</p>\n<p>在面试中间如果发现候选人还是非常紧张，不太在状态，可以给一点小提示，或者其它的合理方式帮助对方降压。如果还是很难调整过来，可以再约面试。</p>\n<p>另外一点也很重要：平等。</p>\n<p>能够进入面试流程的候选人基本也是有货的，作为招聘方，既然我们希望能够招揽人才，那么就不要抱着高人一等的态度。反过来，对于一些非常出色的候选人，也大可不必太过谦卑，双方有利益共同点才是真正稳固的合作。</p>\n<p>我们应该总是秉持一种平等的心态去沟通和交流。正如在后面的工作中一样，团队负责人只是一个协助大家发挥自身所长的角色而已。具体实践中有很多可以体现的点：</p>\n<ul>\n<li>沟通方式比较专业、和睦、不卑不亢</li>\n<li>一些问题点候选人有疑问的时候，面试官应该与其交流，而非单纯让其自己考虑，冷眼相对</li>\n<li>最后预留一些时间，一般五分钟左右，专门回答候选人的问题</li>\n</ul>\n<p>通过营造这样一个愉悦的氛围，搭建好一个候选人能够高水平发挥的舞台，为接下来面试提供良好的基础。</p>\n<h3 id=\"努力挖掘相关方向的亮点\"><a href=\"#努力挖掘相关方向的亮点\" class=\"headerlink\" title=\"努力挖掘相关方向的亮点\"></a>努力挖掘相关方向的亮点</h3><p>好的面试题应该是怎样的？</p>\n<p>不同的人有不同的解答。实践中，我们也发现很多人感慨“面试造火箭，入职扭螺丝”，面试内容和实际工作大相径庭。既然这么多人吐槽，那么显然这不太像好的面试题。还有一些候选人比较喜欢“应试”，刷题几百道后，面试 so easy，然而这样的技能在实际工作中真得有用吗？</p>\n<p>目前我对好面试题的理解是这样的：</p>\n<ul>\n<li>来源于相关领域实践，但有一定拔高</li>\n<li>有较好的层次性，很容易想到一些解决办法，且有多种层层递进的进阶方案</li>\n<li>能够让有才华的候选人举一反三，融会贯通</li>\n</ul>\n<p>譬如说前端的一个架构能力考核面试中，可以出一个题目：如何做一个微博首页。这是一个非常开放的题目，需要候选人去考虑实际场景、核心要求、团队结构、现有技术栈等去权衡各种方案的利弊。每当候选人有了一定的见解后，面试官可以选择一些要点继续深挖，直到逼近候选人的极限为止。如果遇到难得的高水平人才，我们可以继续讨论有所关联的类似产品但不同场景、不同产品类似场景等多种方案，看对方是否融会贯通，高屋建瓴。</p>\n<p>另外，相比于挖掘对方的缺点，一种更好的方式还是抓亮点。我们需要知道候选人的不足，但这些不是能够提升我们团队能力的关键。构建一个高绩效团队和木桶理论不太相关，团队在某个方面的天花板更大程度地体现在大家的专长上。因此，抓亮点是关键所在。准确地抓亮点是设计面试题目的目标，如果面试题目和实际问题相去甚远、没有任何层次只是闭合性问题、没有一通百通而只适用特定领域，那么这样的题目就不能达成抓亮点的目标。</p>\n<h3 id=\"专业的全流程体验\"><a href=\"#专业的全流程体验\" class=\"headerlink\" title=\"专业的全流程体验\"></a>专业的全流程体验</h3><p>面试整个流程不只有面试官，还有人力部门、当地主管等等众多角色参与。某个环节掉链子的话，也会对面试体验有一定程度负面影响。譬如：</p>\n<ul>\n<li>某个新手面试官上来就引用编程语言问题晾了候选人一会儿。这可能需要更多事前培训和传帮带流程</li>\n<li>约好的面试时间发现会议室被占用。这可能需要公司办公系统方面的支持</li>\n<li>Offer 沟通流程过长。这可能需要决策人员和 HR 团队的紧密配合</li>\n</ul>\n<p>没有完美的流程，任何事情不可能一蹴而就。本着招贤纳士的根本目标，不断优化和完善全流程体验，才会赢得越来越多候选人的芳心。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>人才是公司最宝贵的资源，面试是招揽人才最为重要的渠道。打造高水平的面试体验难度很大，但是非常物有所值。期望我的一点思考能够对你有所帮助，也欢迎一起探讨面试的相关问题。</p>\n","site":{"data":{}},"excerpt":"<p>2018 年一段真实的对话：</p>\n<ul>\n<li>小 A：你好！非常抱歉，我考虑再三，决定还是加入另外一家公司</li>\n<li>我：（内心有点小崩溃，但是还想再抢救一下）嗯嗯，替你感到高兴！不过方便再问一下，你最期望在下一份工作中得到什么呢？</li>\n<li>小 A：主要还是想在技术方面有一些成长吧</li>\n<li>我：（感觉我们还是有点竞争力）面试是双向的，可以的话，我建议你再比较下两边的面试体验，看下哪边的工程师技术更好些</li>\n<li>小 A：ok，那我再考虑一下</li>\n</ul>\n<p>几天后：</p>\n<ul>\n<li>小 A：我觉得还是你们这边技术方面更好些，所以我改变了主意，准备加入你们</li>\n</ul>\n<p>后来小 A 入职后，成长速度的确非常非常好，业余爱好也是一个没落下，说是事业爱好双丰收也不为过。\n类似的“话术”后面我也用过几次，在候选人的几个选项比较接近时，成功率还是蛮高的。</p>","more":"<h2 id=\"在面试候选人的同时，候选人也在考察面试官\"><a href=\"#在面试候选人的同时，候选人也在考察面试官\" class=\"headerlink\" title=\"在面试候选人的同时，候选人也在考察面试官\"></a>在面试候选人的同时，候选人也在考察面试官</h2><p>一般人理解面试官总是高人一等的，牢牢把握着面试中的主动权。究其根本，这种先入为主的偏见其实往往来源于层级分明的公司文化中：</p>\n<ul>\n<li>一切问题，老大说了算</li>\n<li>高 P 总是掌握着更多的资源和决策权</li>\n<li>新来的是龙得盘着点，是虎得卧着点，轮不到你 BB</li>\n</ul>\n<p>在这种文化中，人才是不太那么受重视的。面试的时候，既然你是过来讨口饭吃，那么居高临下去审视你当然就是理所当然的了。面试中也因此出现各种乱象：</p>\n<ul>\n<li>侧重寻找不足而非挖掘亮点</li>\n<li>代码可以不写，但是一定要能说</li>\n<li>偏好算法、脑筋急转弯，轻视工程实践、问题解决能力</li>\n<li>迟到、早退、和候选人没有实质互动</li>\n<li>简单粗暴不专业，被质疑的时候气急败坏</li>\n</ul>\n<p>面试作为候选人和公司进行深入交流的重要窗口，其实不只是面试官们在评估候选人是不是适合特定岗位，与此同时，候选人其实也在通过面试体验来审视这家公司是不是适合自己：</p>\n<ul>\n<li>面试官一般是将来的团队骨干，他们是不是足够资深，自己跟着他们混有没有前途？</li>\n<li>面试官对自己从事的工作是不是眼中有光，激情投入？</li>\n<li>当自己遇到了困惑，或者情绪上有些紧张的时候，面试官是不是在引导和调整自己的状态，以更好地体现出自己的真实水平？如果是的话，那么这会是一个很 supportive 的团队</li>\n<li>面试体验一定程度上体现出了公司的文化，自己是不是喜欢接下来三年五年在这样的文化里工作？</li>\n</ul>\n<p>简而言之，候选人会去考虑自己是不是想和这样一批人共事。</p>\n<h2 id=\"如何更好适应双向的面试？\"><a href=\"#如何更好适应双向的面试？\" class=\"headerlink\" title=\"如何更好适应双向的面试？\"></a>如何更好适应双向的面试？</h2><p>作为如此重要的双方交流窗口，如何确保面试能够筛选出我们需要的人才，同时也能够提升候选人的体验和评价呢？我有如下几点思考。</p>\n<h3 id=\"营造舒适平等的面试氛围\"><a href=\"#营造舒适平等的面试氛围\" class=\"headerlink\" title=\"营造舒适平等的面试氛围\"></a>营造舒适平等的面试氛围</h3><p>先说舒适。</p>\n<p>很多候选人在面试开始的时候，或者遇到了一些挑战，都会有一些紧张。实话实话，我自己为数不多的面试里，就好多次比较紧张，导致没有发挥出应有水平。因此，在面试刚刚开始的时候，最好有一些举措让整个氛围热络起来：</p>\n<ul>\n<li>给候选人倒杯水，然后聊下今天来的路上堵不堵</li>\n<li>简单评价下简历上的一些亮点，譬如拿过很多次奖学金、ACM 排名等等，表达对候选人的认可</li>\n<li>面试官自我介绍下，同时也介绍下该轮面试的主要流程</li>\n</ul>\n<p>基本就是套套近乎，为接下来的面试主题做些铺垫，帮助对方进入状态。</p>\n<p>在面试中间如果发现候选人还是非常紧张，不太在状态，可以给一点小提示，或者其它的合理方式帮助对方降压。如果还是很难调整过来，可以再约面试。</p>\n<p>另外一点也很重要：平等。</p>\n<p>能够进入面试流程的候选人基本也是有货的，作为招聘方，既然我们希望能够招揽人才，那么就不要抱着高人一等的态度。反过来，对于一些非常出色的候选人，也大可不必太过谦卑，双方有利益共同点才是真正稳固的合作。</p>\n<p>我们应该总是秉持一种平等的心态去沟通和交流。正如在后面的工作中一样，团队负责人只是一个协助大家发挥自身所长的角色而已。具体实践中有很多可以体现的点：</p>\n<ul>\n<li>沟通方式比较专业、和睦、不卑不亢</li>\n<li>一些问题点候选人有疑问的时候，面试官应该与其交流，而非单纯让其自己考虑，冷眼相对</li>\n<li>最后预留一些时间，一般五分钟左右，专门回答候选人的问题</li>\n</ul>\n<p>通过营造这样一个愉悦的氛围，搭建好一个候选人能够高水平发挥的舞台，为接下来面试提供良好的基础。</p>\n<h3 id=\"努力挖掘相关方向的亮点\"><a href=\"#努力挖掘相关方向的亮点\" class=\"headerlink\" title=\"努力挖掘相关方向的亮点\"></a>努力挖掘相关方向的亮点</h3><p>好的面试题应该是怎样的？</p>\n<p>不同的人有不同的解答。实践中，我们也发现很多人感慨“面试造火箭，入职扭螺丝”，面试内容和实际工作大相径庭。既然这么多人吐槽，那么显然这不太像好的面试题。还有一些候选人比较喜欢“应试”，刷题几百道后，面试 so easy，然而这样的技能在实际工作中真得有用吗？</p>\n<p>目前我对好面试题的理解是这样的：</p>\n<ul>\n<li>来源于相关领域实践，但有一定拔高</li>\n<li>有较好的层次性，很容易想到一些解决办法，且有多种层层递进的进阶方案</li>\n<li>能够让有才华的候选人举一反三，融会贯通</li>\n</ul>\n<p>譬如说前端的一个架构能力考核面试中，可以出一个题目：如何做一个微博首页。这是一个非常开放的题目，需要候选人去考虑实际场景、核心要求、团队结构、现有技术栈等去权衡各种方案的利弊。每当候选人有了一定的见解后，面试官可以选择一些要点继续深挖，直到逼近候选人的极限为止。如果遇到难得的高水平人才，我们可以继续讨论有所关联的类似产品但不同场景、不同产品类似场景等多种方案，看对方是否融会贯通，高屋建瓴。</p>\n<p>另外，相比于挖掘对方的缺点，一种更好的方式还是抓亮点。我们需要知道候选人的不足，但这些不是能够提升我们团队能力的关键。构建一个高绩效团队和木桶理论不太相关，团队在某个方面的天花板更大程度地体现在大家的专长上。因此，抓亮点是关键所在。准确地抓亮点是设计面试题目的目标，如果面试题目和实际问题相去甚远、没有任何层次只是闭合性问题、没有一通百通而只适用特定领域，那么这样的题目就不能达成抓亮点的目标。</p>\n<h3 id=\"专业的全流程体验\"><a href=\"#专业的全流程体验\" class=\"headerlink\" title=\"专业的全流程体验\"></a>专业的全流程体验</h3><p>面试整个流程不只有面试官，还有人力部门、当地主管等等众多角色参与。某个环节掉链子的话，也会对面试体验有一定程度负面影响。譬如：</p>\n<ul>\n<li>某个新手面试官上来就引用编程语言问题晾了候选人一会儿。这可能需要更多事前培训和传帮带流程</li>\n<li>约好的面试时间发现会议室被占用。这可能需要公司办公系统方面的支持</li>\n<li>Offer 沟通流程过长。这可能需要决策人员和 HR 团队的紧密配合</li>\n</ul>\n<p>没有完美的流程，任何事情不可能一蹴而就。本着招贤纳士的根本目标，不断优化和完善全流程体验，才会赢得越来越多候选人的芳心。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>人才是公司最宝贵的资源，面试是招揽人才最为重要的渠道。打造高水平的面试体验难度很大，但是非常物有所值。期望我的一点思考能够对你有所帮助，也欢迎一起探讨面试的相关问题。</p>"},{"layout":"post","title":"JS Linter 进化史","date":"2018-05-29T11:52:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [JS Linter 进化史](https://zhuanlan.zhihu.com/p/34656263) 查看全文。\n","source":"_posts/js-linter-history.md","raw":"---\nlayout: post\ntitle: \"JS Linter 进化史\"\ndate: 2018-05-29 19:52\nstatus: publish\ntags: [JavaScript, Linter, ESLint, JSLint]\n---\n\n请移步知乎“前端之美”专栏 [JS Linter 进化史](https://zhuanlan.zhihu.com/p/34656263) 查看全文。\n","slug":"js-linter-history","published":1,"updated":"2021-10-05T13:16:14.125Z","comments":1,"photos":[],"link":"","_id":"cl1klgupp000x8e85efwm556p","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/34656263\">JS Linter 进化史</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/34656263\">JS Linter 进化史</a> 查看全文。</p>\n"},{"layout":"post","title":"React 设计中的闪光点","date":"2018-01-31T13:04:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [React 设计中的闪光点](https://zhuanlan.zhihu.com/p/28562066) 查看全文。\n","source":"_posts/react-design-highlights.md","raw":"---\nlayout: post\ntitle: \"React 设计中的闪光点\"\ndate: 2018-01-31 21:04\nstatus: publish\ntags: [React, Virtual DOM, Fiber]\n---\n\n请移步知乎“前端之美”专栏 [React 设计中的闪光点](https://zhuanlan.zhihu.com/p/28562066) 查看全文。\n","slug":"react-design-highlights","published":1,"updated":"2021-10-05T13:17:35.246Z","comments":1,"photos":[],"link":"","_id":"cl1klgupp00108e85ewfzblzj","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/28562066\">React 设计中的闪光点</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/28562066\">React 设计中的闪光点</a> 查看全文。</p>\n"},{"layout":"post","title":"前端中的 Monad","date":"2018-10-23T10:30:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [前端中的 Monad](https://zhuanlan.zhihu.com/p/47130217) 查看全文。\n","source":"_posts/monad.md","raw":"---\nlayout: post\ntitle: \"前端中的 Monad\"\ndate: 2018-10-23 18:30\nstatus: publish\ntags: [Functional Programming, Monad]\n---\n\n请移步知乎“前端之美”专栏 [前端中的 Monad](https://zhuanlan.zhihu.com/p/47130217) 查看全文。\n","slug":"monad","published":1,"updated":"2021-10-05T13:14:50.562Z","comments":1,"photos":[],"link":"","_id":"cl1klgupq00128e85aocl9sif","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/47130217\">前端中的 Monad</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/47130217\">前端中的 Monad</a> 查看全文。</p>\n"},{"layout":"post","title":"剖析 Promise 之基础篇","date":"2014-05-08T14:16:00.000Z","status":"publish","_content":"\n随着浏览器端异步操作的复杂程度日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了飞速发展。本文旨在剖析 Promise 的内部机制，从实现原理层面深入探讨，从而达到“知其然且知其所以然”，在使用 Promise 上更加熟练自如。如果你还不太了解 Promise，推荐阅读下 [promisejs.org](https://www.promisejs.org/) 的介绍。\n\n\n## 是什么\n\nPromise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 [Promises/A+](http://promisesaplus.com/)。\n\nPromise 较通常的回调、事件/消息，在处理异步操作时具有显著的优势。其中最为重要的一点是：Promise 在语义上代表了异步操作的主体。这种准确、清晰的定位极大推动了它在编程中的普及，因为具有单一职责，而且将份内事做到极致的事物总是具有病毒式的传染力。分离输入输出参数、错误冒泡、串行/并行控制流等特性都成为 Promise 横扫异步操作编程领域的重要砝码，以至于 ES6 都将其收录，并已在 Chrome、Firefox 等现代浏览器中实现。\n\n## 内部机制\n\n自从看到 Promise 的 API，我对它的实现就充满了深深的好奇，一直有心窥其究竟。接下来，将首先从最简单的基础实现开始，由浅入深的逐步探索，剖析每一个 feature 后面的故事。\n\n为了让语言上更加准确和简练，本文做如下约定：\n\n- Promise：代表由 Promises/A+ 规范所定义的异步操作封装方式；\n- promise：代表一个 Promise 实例。\n\n### 基础实现\n\n为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：\n\n```javascript\n// 例1\n\nfunction getUserId() {\n\treturn new Promise(function (resolve) {\n\t\t// 异步请求\n\t\tY.io('/userid', {\n\t\t\ton: {\n\t\t\t\tsuccess: function (id, res) {\n\t\t\t\t\tresolve(JSON.parse(res).id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n});\n```\n[JS Bin](http://jsbin.com/kebigicu/1/embed?js,console)\n\n<!-- more -->\n\n`getUserId` 方法返回一个 promise，可以通过它的 `then` 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。\n\n满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：\n\n```javascript\nfunction Promise(fn) {\n    var value = null,\n    \tdeferreds = [];\n        \n    this.then = function (onFulfilled) {\n        deferreds.push(onFulfilled);\n    };\n    \n    function resolve(value) {\n    \tdeferreds.forEach(function (deferred) {\n    \t\tdeferred(value);\n    \t});\n    }\n\n    fn(resolve);\n}\n```\n\n代码很短，逻辑也非常清晰：\n\n- 调用`then`方法，将想要在 Promise 异步操作成功时执行的回调放入 `deferreds` 队列；\n- 创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 `resolve`，用以在合适的时机触发异步操作成功。真正执行的操作是将 `deferreds` 队列中的回调一一执行；\n- `resolve` 接收一个参数，即异步操作返回的结果，方便回调使用。\n\n有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：\n\n```javascript\nthis.then = function (onFulfilled) {\n    deferreds.push(onFulfilled);\n    return this;\n};\n```\n\n这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：\n\n```javascript\n// 例2\n\ngetUserId().then(function (id) {\n\t// do sth with id\n}).then(function (id) {\n\t// do sth else with id\n});\n```\n[JS Bin](http://jsbin.com/fedukaso/2/edit?js,console)\n\n### 延时\n\n如果 promise 是同步代码，`resolve` 会先于 `then` 执行，这时 `deferreds` 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：\n\n```javascript\n// 例3\n\nfunction getUserId() {\n\treturn new Promise(function (resolve) {\n\t\tresolve(9876);\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n});\n```\n[JS Bin](http://jsbin.com/fenopelo/3/edit?js,console)\n\n此外，Promises/A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 `setTimeout` 将 `resolve` 中执行回调的逻辑放置到 JS 任务队列末尾：\n\n```javascript\nfunction resolve(value) {\n    setTimeout(function () {\n        deferreds.forEach(function (deferred) {\n    \t    deferred(value);\n        });\n    }, 0);\n}\n```\n\n### 引入状态\n\nHmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 `then` 注册的回调再也不会执行了，而这是不符合我们预期的。\n\n解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：\n\n<center>\n<img title=\"states flow\" src=\"/images/promise-states-flow.png\" />\n</center>\n\n经过改进后的代码：\n\n```javascript\nfunction Promise(fn) {\n    var state = 'pending',\n    \tvalue = null,\n    \tdeferreds = [];\n        \n    this.then = function (onFulfilled) {\n    \tif (state === 'pending') {\n        \tdeferreds.push(onFulfilled);\n        \treturn this;\n        }\n        onFulfilled(value);\n        return this;\n    };\n    \n    function resolve(newValue) {\n        value = newValue;\n    \tstate = 'fulfilled';\n        setTimeout(function () {\n            deferreds.forEach(function (deferred) {\n                deferred(value);\n            });\n        }, 0);\n    }\n\n    fn(resolve);\n}\n```\n[JS Bin](http://jsbin.com/lamewijo/2/edit?js,console)\n\n`resolve` 执行时，会将状态设置为 fulfilled，在此之后调用 `then` 添加的新回调，都会立即执行。\n\n似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。\n\n### 串行 Promise\n\n在这一小节，将要探索的是 Promise 的 Killer Feature：**串行 Promise**，这是最为有趣也最为神秘的一个功能。\n\n串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：\n\n```javascript\n// 例4\n\ngetUserId()\n    .then(getUserMobileById)\n    .then(function (mobile) {\n\t    // do sth with mobile\n    });\n\nfunction getUserMobileById(id) {\n\treturn new Promise(function (resolve) {\n\t    Y.io('/usermobile/' + id, {\n\t        on: {\n\t            success: function (i, o) {\n\t                resolve(JSON.parse(o).mobile);\n\t            }\n\t        }\n   \t    });\n\t});\n}\n```\n[JS Bin](http://jsbin.com/pibicefe/2/edit?js,console)\n\n这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。\n\n首先对 `then` 方法进行改造：\n\n```javascript\nthis.then = function (onFulfilled) {\n    return new Promise(function (resolve) {\n        handle({\n            onFulfilled: onFulfilled || null,\n            resolve: resolve\n        });\n    });\n};\n\nfunction handle(deferred) {\n    if (state === 'pending') {\n        deferreds.push(deferred);\n        return;\n    }\n    \n    var ret = deferred.onFulfilled(value);\n    deferred.resolve(ret);\n}\n```\n\n`then` 方法改变很多，这是一段暗藏玄机的代码：\n\n- `then` 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；\n- `handle` 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。`then` 方法传入的形参 `onFullfilled`，以及创建新 Promise 实例时传入的 `resolve` 均被压入当前 promise 的 `deferreds` 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。\n\n新增的 `handle` 方法，相比改造之前的 `then` 方法，仅增加了一行代码：\n\n```javascript\ndeferred.resolve(ret);\n```\n\n这意味着当前 promise 异步操作成功后执行 `handle` 方法时，先执行 `onFulfilled` 方法，然后将其返回值作为实参执行 `resolve` 方法，而这标志着后邻 promise 异步操作成功，**接力**工作就这样完成啦！\n\n以例 2 代码为例，串行 Promise 执行流如下：\n\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-simple-flow.png\" />\n</center>\n\n这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔--最后一个方法 `resolve` 是这样被改造的：\n\n```javascript\nfunction resolve(newValue) {\n    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (typeof then === 'function') {\n            then.call(newValue, resolve);\n            return;\n        }\n    }\n    state = 'fulfilled';\n    value = newValue;\n    setTimeout(function () {\n        deferreds.forEach(function (deferred) {\n            handle(deferred);\n        });\n    }, 0);\n}\n```\n\n啊哈，`resolve` 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：\n\n1. `getUserId` 生成的 promise （简称 `getUserId` promise）异步操作成功，执行其内部方法 `resolve`，传入的参数正是异步操作的结果 `userid`；\n2. 调用 `handle` 方法处理 `deferreds` 队列中的回调：`getUserMobileById` 方法，生成新的 promise（简称 `getUserMobileById` promise）；\n3. 执行之前由 `getUserId` promise 的 `then` 方法生成的 bridge promise 的 `resolve` 方法，传入参数为 `getUserMobileById` promise。这种情况下，会将该 `resolve` 方法传入 `getUserMobileById` promise 的 `then` 方法中，并直接返回；\n4. 在 `getUserMobileById` promise 异步操作成功时，执行其 `deferreds` 中的回调：`getUserId` bridge promise 的 `resolve` 方法；\n5. 最后，执行 `getUserId` bridge promise 的后邻 promise 的 `deferreds` 中的回调\n\n上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。\n\n一图胜千言，下图描述了例 4 的 Promise 执行流：\n\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-flow.png\" />\n</center>\n\n### 失败处理\n\n本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：\n\n```javascript\n// 例5\n\nfunction getUserId() {\n\treturn new Promise(function (resolve, reject) {\n\t\t// 异步请求\n\t\tY.io('/userid/1', {\n\t\t\ton: {\n\t\t\t\tsuccess: function (id, res) {\n                    var o = JSON.parse(res);\n                    if (o.status === 1) {\n                        resolve(o.id);\n                    } else {\n                        // 请求失败，返回错误信息\n                        reject(o.errorMsg);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n}, function (error) {\n    console.log(error);\n});\n```\n[JS Bin](http://jsbin.com/padolebi/2/edit?js,console)\n\n有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：\n\n```javascript\nfunction Promise(fn) {\n    var state = 'pending',\n    \tvalue = null,\n        deferreds = [];\n        \n    this.then = function (onFulfilled, onRejected) {\n        return new Promise(function (resolve, reject) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                onRejected: onRejected || null,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    };\n\n    function handle(deferred) {\n        if (state === 'pending') {\n            deferreds.push(deferred);\n            return;\n        }\n        \n        var cb = state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected,\n            ret;\n        if (cb === null) {\n            cb = state === 'fulfilled' ? deferred.resolve : deferred.reject;\n            cb(value);\n            return;\n        }\n        ret = cb(value);\n        deferred.resolve(ret);\n    }\n\n    function resolve(newValue) {\n        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n            var then = newValue.then;\n            if (typeof then === 'function') {\n                then.call(newValue, resolve, reject);\n                return;\n            }\n        }\n        state = 'fulfilled';\n        value = newValue;\n        finale();\n    }\n\n    function reject(reason) {\n        state = 'rejected';\n        value = reason;\n        finale();\n    }\n\n    function finale() {\n        setTimeout(function () {\n            deferreds.forEach(function (deferred) {\n                handle(deferred);\n            });\n        }, 0);\n    }\n\n    fn(resolve, reject);\n}\n```\n\n增加了新的 `reject` 方法，供异步操作失败时调用，同时抽出了 `resolve` 和 `reject` 共用的部分，形成 `finale` 方法。\n\n**错误冒泡**是上述代码已经支持，且非常实用的一个特性。在 `handle` 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：\n\n```javascript\n// 例6\n\ngetUserId()\n    .then(getUserMobileById)\n    .then(function (mobile) {\n\t    // do sth else with mobile\n    }, function (error) {\n        // getUserId或者getUerMobileById时出现的错误\n        console.log(error);\n    });\n```\n[JS Bin](http://jsbin.com/joqamiko/3/edit?js,console)\n\n### 异常处理\n\n如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 `try-catch` 捕获错误，并将 bridge promise 设为 rejected 状态。`handle` 方法改造如下：\n\n```javascript\nfunction handle(deferred) {\n    if (state === 'pending') {\n        deferreds.push(deferred);\n        return;\n    }\n    \n    var cb = state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected,\n        ret;\n    if (cb === null) {\n        cb = state === 'fulfilled' ? deferred.resolve : deferred.reject;\n        cb(value);\n        return;\n    }\n    try {\n        ret = cb(value);\n        deferred.resolve(ret);\n    } catch (e) {\n        deferred.reject(e);\n    } \n}\n```\n\n如果在异步操作中，多次执行 `resolve` 或者 `reject` 会重复处理后续回调，可以通过内置一个标志位解决。\n\n## 总结\n\nPromise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理/失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个[简单 Promise 实现](https://github.com/then/promise/blob/master/core.js)的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。\n\n## 预告\n\n下一篇关于 Promise 的文章中，将重点关注高阶应用的一些场景，例如并行 Promise、基于 Promise 的异步操作流封装、语法糖等。敬请期待。\n\n## 参考\n\n- [Introduction to Promises](https://www.promisejs.org/)\n- [JavaScript Promises ... In Wicked Detail](http://mattgreer.org/articles/promises-in-wicked-detail/)\n- [A Gentle Introduction to Monads in JavaScript](http://sean.voisen.org/blog/2013/10/intro-monads-maybe/)\n","source":"_posts/promise-insight.md","raw":"---\nlayout: post\ntitle: \"剖析 Promise 之基础篇\"\ndate: 2014-05-08 22:16\nstatus: publish\ntags: [Promise, Monad, JavaScript]\n---\n\n随着浏览器端异步操作的复杂程度日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了飞速发展。本文旨在剖析 Promise 的内部机制，从实现原理层面深入探讨，从而达到“知其然且知其所以然”，在使用 Promise 上更加熟练自如。如果你还不太了解 Promise，推荐阅读下 [promisejs.org](https://www.promisejs.org/) 的介绍。\n\n\n## 是什么\n\nPromise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 [Promises/A+](http://promisesaplus.com/)。\n\nPromise 较通常的回调、事件/消息，在处理异步操作时具有显著的优势。其中最为重要的一点是：Promise 在语义上代表了异步操作的主体。这种准确、清晰的定位极大推动了它在编程中的普及，因为具有单一职责，而且将份内事做到极致的事物总是具有病毒式的传染力。分离输入输出参数、错误冒泡、串行/并行控制流等特性都成为 Promise 横扫异步操作编程领域的重要砝码，以至于 ES6 都将其收录，并已在 Chrome、Firefox 等现代浏览器中实现。\n\n## 内部机制\n\n自从看到 Promise 的 API，我对它的实现就充满了深深的好奇，一直有心窥其究竟。接下来，将首先从最简单的基础实现开始，由浅入深的逐步探索，剖析每一个 feature 后面的故事。\n\n为了让语言上更加准确和简练，本文做如下约定：\n\n- Promise：代表由 Promises/A+ 规范所定义的异步操作封装方式；\n- promise：代表一个 Promise 实例。\n\n### 基础实现\n\n为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：\n\n```javascript\n// 例1\n\nfunction getUserId() {\n\treturn new Promise(function (resolve) {\n\t\t// 异步请求\n\t\tY.io('/userid', {\n\t\t\ton: {\n\t\t\t\tsuccess: function (id, res) {\n\t\t\t\t\tresolve(JSON.parse(res).id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n});\n```\n[JS Bin](http://jsbin.com/kebigicu/1/embed?js,console)\n\n<!-- more -->\n\n`getUserId` 方法返回一个 promise，可以通过它的 `then` 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。\n\n满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：\n\n```javascript\nfunction Promise(fn) {\n    var value = null,\n    \tdeferreds = [];\n        \n    this.then = function (onFulfilled) {\n        deferreds.push(onFulfilled);\n    };\n    \n    function resolve(value) {\n    \tdeferreds.forEach(function (deferred) {\n    \t\tdeferred(value);\n    \t});\n    }\n\n    fn(resolve);\n}\n```\n\n代码很短，逻辑也非常清晰：\n\n- 调用`then`方法，将想要在 Promise 异步操作成功时执行的回调放入 `deferreds` 队列；\n- 创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 `resolve`，用以在合适的时机触发异步操作成功。真正执行的操作是将 `deferreds` 队列中的回调一一执行；\n- `resolve` 接收一个参数，即异步操作返回的结果，方便回调使用。\n\n有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：\n\n```javascript\nthis.then = function (onFulfilled) {\n    deferreds.push(onFulfilled);\n    return this;\n};\n```\n\n这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：\n\n```javascript\n// 例2\n\ngetUserId().then(function (id) {\n\t// do sth with id\n}).then(function (id) {\n\t// do sth else with id\n});\n```\n[JS Bin](http://jsbin.com/fedukaso/2/edit?js,console)\n\n### 延时\n\n如果 promise 是同步代码，`resolve` 会先于 `then` 执行，这时 `deferreds` 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：\n\n```javascript\n// 例3\n\nfunction getUserId() {\n\treturn new Promise(function (resolve) {\n\t\tresolve(9876);\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n});\n```\n[JS Bin](http://jsbin.com/fenopelo/3/edit?js,console)\n\n此外，Promises/A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 `setTimeout` 将 `resolve` 中执行回调的逻辑放置到 JS 任务队列末尾：\n\n```javascript\nfunction resolve(value) {\n    setTimeout(function () {\n        deferreds.forEach(function (deferred) {\n    \t    deferred(value);\n        });\n    }, 0);\n}\n```\n\n### 引入状态\n\nHmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 `then` 注册的回调再也不会执行了，而这是不符合我们预期的。\n\n解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：\n\n<center>\n<img title=\"states flow\" src=\"/images/promise-states-flow.png\" />\n</center>\n\n经过改进后的代码：\n\n```javascript\nfunction Promise(fn) {\n    var state = 'pending',\n    \tvalue = null,\n    \tdeferreds = [];\n        \n    this.then = function (onFulfilled) {\n    \tif (state === 'pending') {\n        \tdeferreds.push(onFulfilled);\n        \treturn this;\n        }\n        onFulfilled(value);\n        return this;\n    };\n    \n    function resolve(newValue) {\n        value = newValue;\n    \tstate = 'fulfilled';\n        setTimeout(function () {\n            deferreds.forEach(function (deferred) {\n                deferred(value);\n            });\n        }, 0);\n    }\n\n    fn(resolve);\n}\n```\n[JS Bin](http://jsbin.com/lamewijo/2/edit?js,console)\n\n`resolve` 执行时，会将状态设置为 fulfilled，在此之后调用 `then` 添加的新回调，都会立即执行。\n\n似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。\n\n### 串行 Promise\n\n在这一小节，将要探索的是 Promise 的 Killer Feature：**串行 Promise**，这是最为有趣也最为神秘的一个功能。\n\n串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：\n\n```javascript\n// 例4\n\ngetUserId()\n    .then(getUserMobileById)\n    .then(function (mobile) {\n\t    // do sth with mobile\n    });\n\nfunction getUserMobileById(id) {\n\treturn new Promise(function (resolve) {\n\t    Y.io('/usermobile/' + id, {\n\t        on: {\n\t            success: function (i, o) {\n\t                resolve(JSON.parse(o).mobile);\n\t            }\n\t        }\n   \t    });\n\t});\n}\n```\n[JS Bin](http://jsbin.com/pibicefe/2/edit?js,console)\n\n这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。\n\n首先对 `then` 方法进行改造：\n\n```javascript\nthis.then = function (onFulfilled) {\n    return new Promise(function (resolve) {\n        handle({\n            onFulfilled: onFulfilled || null,\n            resolve: resolve\n        });\n    });\n};\n\nfunction handle(deferred) {\n    if (state === 'pending') {\n        deferreds.push(deferred);\n        return;\n    }\n    \n    var ret = deferred.onFulfilled(value);\n    deferred.resolve(ret);\n}\n```\n\n`then` 方法改变很多，这是一段暗藏玄机的代码：\n\n- `then` 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；\n- `handle` 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。`then` 方法传入的形参 `onFullfilled`，以及创建新 Promise 实例时传入的 `resolve` 均被压入当前 promise 的 `deferreds` 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。\n\n新增的 `handle` 方法，相比改造之前的 `then` 方法，仅增加了一行代码：\n\n```javascript\ndeferred.resolve(ret);\n```\n\n这意味着当前 promise 异步操作成功后执行 `handle` 方法时，先执行 `onFulfilled` 方法，然后将其返回值作为实参执行 `resolve` 方法，而这标志着后邻 promise 异步操作成功，**接力**工作就这样完成啦！\n\n以例 2 代码为例，串行 Promise 执行流如下：\n\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-simple-flow.png\" />\n</center>\n\n这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔--最后一个方法 `resolve` 是这样被改造的：\n\n```javascript\nfunction resolve(newValue) {\n    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (typeof then === 'function') {\n            then.call(newValue, resolve);\n            return;\n        }\n    }\n    state = 'fulfilled';\n    value = newValue;\n    setTimeout(function () {\n        deferreds.forEach(function (deferred) {\n            handle(deferred);\n        });\n    }, 0);\n}\n```\n\n啊哈，`resolve` 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：\n\n1. `getUserId` 生成的 promise （简称 `getUserId` promise）异步操作成功，执行其内部方法 `resolve`，传入的参数正是异步操作的结果 `userid`；\n2. 调用 `handle` 方法处理 `deferreds` 队列中的回调：`getUserMobileById` 方法，生成新的 promise（简称 `getUserMobileById` promise）；\n3. 执行之前由 `getUserId` promise 的 `then` 方法生成的 bridge promise 的 `resolve` 方法，传入参数为 `getUserMobileById` promise。这种情况下，会将该 `resolve` 方法传入 `getUserMobileById` promise 的 `then` 方法中，并直接返回；\n4. 在 `getUserMobileById` promise 异步操作成功时，执行其 `deferreds` 中的回调：`getUserId` bridge promise 的 `resolve` 方法；\n5. 最后，执行 `getUserId` bridge promise 的后邻 promise 的 `deferreds` 中的回调\n\n上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。\n\n一图胜千言，下图描述了例 4 的 Promise 执行流：\n\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-flow.png\" />\n</center>\n\n### 失败处理\n\n本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：\n\n```javascript\n// 例5\n\nfunction getUserId() {\n\treturn new Promise(function (resolve, reject) {\n\t\t// 异步请求\n\t\tY.io('/userid/1', {\n\t\t\ton: {\n\t\t\t\tsuccess: function (id, res) {\n                    var o = JSON.parse(res);\n                    if (o.status === 1) {\n                        resolve(o.id);\n                    } else {\n                        // 请求失败，返回错误信息\n                        reject(o.errorMsg);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\ngetUserId().then(function (id) {\n\t// do sth with id\n}, function (error) {\n    console.log(error);\n});\n```\n[JS Bin](http://jsbin.com/padolebi/2/edit?js,console)\n\n有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：\n\n```javascript\nfunction Promise(fn) {\n    var state = 'pending',\n    \tvalue = null,\n        deferreds = [];\n        \n    this.then = function (onFulfilled, onRejected) {\n        return new Promise(function (resolve, reject) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                onRejected: onRejected || null,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    };\n\n    function handle(deferred) {\n        if (state === 'pending') {\n            deferreds.push(deferred);\n            return;\n        }\n        \n        var cb = state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected,\n            ret;\n        if (cb === null) {\n            cb = state === 'fulfilled' ? deferred.resolve : deferred.reject;\n            cb(value);\n            return;\n        }\n        ret = cb(value);\n        deferred.resolve(ret);\n    }\n\n    function resolve(newValue) {\n        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n            var then = newValue.then;\n            if (typeof then === 'function') {\n                then.call(newValue, resolve, reject);\n                return;\n            }\n        }\n        state = 'fulfilled';\n        value = newValue;\n        finale();\n    }\n\n    function reject(reason) {\n        state = 'rejected';\n        value = reason;\n        finale();\n    }\n\n    function finale() {\n        setTimeout(function () {\n            deferreds.forEach(function (deferred) {\n                handle(deferred);\n            });\n        }, 0);\n    }\n\n    fn(resolve, reject);\n}\n```\n\n增加了新的 `reject` 方法，供异步操作失败时调用，同时抽出了 `resolve` 和 `reject` 共用的部分，形成 `finale` 方法。\n\n**错误冒泡**是上述代码已经支持，且非常实用的一个特性。在 `handle` 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：\n\n```javascript\n// 例6\n\ngetUserId()\n    .then(getUserMobileById)\n    .then(function (mobile) {\n\t    // do sth else with mobile\n    }, function (error) {\n        // getUserId或者getUerMobileById时出现的错误\n        console.log(error);\n    });\n```\n[JS Bin](http://jsbin.com/joqamiko/3/edit?js,console)\n\n### 异常处理\n\n如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 `try-catch` 捕获错误，并将 bridge promise 设为 rejected 状态。`handle` 方法改造如下：\n\n```javascript\nfunction handle(deferred) {\n    if (state === 'pending') {\n        deferreds.push(deferred);\n        return;\n    }\n    \n    var cb = state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected,\n        ret;\n    if (cb === null) {\n        cb = state === 'fulfilled' ? deferred.resolve : deferred.reject;\n        cb(value);\n        return;\n    }\n    try {\n        ret = cb(value);\n        deferred.resolve(ret);\n    } catch (e) {\n        deferred.reject(e);\n    } \n}\n```\n\n如果在异步操作中，多次执行 `resolve` 或者 `reject` 会重复处理后续回调，可以通过内置一个标志位解决。\n\n## 总结\n\nPromise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理/失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个[简单 Promise 实现](https://github.com/then/promise/blob/master/core.js)的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。\n\n## 预告\n\n下一篇关于 Promise 的文章中，将重点关注高阶应用的一些场景，例如并行 Promise、基于 Promise 的异步操作流封装、语法糖等。敬请期待。\n\n## 参考\n\n- [Introduction to Promises](https://www.promisejs.org/)\n- [JavaScript Promises ... In Wicked Detail](http://mattgreer.org/articles/promises-in-wicked-detail/)\n- [A Gentle Introduction to Monads in JavaScript](http://sean.voisen.org/blog/2013/10/intro-monads-maybe/)\n","slug":"promise-insight","published":1,"updated":"2021-10-05T09:20:21.060Z","comments":1,"photos":[],"link":"","_id":"cl1klgupq00148e85f3wr8c3b","content":"<p>随着浏览器端异步操作的复杂程度日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了飞速发展。本文旨在剖析 Promise 的内部机制，从实现原理层面深入探讨，从而达到“知其然且知其所以然”，在使用 Promise 上更加熟练自如。如果你还不太了解 Promise，推荐阅读下 <a href=\"https://www.promisejs.org/\">promisejs.org</a> 的介绍。</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 <a href=\"http://promisesaplus.com/\">Promises/A+</a>。</p>\n<p>Promise 较通常的回调、事件/消息，在处理异步操作时具有显著的优势。其中最为重要的一点是：Promise 在语义上代表了异步操作的主体。这种准确、清晰的定位极大推动了它在编程中的普及，因为具有单一职责，而且将份内事做到极致的事物总是具有病毒式的传染力。分离输入输出参数、错误冒泡、串行/并行控制流等特性都成为 Promise 横扫异步操作编程领域的重要砝码，以至于 ES6 都将其收录，并已在 Chrome、Firefox 等现代浏览器中实现。</p>\n<h2 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h2><p>自从看到 Promise 的 API，我对它的实现就充满了深深的好奇，一直有心窥其究竟。接下来，将首先从最简单的基础实现开始，由浅入深的逐步探索，剖析每一个 feature 后面的故事。</p>\n<p>为了让语言上更加准确和简练，本文做如下约定：</p>\n<ul>\n<li>Promise：代表由 Promises/A+ 规范所定义的异步操作封装方式；</li>\n<li>promise：代表一个 Promise 实例。</li>\n</ul>\n<h3 id=\"基础实现\"><a href=\"#基础实现\" class=\"headerlink\" title=\"基础实现\"></a>基础实现</h3><p>为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步请求</span></span><br><span class=\"line\">\t\tY.io(<span class=\"string\">&#x27;/userid&#x27;</span>, &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, res</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tresolve(<span class=\"built_in\">JSON</span>.parse(res).id);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/kebigicu/1/embed?js,console\">JS Bin</a></p>\n<span id=\"more\"></span>\n\n<p><code>getUserId</code> 方法返回一个 promise，可以通过它的 <code>then</code> 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。</p>\n<p>满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    \tdeferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">        deferreds.push(onFulfilled);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    \tdeferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    \t\tdeferred(value);</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很短，逻辑也非常清晰：</p>\n<ul>\n<li>调用<code>then</code>方法，将想要在 Promise 异步操作成功时执行的回调放入 <code>deferreds</code> 队列；</li>\n<li>创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 <code>resolve</code>，用以在合适的时机触发异步操作成功。真正执行的操作是将 <code>deferreds</code> 队列中的回调一一执行；</li>\n<li><code>resolve</code> 接收一个参数，即异步操作返回的结果，方便回调使用。</li>\n</ul>\n<p>有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    deferreds.push(onFulfilled);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth else with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/fedukaso/2/edit?js,console\">JS Bin</a></p>\n<h3 id=\"延时\"><a href=\"#延时\" class=\"headerlink\" title=\"延时\"></a>延时</h3><p>如果 promise 是同步代码，<code>resolve</code> 会先于 <code>then</code> 执行，这时 <code>deferreds</code> 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t\tresolve(<span class=\"number\">9876</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/fenopelo/3/edit?js,console\">JS Bin</a></p>\n<p>此外，Promises/A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中执行回调的逻辑放置到 JS 任务队列末尾：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    \t    deferred(value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引入状态\"><a href=\"#引入状态\" class=\"headerlink\" title=\"引入状态\"></a>引入状态</h3><p>Hmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 <code>then</code> 注册的回调再也不会执行了，而这是不符合我们预期的。</p>\n<p>解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：</p>\n<center>\n<img title=\"states flow\" src=\"/images/promise-states-flow.png\" />\n</center>\n\n<p>经过改进后的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>,</span><br><span class=\"line\">    \tvalue = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    \tdeferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        \tdeferreds.push(onFulfilled);</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        onFulfilled(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">    \tstate = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">                deferred(value);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/lamewijo/2/edit?js,console\">JS Bin</a></p>\n<p><code>resolve</code> 执行时，会将状态设置为 fulfilled，在此之后调用 <code>then</code> 添加的新回调，都会立即执行。</p>\n<p>似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。</p>\n<h3 id=\"串行-Promise\"><a href=\"#串行-Promise\" class=\"headerlink\" title=\"串行 Promise\"></a>串行 Promise</h3><p>在这一小节，将要探索的是 Promise 的 Killer Feature：<strong>串行 Promise</strong>，这是最为有趣也最为神秘的一个功能。</p>\n<p>串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId()</span><br><span class=\"line\">    .then(getUserMobileById)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mobile</span>) </span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// do sth with mobile</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserMobileById</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t    Y.io(<span class=\"string\">&#x27;/usermobile/&#x27;</span> + id, &#123;</span><br><span class=\"line\">\t        <span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t            <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i, o</span>) </span>&#123;</span><br><span class=\"line\">\t                resolve(<span class=\"built_in\">JSON</span>.parse(o).mobile);</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">   \t    &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/pibicefe/2/edit?js,console\">JS Bin</a></p>\n<p>这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。</p>\n<p>首先对 <code>then</code> 方法进行改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        handle(&#123;</span><br><span class=\"line\">            <span class=\"attr\">onFulfilled</span>: onFulfilled || <span class=\"literal\">null</span>,</span><br><span class=\"line\">            <span class=\"attr\">resolve</span>: resolve</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        deferreds.push(deferred);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = deferred.onFulfilled(value);</span><br><span class=\"line\">    deferred.resolve(ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>then</code> 方法改变很多，这是一段暗藏玄机的代码：</p>\n<ul>\n<li><code>then</code> 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；</li>\n<li><code>handle</code> 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。<code>then</code> 方法传入的形参 <code>onFullfilled</code>，以及创建新 Promise 实例时传入的 <code>resolve</code> 均被压入当前 promise 的 <code>deferreds</code> 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。</li>\n</ul>\n<p>新增的 <code>handle</code> 方法，相比改造之前的 <code>then</code> 方法，仅增加了一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deferred.resolve(ret);</span><br></pre></td></tr></table></figure>\n\n<p>这意味着当前 promise 异步操作成功后执行 <code>handle</code> 方法时，先执行 <code>onFulfilled</code> 方法，然后将其返回值作为实参执行 <code>resolve</code> 方法，而这标志着后邻 promise 异步操作成功，<strong>接力</strong>工作就这样完成啦！</p>\n<p>以例 2 代码为例，串行 Promise 执行流如下：</p>\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-simple-flow.png\" />\n</center>\n\n<p>这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔–最后一个方法 <code>resolve</code> 是这样被改造的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &amp;&amp; (<span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> then = newValue.then;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            then.call(newValue, resolve);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">            handle(deferred);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>啊哈，<code>resolve</code> 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：</p>\n<ol>\n<li><code>getUserId</code> 生成的 promise （简称 <code>getUserId</code> promise）异步操作成功，执行其内部方法 <code>resolve</code>，传入的参数正是异步操作的结果 <code>userid</code>；</li>\n<li>调用 <code>handle</code> 方法处理 <code>deferreds</code> 队列中的回调：<code>getUserMobileById</code> 方法，生成新的 promise（简称 <code>getUserMobileById</code> promise）；</li>\n<li>执行之前由 <code>getUserId</code> promise 的 <code>then</code> 方法生成的 bridge promise 的 <code>resolve</code> 方法，传入参数为 <code>getUserMobileById</code> promise。这种情况下，会将该 <code>resolve</code> 方法传入 <code>getUserMobileById</code> promise 的 <code>then</code> 方法中，并直接返回；</li>\n<li>在 <code>getUserMobileById</code> promise 异步操作成功时，执行其 <code>deferreds</code> 中的回调：<code>getUserId</code> bridge promise 的 <code>resolve</code> 方法；</li>\n<li>最后，执行 <code>getUserId</code> bridge promise 的后邻 promise 的 <code>deferreds</code> 中的回调</li>\n</ol>\n<p>上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。</p>\n<p>一图胜千言，下图描述了例 4 的 Promise 执行流：</p>\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-flow.png\" />\n</center>\n\n<h3 id=\"失败处理\"><a href=\"#失败处理\" class=\"headerlink\" title=\"失败处理\"></a>失败处理</h3><p>本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步请求</span></span><br><span class=\"line\">\t\tY.io(<span class=\"string\">&#x27;/userid/1&#x27;</span>, &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, res</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> o = <span class=\"built_in\">JSON</span>.parse(res);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (o.status === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        resolve(o.id);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 请求失败，返回错误信息</span></span><br><span class=\"line\">                        reject(o.errorMsg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/padolebi/2/edit?js,console\">JS Bin</a></p>\n<p>有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>,</span><br><span class=\"line\">    \tvalue = <span class=\"literal\">null</span>,</span><br><span class=\"line\">        deferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                <span class=\"attr\">onFulfilled</span>: onFulfilled || <span class=\"literal\">null</span>,</span><br><span class=\"line\">                <span class=\"attr\">onRejected</span>: onRejected || <span class=\"literal\">null</span>,</span><br><span class=\"line\">                <span class=\"attr\">resolve</span>: resolve,</span><br><span class=\"line\">                <span class=\"attr\">reject</span>: reject</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">            deferreds.push(deferred);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.onFulfilled : deferred.onRejected,</span><br><span class=\"line\">            ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.resolve : deferred.reject;</span><br><span class=\"line\">            cb(value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = cb(value);</span><br><span class=\"line\">        deferred.resolve(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newValue &amp;&amp; (<span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> then = newValue.then;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">                then.call(newValue, resolve, reject);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        finale();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">        value = reason;</span><br><span class=\"line\">        finale();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finale</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">                handle(deferred);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>增加了新的 <code>reject</code> 方法，供异步操作失败时调用，同时抽出了 <code>resolve</code> 和 <code>reject</code> 共用的部分，形成 <code>finale</code> 方法。</p>\n<p><strong>错误冒泡</strong>是上述代码已经支持，且非常实用的一个特性。在 <code>handle</code> 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例6</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId()</span><br><span class=\"line\">    .then(getUserMobileById)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mobile</span>) </span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// do sth else with mobile</span></span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// getUserId或者getUerMobileById时出现的错误</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/joqamiko/3/edit?js,console\">JS Bin</a></p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 <code>try-catch</code> 捕获错误，并将 bridge promise 设为 rejected 状态。<code>handle</code> 方法改造如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        deferreds.push(deferred);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.onFulfilled : deferred.onRejected,</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.resolve : deferred.reject;</span><br><span class=\"line\">        cb(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = cb(value);</span><br><span class=\"line\">        deferred.resolve(ret);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        deferred.reject(e);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在异步操作中，多次执行 <code>resolve</code> 或者 <code>reject</code> 会重复处理后续回调，可以通过内置一个标志位解决。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Promise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理/失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个<a href=\"https://github.com/then/promise/blob/master/core.js\">简单 Promise 实现</a>的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。</p>\n<h2 id=\"预告\"><a href=\"#预告\" class=\"headerlink\" title=\"预告\"></a>预告</h2><p>下一篇关于 Promise 的文章中，将重点关注高阶应用的一些场景，例如并行 Promise、基于 Promise 的异步操作流封装、语法糖等。敬请期待。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.promisejs.org/\">Introduction to Promises</a></li>\n<li><a href=\"http://mattgreer.org/articles/promises-in-wicked-detail/\">JavaScript Promises … In Wicked Detail</a></li>\n<li><a href=\"http://sean.voisen.org/blog/2013/10/intro-monads-maybe/\">A Gentle Introduction to Monads in JavaScript</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>随着浏览器端异步操作的复杂程度日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了飞速发展。本文旨在剖析 Promise 的内部机制，从实现原理层面深入探讨，从而达到“知其然且知其所以然”，在使用 Promise 上更加熟练自如。如果你还不太了解 Promise，推荐阅读下 <a href=\"https://www.promisejs.org/\">promisejs.org</a> 的介绍。</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 <a href=\"http://promisesaplus.com/\">Promises/A+</a>。</p>\n<p>Promise 较通常的回调、事件/消息，在处理异步操作时具有显著的优势。其中最为重要的一点是：Promise 在语义上代表了异步操作的主体。这种准确、清晰的定位极大推动了它在编程中的普及，因为具有单一职责，而且将份内事做到极致的事物总是具有病毒式的传染力。分离输入输出参数、错误冒泡、串行/并行控制流等特性都成为 Promise 横扫异步操作编程领域的重要砝码，以至于 ES6 都将其收录，并已在 Chrome、Firefox 等现代浏览器中实现。</p>\n<h2 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h2><p>自从看到 Promise 的 API，我对它的实现就充满了深深的好奇，一直有心窥其究竟。接下来，将首先从最简单的基础实现开始，由浅入深的逐步探索，剖析每一个 feature 后面的故事。</p>\n<p>为了让语言上更加准确和简练，本文做如下约定：</p>\n<ul>\n<li>Promise：代表由 Promises/A+ 规范所定义的异步操作封装方式；</li>\n<li>promise：代表一个 Promise 实例。</li>\n</ul>\n<h3 id=\"基础实现\"><a href=\"#基础实现\" class=\"headerlink\" title=\"基础实现\"></a>基础实现</h3><p>为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步请求</span></span><br><span class=\"line\">\t\tY.io(<span class=\"string\">&#x27;/userid&#x27;</span>, &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, res</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tresolve(<span class=\"built_in\">JSON</span>.parse(res).id);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/kebigicu/1/embed?js,console\">JS Bin</a></p>","more":"<p><code>getUserId</code> 方法返回一个 promise，可以通过它的 <code>then</code> 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。</p>\n<p>满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    \tdeferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">        deferreds.push(onFulfilled);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    \tdeferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    \t\tdeferred(value);</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很短，逻辑也非常清晰：</p>\n<ul>\n<li>调用<code>then</code>方法，将想要在 Promise 异步操作成功时执行的回调放入 <code>deferreds</code> 队列；</li>\n<li>创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 <code>resolve</code>，用以在合适的时机触发异步操作成功。真正执行的操作是将 <code>deferreds</code> 队列中的回调一一执行；</li>\n<li><code>resolve</code> 接收一个参数，即异步操作返回的结果，方便回调使用。</li>\n</ul>\n<p>有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    deferreds.push(onFulfilled);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth else with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/fedukaso/2/edit?js,console\">JS Bin</a></p>\n<h3 id=\"延时\"><a href=\"#延时\" class=\"headerlink\" title=\"延时\"></a>延时</h3><p>如果 promise 是同步代码，<code>resolve</code> 会先于 <code>then</code> 执行，这时 <code>deferreds</code> 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t\tresolve(<span class=\"number\">9876</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/fenopelo/3/edit?js,console\">JS Bin</a></p>\n<p>此外，Promises/A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中执行回调的逻辑放置到 JS 任务队列末尾：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    \t    deferred(value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引入状态\"><a href=\"#引入状态\" class=\"headerlink\" title=\"引入状态\"></a>引入状态</h3><p>Hmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 <code>then</code> 注册的回调再也不会执行了，而这是不符合我们预期的。</p>\n<p>解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：</p>\n<center>\n<img title=\"states flow\" src=\"/images/promise-states-flow.png\" />\n</center>\n\n<p>经过改进后的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>,</span><br><span class=\"line\">    \tvalue = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    \tdeferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        \tdeferreds.push(onFulfilled);</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        onFulfilled(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">    \tstate = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">                deferred(value);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/lamewijo/2/edit?js,console\">JS Bin</a></p>\n<p><code>resolve</code> 执行时，会将状态设置为 fulfilled，在此之后调用 <code>then</code> 添加的新回调，都会立即执行。</p>\n<p>似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。</p>\n<h3 id=\"串行-Promise\"><a href=\"#串行-Promise\" class=\"headerlink\" title=\"串行 Promise\"></a>串行 Promise</h3><p>在这一小节，将要探索的是 Promise 的 Killer Feature：<strong>串行 Promise</strong>，这是最为有趣也最为神秘的一个功能。</p>\n<p>串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例4</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId()</span><br><span class=\"line\">    .then(getUserMobileById)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mobile</span>) </span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// do sth with mobile</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserMobileById</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">\t    Y.io(<span class=\"string\">&#x27;/usermobile/&#x27;</span> + id, &#123;</span><br><span class=\"line\">\t        <span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t            <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i, o</span>) </span>&#123;</span><br><span class=\"line\">\t                resolve(<span class=\"built_in\">JSON</span>.parse(o).mobile);</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">   \t    &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/pibicefe/2/edit?js,console\">JS Bin</a></p>\n<p>这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。</p>\n<p>首先对 <code>then</code> 方法进行改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        handle(&#123;</span><br><span class=\"line\">            <span class=\"attr\">onFulfilled</span>: onFulfilled || <span class=\"literal\">null</span>,</span><br><span class=\"line\">            <span class=\"attr\">resolve</span>: resolve</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        deferreds.push(deferred);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = deferred.onFulfilled(value);</span><br><span class=\"line\">    deferred.resolve(ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>then</code> 方法改变很多，这是一段暗藏玄机的代码：</p>\n<ul>\n<li><code>then</code> 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；</li>\n<li><code>handle</code> 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。<code>then</code> 方法传入的形参 <code>onFullfilled</code>，以及创建新 Promise 实例时传入的 <code>resolve</code> 均被压入当前 promise 的 <code>deferreds</code> 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。</li>\n</ul>\n<p>新增的 <code>handle</code> 方法，相比改造之前的 <code>then</code> 方法，仅增加了一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deferred.resolve(ret);</span><br></pre></td></tr></table></figure>\n\n<p>这意味着当前 promise 异步操作成功后执行 <code>handle</code> 方法时，先执行 <code>onFulfilled</code> 方法，然后将其返回值作为实参执行 <code>resolve</code> 方法，而这标志着后邻 promise 异步操作成功，<strong>接力</strong>工作就这样完成啦！</p>\n<p>以例 2 代码为例，串行 Promise 执行流如下：</p>\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-simple-flow.png\" />\n</center>\n\n<p>这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔–最后一个方法 <code>resolve</code> 是这样被改造的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &amp;&amp; (<span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> then = newValue.then;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            then.call(newValue, resolve);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">            handle(deferred);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>啊哈，<code>resolve</code> 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：</p>\n<ol>\n<li><code>getUserId</code> 生成的 promise （简称 <code>getUserId</code> promise）异步操作成功，执行其内部方法 <code>resolve</code>，传入的参数正是异步操作的结果 <code>userid</code>；</li>\n<li>调用 <code>handle</code> 方法处理 <code>deferreds</code> 队列中的回调：<code>getUserMobileById</code> 方法，生成新的 promise（简称 <code>getUserMobileById</code> promise）；</li>\n<li>执行之前由 <code>getUserId</code> promise 的 <code>then</code> 方法生成的 bridge promise 的 <code>resolve</code> 方法，传入参数为 <code>getUserMobileById</code> promise。这种情况下，会将该 <code>resolve</code> 方法传入 <code>getUserMobileById</code> promise 的 <code>then</code> 方法中，并直接返回；</li>\n<li>在 <code>getUserMobileById</code> promise 异步操作成功时，执行其 <code>deferreds</code> 中的回调：<code>getUserId</code> bridge promise 的 <code>resolve</code> 方法；</li>\n<li>最后，执行 <code>getUserId</code> bridge promise 的后邻 promise 的 <code>deferreds</code> 中的回调</li>\n</ol>\n<p>上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。</p>\n<p>一图胜千言，下图描述了例 4 的 Promise 执行流：</p>\n<center>\n<img title=\"promise series flow\" src=\"/images/promise-series-flow.png\" />\n</center>\n\n<h3 id=\"失败处理\"><a href=\"#失败处理\" class=\"headerlink\" title=\"失败处理\"></a>失败处理</h3><p>本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步请求</span></span><br><span class=\"line\">\t\tY.io(<span class=\"string\">&#x27;/userid/1&#x27;</span>, &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">on</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, res</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> o = <span class=\"built_in\">JSON</span>.parse(res);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (o.status === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        resolve(o.id);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 请求失败，返回错误信息</span></span><br><span class=\"line\">                        reject(o.errorMsg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserId().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do sth with id</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/padolebi/2/edit?js,console\">JS Bin</a></p>\n<p>有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>,</span><br><span class=\"line\">    \tvalue = <span class=\"literal\">null</span>,</span><br><span class=\"line\">        deferreds = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            handle(&#123;</span><br><span class=\"line\">                <span class=\"attr\">onFulfilled</span>: onFulfilled || <span class=\"literal\">null</span>,</span><br><span class=\"line\">                <span class=\"attr\">onRejected</span>: onRejected || <span class=\"literal\">null</span>,</span><br><span class=\"line\">                <span class=\"attr\">resolve</span>: resolve,</span><br><span class=\"line\">                <span class=\"attr\">reject</span>: reject</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">            deferreds.push(deferred);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.onFulfilled : deferred.onRejected,</span><br><span class=\"line\">            ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.resolve : deferred.reject;</span><br><span class=\"line\">            cb(value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = cb(value);</span><br><span class=\"line\">        deferred.resolve(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newValue &amp;&amp; (<span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> newValue === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> then = newValue.then;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">                then.call(newValue, resolve, reject);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = <span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        finale();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">        value = reason;</span><br><span class=\"line\">        finale();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finale</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            deferreds.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">                handle(deferred);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>增加了新的 <code>reject</code> 方法，供异步操作失败时调用，同时抽出了 <code>resolve</code> 和 <code>reject</code> 共用的部分，形成 <code>finale</code> 方法。</p>\n<p><strong>错误冒泡</strong>是上述代码已经支持，且非常实用的一个特性。在 <code>handle</code> 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例6</span></span><br><span class=\"line\"></span><br><span class=\"line\">getUserId()</span><br><span class=\"line\">    .then(getUserMobileById)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mobile</span>) </span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// do sth else with mobile</span></span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// getUserId或者getUerMobileById时出现的错误</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/joqamiko/3/edit?js,console\">JS Bin</a></p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 <code>try-catch</code> 捕获错误，并将 bridge promise 设为 rejected 状态。<code>handle</code> 方法改造如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">deferred</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        deferreds.push(deferred);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.onFulfilled : deferred.onRejected,</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        cb = state === <span class=\"string\">&#x27;fulfilled&#x27;</span> ? deferred.resolve : deferred.reject;</span><br><span class=\"line\">        cb(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ret = cb(value);</span><br><span class=\"line\">        deferred.resolve(ret);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        deferred.reject(e);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在异步操作中，多次执行 <code>resolve</code> 或者 <code>reject</code> 会重复处理后续回调，可以通过内置一个标志位解决。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Promise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理/失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个<a href=\"https://github.com/then/promise/blob/master/core.js\">简单 Promise 实现</a>的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。</p>\n<h2 id=\"预告\"><a href=\"#预告\" class=\"headerlink\" title=\"预告\"></a>预告</h2><p>下一篇关于 Promise 的文章中，将重点关注高阶应用的一些场景，例如并行 Promise、基于 Promise 的异步操作流封装、语法糖等。敬请期待。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.promisejs.org/\">Introduction to Promises</a></li>\n<li><a href=\"http://mattgreer.org/articles/promises-in-wicked-detail/\">JavaScript Promises … In Wicked Detail</a></li>\n<li><a href=\"http://sean.voisen.org/blog/2013/10/intro-monads-maybe/\">A Gentle Introduction to Monads in JavaScript</a></li>\n</ul>"},{"layout":"post","title":"React Hooks 原理剖析","date":"2021-08-31T13:54:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [React Hooks 原理剖析](https://zhuanlan.zhihu.com/p/372790745) 查看全文。\n","source":"_posts/react-hooks.md","raw":"---\nlayout: post\ntitle: \"React Hooks 原理剖析\"\ndate: 2021-08-31 21:54\nstatus: publish\ntags: [React, Hooks, Web]\n---\n\n请移步知乎“前端之美”专栏 [React Hooks 原理剖析](https://zhuanlan.zhihu.com/p/372790745) 查看全文。\n","slug":"react-hooks","published":1,"updated":"2021-10-05T13:05:42.377Z","comments":1,"photos":[],"link":"","_id":"cl1klgupr00158e85hfgo91we","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/372790745\">React Hooks 原理剖析</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/372790745\">React Hooks 原理剖析</a> 查看全文。</p>\n"},{"layout":"post","title":"Javascript错误监控机制","date":"2011-11-06T12:30:00.000Z","status":"publish","_content":"\n> If an error is possible, someone will make it. The designer must assume that all possible errors will occur and design so as to minimize the chance of the error in the first place, or its effects once it gets made. Errors should be easy to detect, they should have minimal consequences, and, if possible, their effects should be reversible.\n> *--Donald Norman, author, The Design of Everyday Things*\n\n我觉得后端工程师较前端工程师最大的便利之一就是：**良好的代码监控机制**。\n\n每次后端工程师上线后，如果PHP运行中出现错误，会立即记录在error log中，并由脚本根据不同的错误级别进行邮件、短信报警。前端工程师在这方面被动很多，大多数情况下是通过用户反映给客服，然后客服再通知技术部门解决，中间的链条甚至会更长一些，因此前端方面的bug造成的影响往往较为严重。\n\n有什么办法可以缓解这一点，能够让我们在错误面前变被动为主动，第一时间解决问题呢？下面就介绍一种简单的Javascript错误监控机制。\n\n## Javascript错误模型\n\n### 生命周期\n\n<center>\n  <img alt=\"error flow\" src=\"/images/error-flow.png\" />\n</center>\n\n如上图所示，一个错误发生后，首先会被`try-catch`处理，如果没有被停止，则继续传递给`window.onerror`处理，如果没有被停止，则最终传递给浏览器控制台处理。\n\n<!-- more -->\n\n#### try-catch\n\n`try-catch`属于ECMAScript中的语句，能够捕捉到顺序执行代码中的错误，以及`throw`抛出的错误，但遗憾的是，它对于延时执行（或称异步执行，例如通过事件、计时器等触发的代码）代码却无能为力。\n\n`try-catch`捕捉到的错误会作为catch的第一个参数，记作ex，兼容性较好的一个属性为`ex.message`，此属性在IE、FireFox、Chrome中均能够较为准确的描述错误信息。例如：\n\n```js\ntry {\n    M.unexistMethod();\n} catch(ex) {\n    alert(ex.message);\n    // IE: \"Object does't support this property or method\"\n    // FF: \"M.unexistMethod is not a function\"\n    // Chrome: \"Object # has no method 'unexistMethod'\"\n}\n```\n\n被`try-catch`捕捉到的错误不会继续传播。如果需要的话，可以在`catch`中通过`throw`语句向更高层次传播错误。\n\n#### window.onerror\n\n`window.onerror`属于DOM的范畴，其支持和实现情况自然有很多差异。`window.onerror`先由IE、FireFox支持，并被加入到HTML5标准中。现在Chrome、Safari新版本均已支持，Opera在12 alpha中会增加支持。`window.onerror`可以捕获到所有类型的js错误，包括顺序、延时代码，这是它非常明显的优点。\n\n在错误的处理方面，各个浏览器也是有些差异的。例如，在js文件与页面不在同一个域时：\n\n```js\nwindow.onerror = function(msg, url, line) {\n    alert(msg + ':' + line);\n    // IE:\"Object does't support this property or method:7\"\n    // FF:\"Script error.:0\"\n    // Chrome:\"Script error.:0\"\n};\nM.unexistMethod();\n```\n\n可以看出，FireFox和Chrome下都是统一的“Script error.”，且行号错误，这样的信息除了告诉我们有错误以外没有任何意义。有人解释说这是出于同源策略的考虑。如果你的js文件与页面在同一个域中，那么恭喜，在下面的错误日志收集机制中只需使用`window.onerror`就可以了。\n\n此外，`window.onerror`在FireFox中可以捕捉到js文件加载失败的错误。\n\n### 错误日志收集\n\n综合`try-catch`和`window.onerror`两种错误捕捉方式的特点，设计一个较为简单的错误日志收集机制如下：\n\n- 考虑到`try-catch`能够获得更为准确的错误描述信息，兼容性良好，且在错误传播模型中处于最底层，所以将页面方法入口放在`try-catch`内，这样在这些方法顺序代码中出现的错误就可以被`try-catch`捕获到\n- 虽然`window.onerror`非常强大，但由于`window.onerror`在兼容性方面的问题，只将延时代码中可能出现的错误交给`window.onerror`处理\n- 捕获到错误后，使用简单强大的beacon将错误信息传递给日志服务器\n\n下面是较为精简的一份代码实现：\n\n```js\n// base.js\nvar M ＝ {\n    toQueryString: function(o) {\n        var res = [], p, encode = encodeURIComponent;\n        for (p in o) {\n             if (o.hasOwnProperty(p)) res.push(encode(p) + '=' + encode(o[p]));\n        }\n        return res.join('&');\n    },\n    beacon: function(msg) {\n        var img = new Image();\n        img.src = 'http://xxx.com/_.gif?' + msg;\n    },\n    log: function(info) {\n        M.beacon(M.toQueryString(info));\n    },\n    runMethod: function(method) {\n        try {\n            method();\n        } catch(ex) {\n            M.log({ msg: ex.message, type: 'try-catch' });\n        }\n    }\n};\nwindow.onerror = function(msg, url, line) {\n    M.log({ msg: msg, url: url, line: line, type: 'onerror' });\n    return true;\n};\n\n// app.js\nM.app = {\n    editAddress = function() {\n        var elForm = document.getElementById('address-form');\n        elForm.onsubmit = function() {\n            if (elForm.address.value === '') return false;\n        };\n        elForm.address.focus();\n    }\n};\n```\n\n```html\n<form action=\"address\" method=\"post\" id=\"address-form\">\n    <!-- the name is misspelled, so it may cause an error -->\n    <input type=\"text\" name=\"adress\" />\n    <input type=\"submit\" value=\"Submit\" />\n</form>\n<script type=\"text/javascript\" src=\"base.js\"></script>\n<script type=\"text/javascript\" src=\"app.js\"></script>\n<script>\nM.runMethod(function() {\n    M.app.editAddress();\n});\n</script>\n```\n\n完整代码见[Github](https://github.com/springuper/log-error)。\n\n## 错误日志处理\n\n由于javascript运行在种类、版本繁多的浏览器中，用户的网络情况也千差万别，直接造成的问题就是错误日志中包含很多垃圾信息，例如：\n\n- Script error.\n- Object doesn't support this property or method.\n\n这些错误信息信息量太少，不能准确描述错误的真正原因，需要进行过滤。\n\n在监听到一些描述准确的错误后，需要及时发送错误报警，形式可以为邮件、短信，这样就可以在短时间内将线上的问题反馈给前端工程师，减少错误响应时间。\n\n前端工程师终于可以放心大胆的上线了！\n\n## 参考\n\n- [HTML5标准-window.onerror](http://www.w3.org/TR/2010/WD-html5-20100624/webappapis.html#handler-window-onerror)\n- [MSDN-window.onerror](http://msdn.microsoft.com/en-us/library/cc197053%28VS.85%29.aspx)\n- [MDN-window.onerror](https://developer.mozilla.org/en/DOM/window.onerror)\n- [Enterprise JavaScript Error Handling](http://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation)\n- [Cryptic “Script Error.” reported in Javascript in Chrome and Firefox](http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox)\n","source":"_posts/js-error-catch.md","raw":"---\nlayout: post\ntitle: \"Javascript错误监控机制\"\ndate: 2011-11-06 20:30\nstatus: publish\ntags: [try-cacth, onerror]\n---\n\n> If an error is possible, someone will make it. The designer must assume that all possible errors will occur and design so as to minimize the chance of the error in the first place, or its effects once it gets made. Errors should be easy to detect, they should have minimal consequences, and, if possible, their effects should be reversible.\n> *--Donald Norman, author, The Design of Everyday Things*\n\n我觉得后端工程师较前端工程师最大的便利之一就是：**良好的代码监控机制**。\n\n每次后端工程师上线后，如果PHP运行中出现错误，会立即记录在error log中，并由脚本根据不同的错误级别进行邮件、短信报警。前端工程师在这方面被动很多，大多数情况下是通过用户反映给客服，然后客服再通知技术部门解决，中间的链条甚至会更长一些，因此前端方面的bug造成的影响往往较为严重。\n\n有什么办法可以缓解这一点，能够让我们在错误面前变被动为主动，第一时间解决问题呢？下面就介绍一种简单的Javascript错误监控机制。\n\n## Javascript错误模型\n\n### 生命周期\n\n<center>\n  <img alt=\"error flow\" src=\"/images/error-flow.png\" />\n</center>\n\n如上图所示，一个错误发生后，首先会被`try-catch`处理，如果没有被停止，则继续传递给`window.onerror`处理，如果没有被停止，则最终传递给浏览器控制台处理。\n\n<!-- more -->\n\n#### try-catch\n\n`try-catch`属于ECMAScript中的语句，能够捕捉到顺序执行代码中的错误，以及`throw`抛出的错误，但遗憾的是，它对于延时执行（或称异步执行，例如通过事件、计时器等触发的代码）代码却无能为力。\n\n`try-catch`捕捉到的错误会作为catch的第一个参数，记作ex，兼容性较好的一个属性为`ex.message`，此属性在IE、FireFox、Chrome中均能够较为准确的描述错误信息。例如：\n\n```js\ntry {\n    M.unexistMethod();\n} catch(ex) {\n    alert(ex.message);\n    // IE: \"Object does't support this property or method\"\n    // FF: \"M.unexistMethod is not a function\"\n    // Chrome: \"Object # has no method 'unexistMethod'\"\n}\n```\n\n被`try-catch`捕捉到的错误不会继续传播。如果需要的话，可以在`catch`中通过`throw`语句向更高层次传播错误。\n\n#### window.onerror\n\n`window.onerror`属于DOM的范畴，其支持和实现情况自然有很多差异。`window.onerror`先由IE、FireFox支持，并被加入到HTML5标准中。现在Chrome、Safari新版本均已支持，Opera在12 alpha中会增加支持。`window.onerror`可以捕获到所有类型的js错误，包括顺序、延时代码，这是它非常明显的优点。\n\n在错误的处理方面，各个浏览器也是有些差异的。例如，在js文件与页面不在同一个域时：\n\n```js\nwindow.onerror = function(msg, url, line) {\n    alert(msg + ':' + line);\n    // IE:\"Object does't support this property or method:7\"\n    // FF:\"Script error.:0\"\n    // Chrome:\"Script error.:0\"\n};\nM.unexistMethod();\n```\n\n可以看出，FireFox和Chrome下都是统一的“Script error.”，且行号错误，这样的信息除了告诉我们有错误以外没有任何意义。有人解释说这是出于同源策略的考虑。如果你的js文件与页面在同一个域中，那么恭喜，在下面的错误日志收集机制中只需使用`window.onerror`就可以了。\n\n此外，`window.onerror`在FireFox中可以捕捉到js文件加载失败的错误。\n\n### 错误日志收集\n\n综合`try-catch`和`window.onerror`两种错误捕捉方式的特点，设计一个较为简单的错误日志收集机制如下：\n\n- 考虑到`try-catch`能够获得更为准确的错误描述信息，兼容性良好，且在错误传播模型中处于最底层，所以将页面方法入口放在`try-catch`内，这样在这些方法顺序代码中出现的错误就可以被`try-catch`捕获到\n- 虽然`window.onerror`非常强大，但由于`window.onerror`在兼容性方面的问题，只将延时代码中可能出现的错误交给`window.onerror`处理\n- 捕获到错误后，使用简单强大的beacon将错误信息传递给日志服务器\n\n下面是较为精简的一份代码实现：\n\n```js\n// base.js\nvar M ＝ {\n    toQueryString: function(o) {\n        var res = [], p, encode = encodeURIComponent;\n        for (p in o) {\n             if (o.hasOwnProperty(p)) res.push(encode(p) + '=' + encode(o[p]));\n        }\n        return res.join('&');\n    },\n    beacon: function(msg) {\n        var img = new Image();\n        img.src = 'http://xxx.com/_.gif?' + msg;\n    },\n    log: function(info) {\n        M.beacon(M.toQueryString(info));\n    },\n    runMethod: function(method) {\n        try {\n            method();\n        } catch(ex) {\n            M.log({ msg: ex.message, type: 'try-catch' });\n        }\n    }\n};\nwindow.onerror = function(msg, url, line) {\n    M.log({ msg: msg, url: url, line: line, type: 'onerror' });\n    return true;\n};\n\n// app.js\nM.app = {\n    editAddress = function() {\n        var elForm = document.getElementById('address-form');\n        elForm.onsubmit = function() {\n            if (elForm.address.value === '') return false;\n        };\n        elForm.address.focus();\n    }\n};\n```\n\n```html\n<form action=\"address\" method=\"post\" id=\"address-form\">\n    <!-- the name is misspelled, so it may cause an error -->\n    <input type=\"text\" name=\"adress\" />\n    <input type=\"submit\" value=\"Submit\" />\n</form>\n<script type=\"text/javascript\" src=\"base.js\"></script>\n<script type=\"text/javascript\" src=\"app.js\"></script>\n<script>\nM.runMethod(function() {\n    M.app.editAddress();\n});\n</script>\n```\n\n完整代码见[Github](https://github.com/springuper/log-error)。\n\n## 错误日志处理\n\n由于javascript运行在种类、版本繁多的浏览器中，用户的网络情况也千差万别，直接造成的问题就是错误日志中包含很多垃圾信息，例如：\n\n- Script error.\n- Object doesn't support this property or method.\n\n这些错误信息信息量太少，不能准确描述错误的真正原因，需要进行过滤。\n\n在监听到一些描述准确的错误后，需要及时发送错误报警，形式可以为邮件、短信，这样就可以在短时间内将线上的问题反馈给前端工程师，减少错误响应时间。\n\n前端工程师终于可以放心大胆的上线了！\n\n## 参考\n\n- [HTML5标准-window.onerror](http://www.w3.org/TR/2010/WD-html5-20100624/webappapis.html#handler-window-onerror)\n- [MSDN-window.onerror](http://msdn.microsoft.com/en-us/library/cc197053%28VS.85%29.aspx)\n- [MDN-window.onerror](https://developer.mozilla.org/en/DOM/window.onerror)\n- [Enterprise JavaScript Error Handling](http://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation)\n- [Cryptic “Script Error.” reported in Javascript in Chrome and Firefox](http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox)\n","slug":"js-error-catch","published":1,"updated":"2021-10-05T09:33:34.983Z","comments":1,"photos":[],"link":"","_id":"cl1klgupr00168e85a8sz2i4n","content":"<blockquote>\n<p>If an error is possible, someone will make it. The designer must assume that all possible errors will occur and design so as to minimize the chance of the error in the first place, or its effects once it gets made. Errors should be easy to detect, they should have minimal consequences, and, if possible, their effects should be reversible.\n<em>–Donald Norman, author, The Design of Everyday Things</em></p>\n</blockquote>\n<p>我觉得后端工程师较前端工程师最大的便利之一就是：<strong>良好的代码监控机制</strong>。</p>\n<p>每次后端工程师上线后，如果PHP运行中出现错误，会立即记录在error log中，并由脚本根据不同的错误级别进行邮件、短信报警。前端工程师在这方面被动很多，大多数情况下是通过用户反映给客服，然后客服再通知技术部门解决，中间的链条甚至会更长一些，因此前端方面的bug造成的影响往往较为严重。</p>\n<p>有什么办法可以缓解这一点，能够让我们在错误面前变被动为主动，第一时间解决问题呢？下面就介绍一种简单的Javascript错误监控机制。</p>\n<h2 id=\"Javascript错误模型\"><a href=\"#Javascript错误模型\" class=\"headerlink\" title=\"Javascript错误模型\"></a>Javascript错误模型</h2><h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><center>\n  <img alt=\"error flow\" src=\"/images/error-flow.png\" />\n</center>\n\n<p>如上图所示，一个错误发生后，首先会被<code>try-catch</code>处理，如果没有被停止，则继续传递给<code>window.onerror</code>处理，如果没有被停止，则最终传递给浏览器控制台处理。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h4><p><code>try-catch</code>属于ECMAScript中的语句，能够捕捉到顺序执行代码中的错误，以及<code>throw</code>抛出的错误，但遗憾的是，它对于延时执行（或称异步执行，例如通过事件、计时器等触发的代码）代码却无能为力。</p>\n<p><code>try-catch</code>捕捉到的错误会作为catch的第一个参数，记作ex，兼容性较好的一个属性为<code>ex.message</code>，此属性在IE、FireFox、Chrome中均能够较为准确的描述错误信息。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    M.unexistMethod();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(ex) &#123;</span><br><span class=\"line\">    alert(ex.message);</span><br><span class=\"line\">    <span class=\"comment\">// IE: &quot;Object does&#x27;t support this property or method&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// FF: &quot;M.unexistMethod is not a function&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Chrome: &quot;Object # has no method &#x27;unexistMethod&#x27;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被<code>try-catch</code>捕捉到的错误不会继续传播。如果需要的话，可以在<code>catch</code>中通过<code>throw</code>语句向更高层次传播错误。</p>\n<h4 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h4><p><code>window.onerror</code>属于DOM的范畴，其支持和实现情况自然有很多差异。<code>window.onerror</code>先由IE、FireFox支持，并被加入到HTML5标准中。现在Chrome、Safari新版本均已支持，Opera在12 alpha中会增加支持。<code>window.onerror</code>可以捕获到所有类型的js错误，包括顺序、延时代码，这是它非常明显的优点。</p>\n<p>在错误的处理方面，各个浏览器也是有些差异的。例如，在js文件与页面不在同一个域时：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg, url, line</span>) </span>&#123;</span><br><span class=\"line\">    alert(msg + <span class=\"string\">&#x27;:&#x27;</span> + line);</span><br><span class=\"line\">    <span class=\"comment\">// IE:&quot;Object does&#x27;t support this property or method:7&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// FF:&quot;Script error.:0&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Chrome:&quot;Script error.:0&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">M.unexistMethod();</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，FireFox和Chrome下都是统一的“Script error.”，且行号错误，这样的信息除了告诉我们有错误以外没有任何意义。有人解释说这是出于同源策略的考虑。如果你的js文件与页面在同一个域中，那么恭喜，在下面的错误日志收集机制中只需使用<code>window.onerror</code>就可以了。</p>\n<p>此外，<code>window.onerror</code>在FireFox中可以捕捉到js文件加载失败的错误。</p>\n<h3 id=\"错误日志收集\"><a href=\"#错误日志收集\" class=\"headerlink\" title=\"错误日志收集\"></a>错误日志收集</h3><p>综合<code>try-catch</code>和<code>window.onerror</code>两种错误捕捉方式的特点，设计一个较为简单的错误日志收集机制如下：</p>\n<ul>\n<li>考虑到<code>try-catch</code>能够获得更为准确的错误描述信息，兼容性良好，且在错误传播模型中处于最底层，所以将页面方法入口放在<code>try-catch</code>内，这样在这些方法顺序代码中出现的错误就可以被<code>try-catch</code>捕获到</li>\n<li>虽然<code>window.onerror</code>非常强大，但由于<code>window.onerror</code>在兼容性方面的问题，只将延时代码中可能出现的错误交给<code>window.onerror</code>处理</li>\n<li>捕获到错误后，使用简单强大的beacon将错误信息传递给日志服务器</li>\n</ul>\n<p>下面是较为精简的一份代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// base.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> M ＝ &#123;</span><br><span class=\"line\">    <span class=\"attr\">toQueryString</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = [], p, encode = <span class=\"built_in\">encodeURIComponent</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (p <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (o.hasOwnProperty(p)) res.push(encode(p) + <span class=\"string\">&#x27;=&#x27;</span> + encode(o[p]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.join(<span class=\"string\">&#x27;&amp;&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">beacon</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">        img.src = <span class=\"string\">&#x27;http://xxx.com/_.gif?&#x27;</span> + msg;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">log</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>) </span>&#123;</span><br><span class=\"line\">        M.beacon(M.toQueryString(info));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">runMethod</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            method();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(ex) &#123;</span><br><span class=\"line\">            M.log(&#123; <span class=\"attr\">msg</span>: ex.message, <span class=\"attr\">type</span>: <span class=\"string\">&#x27;try-catch&#x27;</span> &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg, url, line</span>) </span>&#123;</span><br><span class=\"line\">    M.log(&#123; <span class=\"attr\">msg</span>: msg, <span class=\"attr\">url</span>: url, <span class=\"attr\">line</span>: line, <span class=\"attr\">type</span>: <span class=\"string\">&#x27;onerror&#x27;</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\">M.app = &#123;</span><br><span class=\"line\">    editAddress = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> elForm = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;address-form&#x27;</span>);</span><br><span class=\"line\">        elForm.onsubmit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elForm.address.value === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        elForm.address.focus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;address-form&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- the name is misspelled, so it may cause an error --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;adress&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Submit&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;base.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">M.runMethod(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    M.app.editAddress();</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>完整代码见<a href=\"https://github.com/springuper/log-error\">Github</a>。</p>\n<h2 id=\"错误日志处理\"><a href=\"#错误日志处理\" class=\"headerlink\" title=\"错误日志处理\"></a>错误日志处理</h2><p>由于javascript运行在种类、版本繁多的浏览器中，用户的网络情况也千差万别，直接造成的问题就是错误日志中包含很多垃圾信息，例如：</p>\n<ul>\n<li>Script error.</li>\n<li>Object doesn’t support this property or method.</li>\n</ul>\n<p>这些错误信息信息量太少，不能准确描述错误的真正原因，需要进行过滤。</p>\n<p>在监听到一些描述准确的错误后，需要及时发送错误报警，形式可以为邮件、短信，这样就可以在短时间内将线上的问题反馈给前端工程师，减少错误响应时间。</p>\n<p>前端工程师终于可以放心大胆的上线了！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.w3.org/TR/2010/WD-html5-20100624/webappapis.html#handler-window-onerror\">HTML5标准-window.onerror</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/cc197053%28VS.85%29.aspx\">MSDN-window.onerror</a></li>\n<li><a href=\"https://developer.mozilla.org/en/DOM/window.onerror\">MDN-window.onerror</a></li>\n<li><a href=\"http://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation\">Enterprise JavaScript Error Handling</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox\">Cryptic “Script Error.” reported in Javascript in Chrome and Firefox</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>If an error is possible, someone will make it. The designer must assume that all possible errors will occur and design so as to minimize the chance of the error in the first place, or its effects once it gets made. Errors should be easy to detect, they should have minimal consequences, and, if possible, their effects should be reversible.\n<em>–Donald Norman, author, The Design of Everyday Things</em></p>\n</blockquote>\n<p>我觉得后端工程师较前端工程师最大的便利之一就是：<strong>良好的代码监控机制</strong>。</p>\n<p>每次后端工程师上线后，如果PHP运行中出现错误，会立即记录在error log中，并由脚本根据不同的错误级别进行邮件、短信报警。前端工程师在这方面被动很多，大多数情况下是通过用户反映给客服，然后客服再通知技术部门解决，中间的链条甚至会更长一些，因此前端方面的bug造成的影响往往较为严重。</p>\n<p>有什么办法可以缓解这一点，能够让我们在错误面前变被动为主动，第一时间解决问题呢？下面就介绍一种简单的Javascript错误监控机制。</p>\n<h2 id=\"Javascript错误模型\"><a href=\"#Javascript错误模型\" class=\"headerlink\" title=\"Javascript错误模型\"></a>Javascript错误模型</h2><h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><center>\n  <img alt=\"error flow\" src=\"/images/error-flow.png\" />\n</center>\n\n<p>如上图所示，一个错误发生后，首先会被<code>try-catch</code>处理，如果没有被停止，则继续传递给<code>window.onerror</code>处理，如果没有被停止，则最终传递给浏览器控制台处理。</p>","more":"<h4 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h4><p><code>try-catch</code>属于ECMAScript中的语句，能够捕捉到顺序执行代码中的错误，以及<code>throw</code>抛出的错误，但遗憾的是，它对于延时执行（或称异步执行，例如通过事件、计时器等触发的代码）代码却无能为力。</p>\n<p><code>try-catch</code>捕捉到的错误会作为catch的第一个参数，记作ex，兼容性较好的一个属性为<code>ex.message</code>，此属性在IE、FireFox、Chrome中均能够较为准确的描述错误信息。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    M.unexistMethod();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(ex) &#123;</span><br><span class=\"line\">    alert(ex.message);</span><br><span class=\"line\">    <span class=\"comment\">// IE: &quot;Object does&#x27;t support this property or method&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// FF: &quot;M.unexistMethod is not a function&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Chrome: &quot;Object # has no method &#x27;unexistMethod&#x27;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被<code>try-catch</code>捕捉到的错误不会继续传播。如果需要的话，可以在<code>catch</code>中通过<code>throw</code>语句向更高层次传播错误。</p>\n<h4 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h4><p><code>window.onerror</code>属于DOM的范畴，其支持和实现情况自然有很多差异。<code>window.onerror</code>先由IE、FireFox支持，并被加入到HTML5标准中。现在Chrome、Safari新版本均已支持，Opera在12 alpha中会增加支持。<code>window.onerror</code>可以捕获到所有类型的js错误，包括顺序、延时代码，这是它非常明显的优点。</p>\n<p>在错误的处理方面，各个浏览器也是有些差异的。例如，在js文件与页面不在同一个域时：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg, url, line</span>) </span>&#123;</span><br><span class=\"line\">    alert(msg + <span class=\"string\">&#x27;:&#x27;</span> + line);</span><br><span class=\"line\">    <span class=\"comment\">// IE:&quot;Object does&#x27;t support this property or method:7&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// FF:&quot;Script error.:0&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// Chrome:&quot;Script error.:0&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">M.unexistMethod();</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，FireFox和Chrome下都是统一的“Script error.”，且行号错误，这样的信息除了告诉我们有错误以外没有任何意义。有人解释说这是出于同源策略的考虑。如果你的js文件与页面在同一个域中，那么恭喜，在下面的错误日志收集机制中只需使用<code>window.onerror</code>就可以了。</p>\n<p>此外，<code>window.onerror</code>在FireFox中可以捕捉到js文件加载失败的错误。</p>\n<h3 id=\"错误日志收集\"><a href=\"#错误日志收集\" class=\"headerlink\" title=\"错误日志收集\"></a>错误日志收集</h3><p>综合<code>try-catch</code>和<code>window.onerror</code>两种错误捕捉方式的特点，设计一个较为简单的错误日志收集机制如下：</p>\n<ul>\n<li>考虑到<code>try-catch</code>能够获得更为准确的错误描述信息，兼容性良好，且在错误传播模型中处于最底层，所以将页面方法入口放在<code>try-catch</code>内，这样在这些方法顺序代码中出现的错误就可以被<code>try-catch</code>捕获到</li>\n<li>虽然<code>window.onerror</code>非常强大，但由于<code>window.onerror</code>在兼容性方面的问题，只将延时代码中可能出现的错误交给<code>window.onerror</code>处理</li>\n<li>捕获到错误后，使用简单强大的beacon将错误信息传递给日志服务器</li>\n</ul>\n<p>下面是较为精简的一份代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// base.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> M ＝ &#123;</span><br><span class=\"line\">    <span class=\"attr\">toQueryString</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = [], p, encode = <span class=\"built_in\">encodeURIComponent</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (p <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (o.hasOwnProperty(p)) res.push(encode(p) + <span class=\"string\">&#x27;=&#x27;</span> + encode(o[p]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.join(<span class=\"string\">&#x27;&amp;&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">beacon</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">        img.src = <span class=\"string\">&#x27;http://xxx.com/_.gif?&#x27;</span> + msg;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">log</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>) </span>&#123;</span><br><span class=\"line\">        M.beacon(M.toQueryString(info));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">runMethod</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            method();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(ex) &#123;</span><br><span class=\"line\">            M.log(&#123; <span class=\"attr\">msg</span>: ex.message, <span class=\"attr\">type</span>: <span class=\"string\">&#x27;try-catch&#x27;</span> &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg, url, line</span>) </span>&#123;</span><br><span class=\"line\">    M.log(&#123; <span class=\"attr\">msg</span>: msg, <span class=\"attr\">url</span>: url, <span class=\"attr\">line</span>: line, <span class=\"attr\">type</span>: <span class=\"string\">&#x27;onerror&#x27;</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\">M.app = &#123;</span><br><span class=\"line\">    editAddress = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> elForm = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;address-form&#x27;</span>);</span><br><span class=\"line\">        elForm.onsubmit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elForm.address.value === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        elForm.address.focus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;address-form&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- the name is misspelled, so it may cause an error --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;adress&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Submit&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;base.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">M.runMethod(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    M.app.editAddress();</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>完整代码见<a href=\"https://github.com/springuper/log-error\">Github</a>。</p>\n<h2 id=\"错误日志处理\"><a href=\"#错误日志处理\" class=\"headerlink\" title=\"错误日志处理\"></a>错误日志处理</h2><p>由于javascript运行在种类、版本繁多的浏览器中，用户的网络情况也千差万别，直接造成的问题就是错误日志中包含很多垃圾信息，例如：</p>\n<ul>\n<li>Script error.</li>\n<li>Object doesn’t support this property or method.</li>\n</ul>\n<p>这些错误信息信息量太少，不能准确描述错误的真正原因，需要进行过滤。</p>\n<p>在监听到一些描述准确的错误后，需要及时发送错误报警，形式可以为邮件、短信，这样就可以在短时间内将线上的问题反馈给前端工程师，减少错误响应时间。</p>\n<p>前端工程师终于可以放心大胆的上线了！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.w3.org/TR/2010/WD-html5-20100624/webappapis.html#handler-window-onerror\">HTML5标准-window.onerror</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/cc197053%28VS.85%29.aspx\">MSDN-window.onerror</a></li>\n<li><a href=\"https://developer.mozilla.org/en/DOM/window.onerror\">MDN-window.onerror</a></li>\n<li><a href=\"http://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation\">Enterprise JavaScript Error Handling</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox\">Cryptic “Script Error.” reported in Javascript in Chrome and Firefox</a></li>\n</ul>"},{"layout":"post","title":"招聘驱动的组织建设","date":"2021-11-23T13:56:00.000Z","status":"publish","_content":"\n\n今天有一位候选人问我：“你作为团队负责人，最重要的工作是什么？”，坦白来说，我自己并没有很深刻地思考过这个问题。脱口而出的答案是：招人，招足够优秀的人。\n\n这时，我看到候选人深以为然地点了点头，似乎是非常认可我这由衷的答复。考虑到他也十足优秀，既然得到了肯定，那我不妨继续沿着这个思路畅想下，谈谈招聘驱动的组织建设。\n\n## 组织建设的核心？\n\n在我们这个工程师行业，虽然很多人声称自己是码畜，只是外表光鲜地干着搬砖的体力活。不过纵观最近 20 多年互联网的飞速发展，诚如 Paul Graham 所言，真正意义上的工程师，或者黑客，实际上是最具有可放大性和可测量性的工种之一。当你的代码跑在成百上千台机器上为百万千万甚至以亿计的用户服务时，毫无疑问你的价值也得到了巨大程度的放大。\n\n进一步，优秀的工程师和普通的工程师的差距就像太阳和灯泡一样大，虽然都能发光发热，但是数量级不一样。\n\n基于此，我粗俗地以为，工程师组织建设的核心就是招人，招足够优秀的人：\n\n- 优秀的工程师会带来优秀的解决方案，进而提升组织效能\n- 优秀的工程师会自我迭代，填满组织成长过程中的内生间隙，保障组织可持续发展\n- 优秀的工程师会自我管理，结果驱动且不断对齐组织目标，管理者更关注中长期问题\n- 最重要的是，优秀的工程师会吸引优秀的工程师\n\n<!--more-->\n\n\n## 怎样招到足够优秀的人\n\n老实说，地球人都知道优秀工程师非常好，可关键问题是：如何招到呢？\n\n其实秘诀也非常简单，那就是一开始就只招优秀工程师，一旦你的团队里有三个这样的人，剩下的就是给他们足够有挑战的事情，然后专注在业务发展上就好了。\n\n但现实很骨感：\n\n- 业务压力太大，人少活多，实在干不过来\n- 头部人才抢夺严重，成本高昂\n- 并不是所有的优秀人才都适合当前团队，水土不服的情况非常普遍\n\n个中缘由林林总总，这大概也是很多团队慢慢变得平庸的原因吧。\n\n既然今天这篇是畅想，不妨设想，如果我们的根本目标是招聘优秀人才，那这会倒逼我们做些什么决策呢？\n\n- 选择一件有意义的事情作为公司的核心业务，一方面要有梦想，另外一方面也兼具社会价值，以此来吸引初始团队\n- 维系一个小而美的优秀核心团队。如果平庸的人太多，不妨逐步提高人才密度，哪怕付出高成本，以此来稳定扩充团队\n- 适当利用外包、采购等外部杠杆，将团队的焦点维持在核心领域，以此来提高团队效能\n- 培养和发展人才，建设起健康梯队的同时，提高团队留存度\n- 通过技术交流活动、媒体传播、招聘运营活动等等方式，对外展示团队优势，获得更广泛知名度的同时，也赢得内部员工认同感\n\n## 鸡生蛋，蛋生鸡？\n\n可是没有优秀的团队，怎么会有好的业务呢？\n\n这似乎陷入了先有鸡还是先有蛋的死循环。然而众所周知，解决死循环的方式之一就是：开始的那第一个人就是个懂业务的优秀工程师！这在很多企业中比比皆是，马化腾、张小龙、任正非、雷军、李彦宏等等。\n还有一个方式就是搭班子，CEO 最先找的通常是 CTO。\n\n## 结语\n\n或许几年后，回过头来看，我会觉得这篇胡言乱语有些稚嫩，不过既然目前还算好使，就沿着这条路继续走下去。如果对你也还算是有所启发，那就是额外的大收益了。\n","source":"_posts/recruitment-driven-organization.md","raw":"---\nlayout: post\ntitle: 招聘驱动的组织建设\ndate: 2021-11-23 21:56\nstatus: publish\ntags:\n  - Recruitment\n  - Organization\n---\n\n\n今天有一位候选人问我：“你作为团队负责人，最重要的工作是什么？”，坦白来说，我自己并没有很深刻地思考过这个问题。脱口而出的答案是：招人，招足够优秀的人。\n\n这时，我看到候选人深以为然地点了点头，似乎是非常认可我这由衷的答复。考虑到他也十足优秀，既然得到了肯定，那我不妨继续沿着这个思路畅想下，谈谈招聘驱动的组织建设。\n\n## 组织建设的核心？\n\n在我们这个工程师行业，虽然很多人声称自己是码畜，只是外表光鲜地干着搬砖的体力活。不过纵观最近 20 多年互联网的飞速发展，诚如 Paul Graham 所言，真正意义上的工程师，或者黑客，实际上是最具有可放大性和可测量性的工种之一。当你的代码跑在成百上千台机器上为百万千万甚至以亿计的用户服务时，毫无疑问你的价值也得到了巨大程度的放大。\n\n进一步，优秀的工程师和普通的工程师的差距就像太阳和灯泡一样大，虽然都能发光发热，但是数量级不一样。\n\n基于此，我粗俗地以为，工程师组织建设的核心就是招人，招足够优秀的人：\n\n- 优秀的工程师会带来优秀的解决方案，进而提升组织效能\n- 优秀的工程师会自我迭代，填满组织成长过程中的内生间隙，保障组织可持续发展\n- 优秀的工程师会自我管理，结果驱动且不断对齐组织目标，管理者更关注中长期问题\n- 最重要的是，优秀的工程师会吸引优秀的工程师\n\n<!--more-->\n\n\n## 怎样招到足够优秀的人\n\n老实说，地球人都知道优秀工程师非常好，可关键问题是：如何招到呢？\n\n其实秘诀也非常简单，那就是一开始就只招优秀工程师，一旦你的团队里有三个这样的人，剩下的就是给他们足够有挑战的事情，然后专注在业务发展上就好了。\n\n但现实很骨感：\n\n- 业务压力太大，人少活多，实在干不过来\n- 头部人才抢夺严重，成本高昂\n- 并不是所有的优秀人才都适合当前团队，水土不服的情况非常普遍\n\n个中缘由林林总总，这大概也是很多团队慢慢变得平庸的原因吧。\n\n既然今天这篇是畅想，不妨设想，如果我们的根本目标是招聘优秀人才，那这会倒逼我们做些什么决策呢？\n\n- 选择一件有意义的事情作为公司的核心业务，一方面要有梦想，另外一方面也兼具社会价值，以此来吸引初始团队\n- 维系一个小而美的优秀核心团队。如果平庸的人太多，不妨逐步提高人才密度，哪怕付出高成本，以此来稳定扩充团队\n- 适当利用外包、采购等外部杠杆，将团队的焦点维持在核心领域，以此来提高团队效能\n- 培养和发展人才，建设起健康梯队的同时，提高团队留存度\n- 通过技术交流活动、媒体传播、招聘运营活动等等方式，对外展示团队优势，获得更广泛知名度的同时，也赢得内部员工认同感\n\n## 鸡生蛋，蛋生鸡？\n\n可是没有优秀的团队，怎么会有好的业务呢？\n\n这似乎陷入了先有鸡还是先有蛋的死循环。然而众所周知，解决死循环的方式之一就是：开始的那第一个人就是个懂业务的优秀工程师！这在很多企业中比比皆是，马化腾、张小龙、任正非、雷军、李彦宏等等。\n还有一个方式就是搭班子，CEO 最先找的通常是 CTO。\n\n## 结语\n\n或许几年后，回过头来看，我会觉得这篇胡言乱语有些稚嫩，不过既然目前还算好使，就沿着这条路继续走下去。如果对你也还算是有所启发，那就是额外的大收益了。\n","slug":"recruitment-driven-organization","published":1,"updated":"2021-11-25T07:35:44.261Z","comments":1,"photos":[],"link":"","_id":"cl1klgupt00198e8578wd71h8","content":"<p>今天有一位候选人问我：“你作为团队负责人，最重要的工作是什么？”，坦白来说，我自己并没有很深刻地思考过这个问题。脱口而出的答案是：招人，招足够优秀的人。</p>\n<p>这时，我看到候选人深以为然地点了点头，似乎是非常认可我这由衷的答复。考虑到他也十足优秀，既然得到了肯定，那我不妨继续沿着这个思路畅想下，谈谈招聘驱动的组织建设。</p>\n<h2 id=\"组织建设的核心？\"><a href=\"#组织建设的核心？\" class=\"headerlink\" title=\"组织建设的核心？\"></a>组织建设的核心？</h2><p>在我们这个工程师行业，虽然很多人声称自己是码畜，只是外表光鲜地干着搬砖的体力活。不过纵观最近 20 多年互联网的飞速发展，诚如 Paul Graham 所言，真正意义上的工程师，或者黑客，实际上是最具有可放大性和可测量性的工种之一。当你的代码跑在成百上千台机器上为百万千万甚至以亿计的用户服务时，毫无疑问你的价值也得到了巨大程度的放大。</p>\n<p>进一步，优秀的工程师和普通的工程师的差距就像太阳和灯泡一样大，虽然都能发光发热，但是数量级不一样。</p>\n<p>基于此，我粗俗地以为，工程师组织建设的核心就是招人，招足够优秀的人：</p>\n<ul>\n<li>优秀的工程师会带来优秀的解决方案，进而提升组织效能</li>\n<li>优秀的工程师会自我迭代，填满组织成长过程中的内生间隙，保障组织可持续发展</li>\n<li>优秀的工程师会自我管理，结果驱动且不断对齐组织目标，管理者更关注中长期问题</li>\n<li>最重要的是，优秀的工程师会吸引优秀的工程师</li>\n</ul>\n<span id=\"more\"></span>\n\n\n<h2 id=\"怎样招到足够优秀的人\"><a href=\"#怎样招到足够优秀的人\" class=\"headerlink\" title=\"怎样招到足够优秀的人\"></a>怎样招到足够优秀的人</h2><p>老实说，地球人都知道优秀工程师非常好，可关键问题是：如何招到呢？</p>\n<p>其实秘诀也非常简单，那就是一开始就只招优秀工程师，一旦你的团队里有三个这样的人，剩下的就是给他们足够有挑战的事情，然后专注在业务发展上就好了。</p>\n<p>但现实很骨感：</p>\n<ul>\n<li>业务压力太大，人少活多，实在干不过来</li>\n<li>头部人才抢夺严重，成本高昂</li>\n<li>并不是所有的优秀人才都适合当前团队，水土不服的情况非常普遍</li>\n</ul>\n<p>个中缘由林林总总，这大概也是很多团队慢慢变得平庸的原因吧。</p>\n<p>既然今天这篇是畅想，不妨设想，如果我们的根本目标是招聘优秀人才，那这会倒逼我们做些什么决策呢？</p>\n<ul>\n<li>选择一件有意义的事情作为公司的核心业务，一方面要有梦想，另外一方面也兼具社会价值，以此来吸引初始团队</li>\n<li>维系一个小而美的优秀核心团队。如果平庸的人太多，不妨逐步提高人才密度，哪怕付出高成本，以此来稳定扩充团队</li>\n<li>适当利用外包、采购等外部杠杆，将团队的焦点维持在核心领域，以此来提高团队效能</li>\n<li>培养和发展人才，建设起健康梯队的同时，提高团队留存度</li>\n<li>通过技术交流活动、媒体传播、招聘运营活动等等方式，对外展示团队优势，获得更广泛知名度的同时，也赢得内部员工认同感</li>\n</ul>\n<h2 id=\"鸡生蛋，蛋生鸡？\"><a href=\"#鸡生蛋，蛋生鸡？\" class=\"headerlink\" title=\"鸡生蛋，蛋生鸡？\"></a>鸡生蛋，蛋生鸡？</h2><p>可是没有优秀的团队，怎么会有好的业务呢？</p>\n<p>这似乎陷入了先有鸡还是先有蛋的死循环。然而众所周知，解决死循环的方式之一就是：开始的那第一个人就是个懂业务的优秀工程师！这在很多企业中比比皆是，马化腾、张小龙、任正非、雷军、李彦宏等等。\n还有一个方式就是搭班子，CEO 最先找的通常是 CTO。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>或许几年后，回过头来看，我会觉得这篇胡言乱语有些稚嫩，不过既然目前还算好使，就沿着这条路继续走下去。如果对你也还算是有所启发，那就是额外的大收益了。</p>\n","site":{"data":{}},"excerpt":"<p>今天有一位候选人问我：“你作为团队负责人，最重要的工作是什么？”，坦白来说，我自己并没有很深刻地思考过这个问题。脱口而出的答案是：招人，招足够优秀的人。</p>\n<p>这时，我看到候选人深以为然地点了点头，似乎是非常认可我这由衷的答复。考虑到他也十足优秀，既然得到了肯定，那我不妨继续沿着这个思路畅想下，谈谈招聘驱动的组织建设。</p>\n<h2 id=\"组织建设的核心？\"><a href=\"#组织建设的核心？\" class=\"headerlink\" title=\"组织建设的核心？\"></a>组织建设的核心？</h2><p>在我们这个工程师行业，虽然很多人声称自己是码畜，只是外表光鲜地干着搬砖的体力活。不过纵观最近 20 多年互联网的飞速发展，诚如 Paul Graham 所言，真正意义上的工程师，或者黑客，实际上是最具有可放大性和可测量性的工种之一。当你的代码跑在成百上千台机器上为百万千万甚至以亿计的用户服务时，毫无疑问你的价值也得到了巨大程度的放大。</p>\n<p>进一步，优秀的工程师和普通的工程师的差距就像太阳和灯泡一样大，虽然都能发光发热，但是数量级不一样。</p>\n<p>基于此，我粗俗地以为，工程师组织建设的核心就是招人，招足够优秀的人：</p>\n<ul>\n<li>优秀的工程师会带来优秀的解决方案，进而提升组织效能</li>\n<li>优秀的工程师会自我迭代，填满组织成长过程中的内生间隙，保障组织可持续发展</li>\n<li>优秀的工程师会自我管理，结果驱动且不断对齐组织目标，管理者更关注中长期问题</li>\n<li>最重要的是，优秀的工程师会吸引优秀的工程师</li>\n</ul>","more":"<h2 id=\"怎样招到足够优秀的人\"><a href=\"#怎样招到足够优秀的人\" class=\"headerlink\" title=\"怎样招到足够优秀的人\"></a>怎样招到足够优秀的人</h2><p>老实说，地球人都知道优秀工程师非常好，可关键问题是：如何招到呢？</p>\n<p>其实秘诀也非常简单，那就是一开始就只招优秀工程师，一旦你的团队里有三个这样的人，剩下的就是给他们足够有挑战的事情，然后专注在业务发展上就好了。</p>\n<p>但现实很骨感：</p>\n<ul>\n<li>业务压力太大，人少活多，实在干不过来</li>\n<li>头部人才抢夺严重，成本高昂</li>\n<li>并不是所有的优秀人才都适合当前团队，水土不服的情况非常普遍</li>\n</ul>\n<p>个中缘由林林总总，这大概也是很多团队慢慢变得平庸的原因吧。</p>\n<p>既然今天这篇是畅想，不妨设想，如果我们的根本目标是招聘优秀人才，那这会倒逼我们做些什么决策呢？</p>\n<ul>\n<li>选择一件有意义的事情作为公司的核心业务，一方面要有梦想，另外一方面也兼具社会价值，以此来吸引初始团队</li>\n<li>维系一个小而美的优秀核心团队。如果平庸的人太多，不妨逐步提高人才密度，哪怕付出高成本，以此来稳定扩充团队</li>\n<li>适当利用外包、采购等外部杠杆，将团队的焦点维持在核心领域，以此来提高团队效能</li>\n<li>培养和发展人才，建设起健康梯队的同时，提高团队留存度</li>\n<li>通过技术交流活动、媒体传播、招聘运营活动等等方式，对外展示团队优势，获得更广泛知名度的同时，也赢得内部员工认同感</li>\n</ul>\n<h2 id=\"鸡生蛋，蛋生鸡？\"><a href=\"#鸡生蛋，蛋生鸡？\" class=\"headerlink\" title=\"鸡生蛋，蛋生鸡？\"></a>鸡生蛋，蛋生鸡？</h2><p>可是没有优秀的团队，怎么会有好的业务呢？</p>\n<p>这似乎陷入了先有鸡还是先有蛋的死循环。然而众所周知，解决死循环的方式之一就是：开始的那第一个人就是个懂业务的优秀工程师！这在很多企业中比比皆是，马化腾、张小龙、任正非、雷军、李彦宏等等。\n还有一个方式就是搭班子，CEO 最先找的通常是 CTO。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>或许几年后，回过头来看，我会觉得这篇胡言乱语有些稚嫩，不过既然目前还算好使，就沿着这条路继续走下去。如果对你也还算是有所启发，那就是额外的大收益了。</p>"},{"layout":"post","title":"“觉醒年代”有感","date":"2021-08-12T14:09:00.000Z","status":"publish","_content":"\n请移步知乎“跬步千里”专栏 [“觉醒年代”有感](https://zhuanlan.zhihu.com/p/397630221) 查看全文。\n","source":"_posts/the-awakeing-age.md","raw":"---\nlayout: post\ntitle: \"“觉醒年代”有感\"\ndate: 2021-08-12 22:09\nstatus: publish\ntags: [Series, Review]\n---\n\n请移步知乎“跬步千里”专栏 [“觉醒年代”有感](https://zhuanlan.zhihu.com/p/397630221) 查看全文。\n","slug":"the-awakeing-age","published":1,"updated":"2021-10-05T13:08:42.280Z","comments":1,"photos":[],"link":"","_id":"cl1klgupt001b8e85huarb063","content":"<p>请移步知乎“跬步千里”专栏 <a href=\"https://zhuanlan.zhihu.com/p/397630221\">“觉醒年代”有感</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“跬步千里”专栏 <a href=\"https://zhuanlan.zhihu.com/p/397630221\">“觉醒年代”有感</a> 查看全文。</p>\n"},{"layout":"post","title":"浅谈 TypeScript 类型系统","date":"2019-06-22T05:53:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [浅谈 TypeScript 类型系统](https://zhuanlan.zhihu.com/p/64446259) 查看全文。\n","source":"_posts/typescript-101.md","raw":"---\nlayout: post\ntitle: \"浅谈 TypeScript 类型系统\"\ndate: 2019-06-22 13:53\nstatus: publish\ntags: [TypeScript, Type System]\n---\n\n请移步知乎“前端之美”专栏 [浅谈 TypeScript 类型系统](https://zhuanlan.zhihu.com/p/64446259) 查看全文。\n","slug":"typescript-101","published":1,"updated":"2021-10-05T13:12:02.099Z","comments":1,"photos":[],"link":"","_id":"cl1klgupu001e8e85dwqoh1hu","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/64446259\">浅谈 TypeScript 类型系统</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/64446259\">浅谈 TypeScript 类型系统</a> 查看全文。</p>\n"},{"layout":"post","title":"TypeScript 进阶","date":"2021-05-15T05:33:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [TypeScript 进阶](https://zhuanlan.zhihu.com/p/370000610) 查看全文。\n","source":"_posts/typescript-advanced.md","raw":"---\nlayout: post\ntitle: \"TypeScript 进阶\"\ndate: 2021-05-15 13:33\nstatus: publish\ntags: [TypeScript, Type System]\n---\n\n请移步知乎“前端之美”专栏 [TypeScript 进阶](https://zhuanlan.zhihu.com/p/370000610) 查看全文。\n","slug":"typescript-advanced","published":1,"updated":"2021-10-05T13:10:25.932Z","comments":1,"photos":[],"link":"","_id":"cl1klgupu001g8e85ct009jv8","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/370000610\">TypeScript 进阶</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/370000610\">TypeScript 进阶</a> 查看全文。</p>\n"},{"layout":"post","title":"w3cTech 21期在美团举行","date":"2011-08-04T12:05:00.000Z","status":"publish","_content":"\n![w3ctech in meituan](/images/w3ctech-meituan.jpg)\n\n很高兴能够作为东道主参加w3cTech。\n\n在我看来，前端行业更加团结、热情，有非常开放、分享的精神。非常喜欢这个行业的风气。\n\n此次交流会，我做了关于我们团队在YUI3方面的一些实践（[YUI3在美团](/yui3-in-meituan.html)），虽然还很初级，但我们在慢慢强大。在行进中开火，纵情向前！\n","source":"_posts/w3ctech-meituan.md","raw":"---\nlayout: post\ntitle: \"w3cTech 21期在美团举行\"\ndate: 2011-08-04 20:05\nstatus: publish\ntags: [W3CTech, Meituan, YUI]\n---\n\n![w3ctech in meituan](/images/w3ctech-meituan.jpg)\n\n很高兴能够作为东道主参加w3cTech。\n\n在我看来，前端行业更加团结、热情，有非常开放、分享的精神。非常喜欢这个行业的风气。\n\n此次交流会，我做了关于我们团队在YUI3方面的一些实践（[YUI3在美团](/yui3-in-meituan.html)），虽然还很初级，但我们在慢慢强大。在行进中开火，纵情向前！\n","slug":"w3ctech-meituan","published":1,"updated":"2021-10-05T09:33:59.162Z","comments":1,"photos":[],"link":"","_id":"cl1klgupu001i8e85brse155x","content":"<p><img src=\"/images/w3ctech-meituan.jpg\" alt=\"w3ctech in meituan\"></p>\n<p>很高兴能够作为东道主参加w3cTech。</p>\n<p>在我看来，前端行业更加团结、热情，有非常开放、分享的精神。非常喜欢这个行业的风气。</p>\n<p>此次交流会，我做了关于我们团队在YUI3方面的一些实践（<a href=\"/yui3-in-meituan.html\">YUI3在美团</a>），虽然还很初级，但我们在慢慢强大。在行进中开火，纵情向前！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/w3ctech-meituan.jpg\" alt=\"w3ctech in meituan\"></p>\n<p>很高兴能够作为东道主参加w3cTech。</p>\n<p>在我看来，前端行业更加团结、热情，有非常开放、分享的精神。非常喜欢这个行业的风气。</p>\n<p>此次交流会，我做了关于我们团队在YUI3方面的一些实践（<a href=\"/yui3-in-meituan.html\">YUI3在美团</a>），虽然还很初级，但我们在慢慢强大。在行进中开火，纵情向前！</p>\n"},{"layout":"post","title":"[译]理解Javascript关键字this","date":"2011-06-21T13:52:00.000Z","status":"publish","_content":"\n<div class=\"preface\">\n    <p>在上一次原生javascript分享时，我发现自己对this的理解仍然不够准确。在翻看了很多现有的文章后，我很失望的发现基本全是在讲种种类型的场景下this是怎样怎样，我需要的不是这些，我想看到更深入的一些解释，例如this在函数中从何而来。后来，我准备自己查阅资料后总结一篇，就在准备资料的时候我欣喜的看到了下面这篇文章，当时的心情只能用相见恨晚来表达。我认为自己不会写出更好的文章，所以就勉强翻译过来给一些E文不太好的童鞋分享，E文好的童鞋请移步，原著更加准确生动些。</p>\n    <p>原文链接：<a href=\"http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/\" target=\"_blank\">Understanding JavaScript’s this keyword</a></p>\n</div>\n\n`this`在Javascript中应用广泛，但对它的误解却比比皆是。\n\n## 你需要知道\n\n每个运行环境\\(execution context，简称环境\\)都含有一个与之关联的ThisBinding常量，它们具有相同的生命周期。运行环境分为三类：\n\n### 1. 全局环境\n\n`this`指向全局对象，在浏览器中为`window`对象。\n\n```js\nalert(this);  // window\n```\n\n<!-- more -->\n\n### 2. 函数环境\n\n至少有5种调用函数的方式，`this`的值取决于具体的调用方式。\n\n#### a) 作为属性调用\n\n`this`的值为将函数作为属性调用的基本对象\\([baseValue](http://javascriptweblog.wordpress.com/2010/08/09/variables-vs-properties-in-javascript/)\\)\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\na.b();  // a\na['b']();  // a\n\nvar c = {};\nc.d = a.b;\nc.d();  // c\n```\n\n#### b) 作为变量调用\n\n`this`指向全局对象。\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\nvar foo = a.b;\nfoo();  // window\n\nvar a = {\n    b: function() {\n        var c = function() {\n            return this;\n        };\n        return c();\n    }\n};\n\na.b();  // window\n```\n\n自执行函数\\(self-invoking functions\\)也是如此：\n\n```js\nvar a = {\n    b: function() {\n        return (function() { return this; })();\n    }\n};\n\na.b();  // window\n```\n\n#### c) 通过Function.prototype.call调用\n\n`this`的值由`call`的第一个参数决定。\n\n#### d) 通过Function.prototype.apply调用\n\n`this`的值由`apply`的第一个参数决定。\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\nvar d = {};\n\na.b.apply(d);  // d\n```\n\n#### e) 通过new作为构造器调用\n\n`this`指向新生成的对象。\n\n```js\nvar A = function() {\n    this.toString = function() { return \"I'm an A\"; };\n};\n\nnew A();  // \"I'm an A\"\n```\n\n### 3. eval环境\n\n`this`的值等于调用`eval`方法的执行环境中的`this`。\n\n```js\nalert(eval('this == window'));  // true - (except firebug, see above)\nvar a = {\n    b: function() {\n        eval('alert(this == a)');\n    }\n};\n\na.b();  // true\n```\n\n## 你也许想知道\n\n本节以ECMA 5 262为参考，对在函数环境下`this`获取值的过程做深入探究。\n\n我们从ECMA中的`this`定义开始：\n\n> 关键字this等于当前执行环境中ThisBinding的值。  *ECMA 5, 11.1.1*\n\n### ThisBinding是如何设定的呢？\n\n每个函数都定义了一个内部方法\\[\\[Call\\]\\]\\(ECMA 5, 13.2.1 [[Call]]\\) ，用来将invocation values传给该函数的执行环境：\n\n> 当控制器进入函数对象F的函数代码(function code)的执行环境时，依据调用对象提供的参数thisValue和argumentsList，执行以下步骤：\n> \n> 1. 若函数代码 (function code) 为严格代码 (strict code)，令ThisBinding等于thisValue\n> 2. 否则，若thisValue为null或undefined，令ThisBinding等于全局对象\n> 3. 否则，若thisValue不是Object类型，令thisBinding等于ToObject(thisValue)\n> 4. 否则，令thisBinding等于thisValue\n> 5. ⋯⋯\n> *ECMA 5, 10.4.3 Entering Function Code*\n\n也就是说，`ThisBinding`在`thisValue`为基本类型时设定为其强制转化对象，或者当`thisValue`为`undefined`、`null`时，设定为全局对象\\(运行于严格模式时除外，这种情况下`ThisBinding`等于`thisValue`\\)。\n\n### 那thisValue从何而来？\n\n这里我们需要回到之前提到的五种调用函数的方式：\n\n#### 1. 作为属性调用\n\n#### 2. 作为变量调用\n\n用ECMAScript的说法，这两种方式称为Function Calls，包含两个要素：MemberExpression和Arguments list。\n\n> 1. 令ref为执行MemberExpression后得到的结果\n> 2. 令func为GetValue(ref)\n> 6. 若Type(ref)是引用，则\n>     a) 若IsPropertyReference(ref)为true，令thisValue为GetBase(ref)\n>     b) 否则，ref的基本对象是一个Environment Record，令thisValue为执行GetBase(ref)的具体方法ImplicitThisValue得到的结果\n> 7. 否则，Type(ref)不是引用，则令thisValue为undefined\n> 8. 令this等于thisValue，argument values等于argList，调用func内部方法[[Call]]，并将结果返回\n> *ECMA 5, 11.2.3 Function Calls*\n\n那么，从本质来讲，`thisValue`成为函数表达式的baseValue\\(见上面第6步。译者注：baseValue为`GetBase`方法得到的结果\\)。\n\n当函数作为属性调用时，baseValue就是在点号\\(或中括号\\)前面的标识符。\n\n```js\nvar foo = {\n    bar: function() {\n        // (Comments apply to example invocation only)\n        // MemberExpression = foo.bar\n        // thisValue = foo\n        // ThisBinding = foo\n        return this;\n    }\n};\n\nfoo.bar();  // foo\nfoo['bar']();  // foo\n```\n\n对于作为变量调用的情况，`baseValue`则是变量对象\\(VariableObject，即上面提到的Environment Record\\)，变量对象属于声明式Environment Record。ECMA 10.2.1.1讲解道，声明式Environment Record的ImplicitThisValue为`undefined`。\n\n```js\nvar bar = function() { ... };\nbar();  // thisValue is undefined\n```\n\n重温上面提到过的10.4.3 Entering Function Code后，我们可以看到，除非在严格模式下，`thisValue`为`undefined`会使`ThisBinding`的值为全局对象。因此`this`在一个作为变量调用的函数中指向全局对象。\n\n```js\nvar bar = function() {\n    // (Comments apply to example invocation only)\n    // MemberExpression = bar\n    // thisValue = undefined\n    // ThisBinding = global object (e.g. window)\n    return this;\n};\n\nbar();  // window\n```\n\n#### 3. 通过Function.prototype.apply调用\n\n#### 4. 通过Function.prototype.use调用\n\n\\(规范参见15.3.4.3 Function.prototype.apply，15.3.4.4 Function.prototype.use\\)\n\n这两个小节描述了在`call`和`apply`调用函数时，函数中的`this`参数\\(它的第一个参数\\)的实际值是如何作为`thisValue`传递给10.4.3 Entering Function Code的。\\(注意，这一点不同于ECMA 3，后者规定`thisArg`的值为基本类型时需要转换为对象类型，为`null`或`undefined`时需要转化为全局对象——但这些区别通常可以忽略，因为`thisArg`的值会在目标函数调用时进行相同的转换过程\\(参见已讲过的10.4.3 Entering Function Code\\)\\)\n\n#### 5. 通过new作为构造器调用\n\n> 当函数对象F的内部方法[[Construct]]被调用时，执行以下步骤：\n> 1. 令obj为新生成的原生ECMAScript对象\n> 8. 令thisValue等于obj，args为传入[[Construct]]的参数列表，调用F内部方法[[Call]]，并将结果保存为result\n> 10. 返回obj\n> *ECMA 5, 13.2.2 [[Construct]]*\n\n显而易见，作为构造器调用函数会生成一个新的对象，它被赋给`thisValue`。这种方式与其它`this`的使用方式截然不同。\n\n## 释疑\n\n### 严格模式\n在ECMAScript的严格模式下，`thisValue`不会强制转化为一个对象。`this`的值为`null`或`undefined`时不会转化为全局对象，并且基本类型的值不会转化为包装类型对象。\n\n### bind函数\n`Function.prototype.bind`是ECMAScript 5新添加的一个方法，使用主流框架的开发者对它已经非常熟悉。基于`call`/`apply`，`bind`可以通过简单的语法预设执行环境中`thisValue`的值。这在事件响应函数中非常有用，例如一个监听按钮点击事件的函数，它的`ThisBinding`默认为`onclick`属性的`baseValue`，即按钮元素：\n\n```js\n// Bad Example: fails because ThisBinding of handler will be button\nvar sorter = function() {\n    sort: function() {\n        alert('sorting');\n    },\n    requestSorting: function() {\n        this.sort();\n    }\n};\n\n$('sortButton').onclick = sorter.requestSorting;\n\n// Good Example: sorter baked into ThisBinding of handler\nvar sorter = function() {\n    sort: function() {\n        alert('sorting');\n    },\n    requestSorting: function() {\n        this.sort();\n    }\n};\n\n$('sortButton').onclick = sorter.requestSorting.bind(sorter);\n```\n\n## 延伸阅读\n\n[ECMA 262 5th Edition \\(PDF\\)](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n\n- 11.1.1 Definition of this\n- 10.4.3 Entering Function Code\n- 11.2.3 Function Calls\n- 13.2.1 [[Call]]\n- 10.2.1.1 Declarative Environment Record \\(ImplicitThisValue\\)\n- 13.2.2 [[Construct]]\n- 15.3.4.3 Function.prototype.apply\n- 15.3.4.4 Function.prototype.call\n- 15.3.4.5 Function.prototype.bind\n- Annex C The Strict Mode of ECMAScript\n","source":"_posts/understanding-this-keyword.md","raw":"---\nlayout: post\ntitle: \"[译]理解Javascript关键字this\"\ndate: 2011-06-21 21:52\nstatus: publish\ntags: [This]\n---\n\n<div class=\"preface\">\n    <p>在上一次原生javascript分享时，我发现自己对this的理解仍然不够准确。在翻看了很多现有的文章后，我很失望的发现基本全是在讲种种类型的场景下this是怎样怎样，我需要的不是这些，我想看到更深入的一些解释，例如this在函数中从何而来。后来，我准备自己查阅资料后总结一篇，就在准备资料的时候我欣喜的看到了下面这篇文章，当时的心情只能用相见恨晚来表达。我认为自己不会写出更好的文章，所以就勉强翻译过来给一些E文不太好的童鞋分享，E文好的童鞋请移步，原著更加准确生动些。</p>\n    <p>原文链接：<a href=\"http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/\" target=\"_blank\">Understanding JavaScript’s this keyword</a></p>\n</div>\n\n`this`在Javascript中应用广泛，但对它的误解却比比皆是。\n\n## 你需要知道\n\n每个运行环境\\(execution context，简称环境\\)都含有一个与之关联的ThisBinding常量，它们具有相同的生命周期。运行环境分为三类：\n\n### 1. 全局环境\n\n`this`指向全局对象，在浏览器中为`window`对象。\n\n```js\nalert(this);  // window\n```\n\n<!-- more -->\n\n### 2. 函数环境\n\n至少有5种调用函数的方式，`this`的值取决于具体的调用方式。\n\n#### a) 作为属性调用\n\n`this`的值为将函数作为属性调用的基本对象\\([baseValue](http://javascriptweblog.wordpress.com/2010/08/09/variables-vs-properties-in-javascript/)\\)\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\na.b();  // a\na['b']();  // a\n\nvar c = {};\nc.d = a.b;\nc.d();  // c\n```\n\n#### b) 作为变量调用\n\n`this`指向全局对象。\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\nvar foo = a.b;\nfoo();  // window\n\nvar a = {\n    b: function() {\n        var c = function() {\n            return this;\n        };\n        return c();\n    }\n};\n\na.b();  // window\n```\n\n自执行函数\\(self-invoking functions\\)也是如此：\n\n```js\nvar a = {\n    b: function() {\n        return (function() { return this; })();\n    }\n};\n\na.b();  // window\n```\n\n#### c) 通过Function.prototype.call调用\n\n`this`的值由`call`的第一个参数决定。\n\n#### d) 通过Function.prototype.apply调用\n\n`this`的值由`apply`的第一个参数决定。\n\n```js\nvar a = {\n    b: function() {\n        return this;\n    }\n};\n\nvar d = {};\n\na.b.apply(d);  // d\n```\n\n#### e) 通过new作为构造器调用\n\n`this`指向新生成的对象。\n\n```js\nvar A = function() {\n    this.toString = function() { return \"I'm an A\"; };\n};\n\nnew A();  // \"I'm an A\"\n```\n\n### 3. eval环境\n\n`this`的值等于调用`eval`方法的执行环境中的`this`。\n\n```js\nalert(eval('this == window'));  // true - (except firebug, see above)\nvar a = {\n    b: function() {\n        eval('alert(this == a)');\n    }\n};\n\na.b();  // true\n```\n\n## 你也许想知道\n\n本节以ECMA 5 262为参考，对在函数环境下`this`获取值的过程做深入探究。\n\n我们从ECMA中的`this`定义开始：\n\n> 关键字this等于当前执行环境中ThisBinding的值。  *ECMA 5, 11.1.1*\n\n### ThisBinding是如何设定的呢？\n\n每个函数都定义了一个内部方法\\[\\[Call\\]\\]\\(ECMA 5, 13.2.1 [[Call]]\\) ，用来将invocation values传给该函数的执行环境：\n\n> 当控制器进入函数对象F的函数代码(function code)的执行环境时，依据调用对象提供的参数thisValue和argumentsList，执行以下步骤：\n> \n> 1. 若函数代码 (function code) 为严格代码 (strict code)，令ThisBinding等于thisValue\n> 2. 否则，若thisValue为null或undefined，令ThisBinding等于全局对象\n> 3. 否则，若thisValue不是Object类型，令thisBinding等于ToObject(thisValue)\n> 4. 否则，令thisBinding等于thisValue\n> 5. ⋯⋯\n> *ECMA 5, 10.4.3 Entering Function Code*\n\n也就是说，`ThisBinding`在`thisValue`为基本类型时设定为其强制转化对象，或者当`thisValue`为`undefined`、`null`时，设定为全局对象\\(运行于严格模式时除外，这种情况下`ThisBinding`等于`thisValue`\\)。\n\n### 那thisValue从何而来？\n\n这里我们需要回到之前提到的五种调用函数的方式：\n\n#### 1. 作为属性调用\n\n#### 2. 作为变量调用\n\n用ECMAScript的说法，这两种方式称为Function Calls，包含两个要素：MemberExpression和Arguments list。\n\n> 1. 令ref为执行MemberExpression后得到的结果\n> 2. 令func为GetValue(ref)\n> 6. 若Type(ref)是引用，则\n>     a) 若IsPropertyReference(ref)为true，令thisValue为GetBase(ref)\n>     b) 否则，ref的基本对象是一个Environment Record，令thisValue为执行GetBase(ref)的具体方法ImplicitThisValue得到的结果\n> 7. 否则，Type(ref)不是引用，则令thisValue为undefined\n> 8. 令this等于thisValue，argument values等于argList，调用func内部方法[[Call]]，并将结果返回\n> *ECMA 5, 11.2.3 Function Calls*\n\n那么，从本质来讲，`thisValue`成为函数表达式的baseValue\\(见上面第6步。译者注：baseValue为`GetBase`方法得到的结果\\)。\n\n当函数作为属性调用时，baseValue就是在点号\\(或中括号\\)前面的标识符。\n\n```js\nvar foo = {\n    bar: function() {\n        // (Comments apply to example invocation only)\n        // MemberExpression = foo.bar\n        // thisValue = foo\n        // ThisBinding = foo\n        return this;\n    }\n};\n\nfoo.bar();  // foo\nfoo['bar']();  // foo\n```\n\n对于作为变量调用的情况，`baseValue`则是变量对象\\(VariableObject，即上面提到的Environment Record\\)，变量对象属于声明式Environment Record。ECMA 10.2.1.1讲解道，声明式Environment Record的ImplicitThisValue为`undefined`。\n\n```js\nvar bar = function() { ... };\nbar();  // thisValue is undefined\n```\n\n重温上面提到过的10.4.3 Entering Function Code后，我们可以看到，除非在严格模式下，`thisValue`为`undefined`会使`ThisBinding`的值为全局对象。因此`this`在一个作为变量调用的函数中指向全局对象。\n\n```js\nvar bar = function() {\n    // (Comments apply to example invocation only)\n    // MemberExpression = bar\n    // thisValue = undefined\n    // ThisBinding = global object (e.g. window)\n    return this;\n};\n\nbar();  // window\n```\n\n#### 3. 通过Function.prototype.apply调用\n\n#### 4. 通过Function.prototype.use调用\n\n\\(规范参见15.3.4.3 Function.prototype.apply，15.3.4.4 Function.prototype.use\\)\n\n这两个小节描述了在`call`和`apply`调用函数时，函数中的`this`参数\\(它的第一个参数\\)的实际值是如何作为`thisValue`传递给10.4.3 Entering Function Code的。\\(注意，这一点不同于ECMA 3，后者规定`thisArg`的值为基本类型时需要转换为对象类型，为`null`或`undefined`时需要转化为全局对象——但这些区别通常可以忽略，因为`thisArg`的值会在目标函数调用时进行相同的转换过程\\(参见已讲过的10.4.3 Entering Function Code\\)\\)\n\n#### 5. 通过new作为构造器调用\n\n> 当函数对象F的内部方法[[Construct]]被调用时，执行以下步骤：\n> 1. 令obj为新生成的原生ECMAScript对象\n> 8. 令thisValue等于obj，args为传入[[Construct]]的参数列表，调用F内部方法[[Call]]，并将结果保存为result\n> 10. 返回obj\n> *ECMA 5, 13.2.2 [[Construct]]*\n\n显而易见，作为构造器调用函数会生成一个新的对象，它被赋给`thisValue`。这种方式与其它`this`的使用方式截然不同。\n\n## 释疑\n\n### 严格模式\n在ECMAScript的严格模式下，`thisValue`不会强制转化为一个对象。`this`的值为`null`或`undefined`时不会转化为全局对象，并且基本类型的值不会转化为包装类型对象。\n\n### bind函数\n`Function.prototype.bind`是ECMAScript 5新添加的一个方法，使用主流框架的开发者对它已经非常熟悉。基于`call`/`apply`，`bind`可以通过简单的语法预设执行环境中`thisValue`的值。这在事件响应函数中非常有用，例如一个监听按钮点击事件的函数，它的`ThisBinding`默认为`onclick`属性的`baseValue`，即按钮元素：\n\n```js\n// Bad Example: fails because ThisBinding of handler will be button\nvar sorter = function() {\n    sort: function() {\n        alert('sorting');\n    },\n    requestSorting: function() {\n        this.sort();\n    }\n};\n\n$('sortButton').onclick = sorter.requestSorting;\n\n// Good Example: sorter baked into ThisBinding of handler\nvar sorter = function() {\n    sort: function() {\n        alert('sorting');\n    },\n    requestSorting: function() {\n        this.sort();\n    }\n};\n\n$('sortButton').onclick = sorter.requestSorting.bind(sorter);\n```\n\n## 延伸阅读\n\n[ECMA 262 5th Edition \\(PDF\\)](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n\n- 11.1.1 Definition of this\n- 10.4.3 Entering Function Code\n- 11.2.3 Function Calls\n- 13.2.1 [[Call]]\n- 10.2.1.1 Declarative Environment Record \\(ImplicitThisValue\\)\n- 13.2.2 [[Construct]]\n- 15.3.4.3 Function.prototype.apply\n- 15.3.4.4 Function.prototype.call\n- 15.3.4.5 Function.prototype.bind\n- Annex C The Strict Mode of ECMAScript\n","slug":"understanding-this-keyword","published":1,"updated":"2021-10-04T12:57:16.037Z","comments":1,"photos":[],"link":"","_id":"cl1klgupv001j8e85c5nwc2ok","content":"<div class=\"preface\">\n    <p>在上一次原生javascript分享时，我发现自己对this的理解仍然不够准确。在翻看了很多现有的文章后，我很失望的发现基本全是在讲种种类型的场景下this是怎样怎样，我需要的不是这些，我想看到更深入的一些解释，例如this在函数中从何而来。后来，我准备自己查阅资料后总结一篇，就在准备资料的时候我欣喜的看到了下面这篇文章，当时的心情只能用相见恨晚来表达。我认为自己不会写出更好的文章，所以就勉强翻译过来给一些E文不太好的童鞋分享，E文好的童鞋请移步，原著更加准确生动些。</p>\n    <p>原文链接：<a href=\"http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/\" target=\"_blank\">Understanding JavaScript’s this keyword</a></p>\n</div>\n\n<p><code>this</code>在Javascript中应用广泛，但对它的误解却比比皆是。</p>\n<h2 id=\"你需要知道\"><a href=\"#你需要知道\" class=\"headerlink\" title=\"你需要知道\"></a>你需要知道</h2><p>每个运行环境(execution context，简称环境)都含有一个与之关联的ThisBinding常量，它们具有相同的生命周期。运行环境分为三类：</p>\n<h3 id=\"1-全局环境\"><a href=\"#1-全局环境\" class=\"headerlink\" title=\"1. 全局环境\"></a>1. 全局环境</h3><p><code>this</code>指向全局对象，在浏览器中为<code>window</code>对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">this</span>);  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h3 id=\"2-函数环境\"><a href=\"#2-函数环境\" class=\"headerlink\" title=\"2. 函数环境\"></a>2. 函数环境</h3><p>至少有5种调用函数的方式，<code>this</code>的值取决于具体的调用方式。</p>\n<h4 id=\"a-作为属性调用\"><a href=\"#a-作为属性调用\" class=\"headerlink\" title=\"a) 作为属性调用\"></a>a) 作为属性调用</h4><p><code>this</code>的值为将函数作为属性调用的基本对象(<a href=\"http://javascriptweblog.wordpress.com/2010/08/09/variables-vs-properties-in-javascript/\">baseValue</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// a</span></span><br><span class=\"line\">a[<span class=\"string\">&#x27;b&#x27;</span>]();  <span class=\"comment\">// a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\">c.d = a.b;</span><br><span class=\"line\">c.d();  <span class=\"comment\">// c</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-作为变量调用\"><a href=\"#b-作为变量调用\" class=\"headerlink\" title=\"b) 作为变量调用\"></a>b) 作为变量调用</h4><p><code>this</code>指向全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = a.b;</span><br><span class=\"line\">foo();  <span class=\"comment\">// window</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<p>自执行函数(self-invoking functions)也是如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-通过Function-prototype-call调用\"><a href=\"#c-通过Function-prototype-call调用\" class=\"headerlink\" title=\"c) 通过Function.prototype.call调用\"></a>c) 通过Function.prototype.call调用</h4><p><code>this</code>的值由<code>call</code>的第一个参数决定。</p>\n<h4 id=\"d-通过Function-prototype-apply调用\"><a href=\"#d-通过Function-prototype-apply调用\" class=\"headerlink\" title=\"d) 通过Function.prototype.apply调用\"></a>d) 通过Function.prototype.apply调用</h4><p><code>this</code>的值由<code>apply</code>的第一个参数决定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b.apply(d);  <span class=\"comment\">// d</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"e-通过new作为构造器调用\"><a href=\"#e-通过new作为构造器调用\" class=\"headerlink\" title=\"e) 通过new作为构造器调用\"></a>e) 通过new作为构造器调用</h4><p><code>this</code>指向新生成的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;I&#x27;m an A&quot;</span>; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> A();  <span class=\"comment\">// &quot;I&#x27;m an A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-eval环境\"><a href=\"#3-eval环境\" class=\"headerlink\" title=\"3. eval环境\"></a>3. eval环境</h3><p><code>this</code>的值等于调用<code>eval</code>方法的执行环境中的<code>this</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;this == window&#x27;</span>));  <span class=\"comment\">// true - (except firebug, see above)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;alert(this == a)&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"你也许想知道\"><a href=\"#你也许想知道\" class=\"headerlink\" title=\"你也许想知道\"></a>你也许想知道</h2><p>本节以ECMA 5 262为参考，对在函数环境下<code>this</code>获取值的过程做深入探究。</p>\n<p>我们从ECMA中的<code>this</code>定义开始：</p>\n<blockquote>\n<p>关键字this等于当前执行环境中ThisBinding的值。  <em>ECMA 5, 11.1.1</em></p>\n</blockquote>\n<h3 id=\"ThisBinding是如何设定的呢？\"><a href=\"#ThisBinding是如何设定的呢？\" class=\"headerlink\" title=\"ThisBinding是如何设定的呢？\"></a>ThisBinding是如何设定的呢？</h3><p>每个函数都定义了一个内部方法[[Call]](ECMA 5, 13.2.1 [[Call]]) ，用来将invocation values传给该函数的执行环境：</p>\n<blockquote>\n<p>当控制器进入函数对象F的函数代码(function code)的执行环境时，依据调用对象提供的参数thisValue和argumentsList，执行以下步骤：</p>\n<ol>\n<li>若函数代码 (function code) 为严格代码 (strict code)，令ThisBinding等于thisValue</li>\n<li>否则，若thisValue为null或undefined，令ThisBinding等于全局对象</li>\n<li>否则，若thisValue不是Object类型，令thisBinding等于ToObject(thisValue)</li>\n<li>否则，令thisBinding等于thisValue</li>\n<li>⋯⋯</li>\n</ol>\n<p><em>ECMA 5, 10.4.3 Entering Function Code</em></p>\n</blockquote>\n<p>也就是说，<code>ThisBinding</code>在<code>thisValue</code>为基本类型时设定为其强制转化对象，或者当<code>thisValue</code>为<code>undefined</code>、<code>null</code>时，设定为全局对象(运行于严格模式时除外，这种情况下<code>ThisBinding</code>等于<code>thisValue</code>)。</p>\n<h3 id=\"那thisValue从何而来？\"><a href=\"#那thisValue从何而来？\" class=\"headerlink\" title=\"那thisValue从何而来？\"></a>那thisValue从何而来？</h3><p>这里我们需要回到之前提到的五种调用函数的方式：</p>\n<h4 id=\"1-作为属性调用\"><a href=\"#1-作为属性调用\" class=\"headerlink\" title=\"1. 作为属性调用\"></a>1. 作为属性调用</h4><h4 id=\"2-作为变量调用\"><a href=\"#2-作为变量调用\" class=\"headerlink\" title=\"2. 作为变量调用\"></a>2. 作为变量调用</h4><p>用ECMAScript的说法，这两种方式称为Function Calls，包含两个要素：MemberExpression和Arguments list。</p>\n<blockquote>\n<ol>\n<li>令ref为执行MemberExpression后得到的结果</li>\n<li>令func为GetValue(ref)</li>\n<li>若Type(ref)是引用，则\n a) 若IsPropertyReference(ref)为true，令thisValue为GetBase(ref)\n b) 否则，ref的基本对象是一个Environment Record，令thisValue为执行GetBase(ref)的具体方法ImplicitThisValue得到的结果</li>\n<li>否则，Type(ref)不是引用，则令thisValue为undefined</li>\n<li>令this等于thisValue，argument values等于argList，调用func内部方法[[Call]]，并将结果返回</li>\n</ol>\n<p><em>ECMA 5, 11.2.3 Function Calls</em></p>\n</blockquote>\n<p>那么，从本质来讲，<code>thisValue</code>成为函数表达式的baseValue(见上面第6步。译者注：baseValue为<code>GetBase</code>方法得到的结果)。</p>\n<p>当函数作为属性调用时，baseValue就是在点号(或中括号)前面的标识符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// (Comments apply to example invocation only)</span></span><br><span class=\"line\">        <span class=\"comment\">// MemberExpression = foo.bar</span></span><br><span class=\"line\">        <span class=\"comment\">// thisValue = foo</span></span><br><span class=\"line\">        <span class=\"comment\">// ThisBinding = foo</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar();  <span class=\"comment\">// foo</span></span><br><span class=\"line\">foo[<span class=\"string\">&#x27;bar&#x27;</span>]();  <span class=\"comment\">// foo</span></span><br></pre></td></tr></table></figure>\n\n<p>对于作为变量调用的情况，<code>baseValue</code>则是变量对象(VariableObject，即上面提到的Environment Record)，变量对象属于声明式Environment Record。ECMA 10.2.1.1讲解道，声明式Environment Record的ImplicitThisValue为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;;</span><br><span class=\"line\">bar();  <span class=\"comment\">// thisValue is undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>重温上面提到过的10.4.3 Entering Function Code后，我们可以看到，除非在严格模式下，<code>thisValue</code>为<code>undefined</code>会使<code>ThisBinding</code>的值为全局对象。因此<code>this</code>在一个作为变量调用的函数中指向全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (Comments apply to example invocation only)</span></span><br><span class=\"line\">    <span class=\"comment\">// MemberExpression = bar</span></span><br><span class=\"line\">    <span class=\"comment\">// thisValue = undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// ThisBinding = global object (e.g. window)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-通过Function-prototype-apply调用\"><a href=\"#3-通过Function-prototype-apply调用\" class=\"headerlink\" title=\"3. 通过Function.prototype.apply调用\"></a>3. 通过Function.prototype.apply调用</h4><h4 id=\"4-通过Function-prototype-use调用\"><a href=\"#4-通过Function-prototype-use调用\" class=\"headerlink\" title=\"4. 通过Function.prototype.use调用\"></a>4. 通过Function.prototype.use调用</h4><p>(规范参见15.3.4.3 Function.prototype.apply，15.3.4.4 Function.prototype.use)</p>\n<p>这两个小节描述了在<code>call</code>和<code>apply</code>调用函数时，函数中的<code>this</code>参数(它的第一个参数)的实际值是如何作为<code>thisValue</code>传递给10.4.3 Entering Function Code的。(注意，这一点不同于ECMA 3，后者规定<code>thisArg</code>的值为基本类型时需要转换为对象类型，为<code>null</code>或<code>undefined</code>时需要转化为全局对象——但这些区别通常可以忽略，因为<code>thisArg</code>的值会在目标函数调用时进行相同的转换过程(参见已讲过的10.4.3 Entering Function Code))</p>\n<h4 id=\"5-通过new作为构造器调用\"><a href=\"#5-通过new作为构造器调用\" class=\"headerlink\" title=\"5. 通过new作为构造器调用\"></a>5. 通过new作为构造器调用</h4><blockquote>\n<p>当函数对象F的内部方法[[Construct]]被调用时，执行以下步骤：</p>\n<ol>\n<li>令obj为新生成的原生ECMAScript对象</li>\n<li>令thisValue等于obj，args为传入[[Construct]]的参数列表，调用F内部方法[[Call]]，并将结果保存为result</li>\n<li>返回obj</li>\n</ol>\n<p><em>ECMA 5, 13.2.2 [[Construct]]</em></p>\n</blockquote>\n<p>显而易见，作为构造器调用函数会生成一个新的对象，它被赋给<code>thisValue</code>。这种方式与其它<code>this</code>的使用方式截然不同。</p>\n<h2 id=\"释疑\"><a href=\"#释疑\" class=\"headerlink\" title=\"释疑\"></a>释疑</h2><h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>在ECMAScript的严格模式下，<code>thisValue</code>不会强制转化为一个对象。<code>this</code>的值为<code>null</code>或<code>undefined</code>时不会转化为全局对象，并且基本类型的值不会转化为包装类型对象。</p>\n<h3 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h3><p><code>Function.prototype.bind</code>是ECMAScript 5新添加的一个方法，使用主流框架的开发者对它已经非常熟悉。基于<code>call</code>/<code>apply</code>，<code>bind</code>可以通过简单的语法预设执行环境中<code>thisValue</code>的值。这在事件响应函数中非常有用，例如一个监听按钮点击事件的函数，它的<code>ThisBinding</code>默认为<code>onclick</code>属性的<code>baseValue</code>，即按钮元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bad Example: fails because ThisBinding of handler will be button</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sorter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">sort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">&#x27;sorting&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">requestSorting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;sortButton&#x27;</span>).onclick = sorter.requestSorting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Good Example: sorter baked into ThisBinding of handler</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sorter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">sort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">&#x27;sorting&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">requestSorting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;sortButton&#x27;</span>).onclick = sorter.requestSorting.bind(sorter);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h2><p><a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf\">ECMA 262 5th Edition (PDF)</a></p>\n<ul>\n<li>11.1.1 Definition of this</li>\n<li>10.4.3 Entering Function Code</li>\n<li>11.2.3 Function Calls</li>\n<li>13.2.1 [[Call]]</li>\n<li>10.2.1.1 Declarative Environment Record (ImplicitThisValue)</li>\n<li>13.2.2 [[Construct]]</li>\n<li>15.3.4.3 Function.prototype.apply</li>\n<li>15.3.4.4 Function.prototype.call</li>\n<li>15.3.4.5 Function.prototype.bind</li>\n<li>Annex C The Strict Mode of ECMAScript</li>\n</ul>\n","site":{"data":{}},"excerpt":"<div class=\"preface\">\n    <p>在上一次原生javascript分享时，我发现自己对this的理解仍然不够准确。在翻看了很多现有的文章后，我很失望的发现基本全是在讲种种类型的场景下this是怎样怎样，我需要的不是这些，我想看到更深入的一些解释，例如this在函数中从何而来。后来，我准备自己查阅资料后总结一篇，就在准备资料的时候我欣喜的看到了下面这篇文章，当时的心情只能用相见恨晚来表达。我认为自己不会写出更好的文章，所以就勉强翻译过来给一些E文不太好的童鞋分享，E文好的童鞋请移步，原著更加准确生动些。</p>\n    <p>原文链接：<a href=\"http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/\" target=\"_blank\">Understanding JavaScript’s this keyword</a></p>\n</div>\n\n<p><code>this</code>在Javascript中应用广泛，但对它的误解却比比皆是。</p>\n<h2 id=\"你需要知道\"><a href=\"#你需要知道\" class=\"headerlink\" title=\"你需要知道\"></a>你需要知道</h2><p>每个运行环境(execution context，简称环境)都含有一个与之关联的ThisBinding常量，它们具有相同的生命周期。运行环境分为三类：</p>\n<h3 id=\"1-全局环境\"><a href=\"#1-全局环境\" class=\"headerlink\" title=\"1. 全局环境\"></a>1. 全局环境</h3><p><code>this</code>指向全局对象，在浏览器中为<code>window</code>对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">this</span>);  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-函数环境\"><a href=\"#2-函数环境\" class=\"headerlink\" title=\"2. 函数环境\"></a>2. 函数环境</h3><p>至少有5种调用函数的方式，<code>this</code>的值取决于具体的调用方式。</p>\n<h4 id=\"a-作为属性调用\"><a href=\"#a-作为属性调用\" class=\"headerlink\" title=\"a) 作为属性调用\"></a>a) 作为属性调用</h4><p><code>this</code>的值为将函数作为属性调用的基本对象(<a href=\"http://javascriptweblog.wordpress.com/2010/08/09/variables-vs-properties-in-javascript/\">baseValue</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// a</span></span><br><span class=\"line\">a[<span class=\"string\">&#x27;b&#x27;</span>]();  <span class=\"comment\">// a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\">c.d = a.b;</span><br><span class=\"line\">c.d();  <span class=\"comment\">// c</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-作为变量调用\"><a href=\"#b-作为变量调用\" class=\"headerlink\" title=\"b) 作为变量调用\"></a>b) 作为变量调用</h4><p><code>this</code>指向全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = a.b;</span><br><span class=\"line\">foo();  <span class=\"comment\">// window</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<p>自执行函数(self-invoking functions)也是如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-通过Function-prototype-call调用\"><a href=\"#c-通过Function-prototype-call调用\" class=\"headerlink\" title=\"c) 通过Function.prototype.call调用\"></a>c) 通过Function.prototype.call调用</h4><p><code>this</code>的值由<code>call</code>的第一个参数决定。</p>\n<h4 id=\"d-通过Function-prototype-apply调用\"><a href=\"#d-通过Function-prototype-apply调用\" class=\"headerlink\" title=\"d) 通过Function.prototype.apply调用\"></a>d) 通过Function.prototype.apply调用</h4><p><code>this</code>的值由<code>apply</code>的第一个参数决定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b.apply(d);  <span class=\"comment\">// d</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"e-通过new作为构造器调用\"><a href=\"#e-通过new作为构造器调用\" class=\"headerlink\" title=\"e) 通过new作为构造器调用\"></a>e) 通过new作为构造器调用</h4><p><code>this</code>指向新生成的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;I&#x27;m an A&quot;</span>; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> A();  <span class=\"comment\">// &quot;I&#x27;m an A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-eval环境\"><a href=\"#3-eval环境\" class=\"headerlink\" title=\"3. eval环境\"></a>3. eval环境</h3><p><code>this</code>的值等于调用<code>eval</code>方法的执行环境中的<code>this</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;this == window&#x27;</span>));  <span class=\"comment\">// true - (except firebug, see above)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;alert(this == a)&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.b();  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"你也许想知道\"><a href=\"#你也许想知道\" class=\"headerlink\" title=\"你也许想知道\"></a>你也许想知道</h2><p>本节以ECMA 5 262为参考，对在函数环境下<code>this</code>获取值的过程做深入探究。</p>\n<p>我们从ECMA中的<code>this</code>定义开始：</p>\n<blockquote>\n<p>关键字this等于当前执行环境中ThisBinding的值。  <em>ECMA 5, 11.1.1</em></p>\n</blockquote>\n<h3 id=\"ThisBinding是如何设定的呢？\"><a href=\"#ThisBinding是如何设定的呢？\" class=\"headerlink\" title=\"ThisBinding是如何设定的呢？\"></a>ThisBinding是如何设定的呢？</h3><p>每个函数都定义了一个内部方法[[Call]](ECMA 5, 13.2.1 [[Call]]) ，用来将invocation values传给该函数的执行环境：</p>\n<blockquote>\n<p>当控制器进入函数对象F的函数代码(function code)的执行环境时，依据调用对象提供的参数thisValue和argumentsList，执行以下步骤：</p>\n<ol>\n<li>若函数代码 (function code) 为严格代码 (strict code)，令ThisBinding等于thisValue</li>\n<li>否则，若thisValue为null或undefined，令ThisBinding等于全局对象</li>\n<li>否则，若thisValue不是Object类型，令thisBinding等于ToObject(thisValue)</li>\n<li>否则，令thisBinding等于thisValue</li>\n<li>⋯⋯</li>\n</ol>\n<p><em>ECMA 5, 10.4.3 Entering Function Code</em></p>\n</blockquote>\n<p>也就是说，<code>ThisBinding</code>在<code>thisValue</code>为基本类型时设定为其强制转化对象，或者当<code>thisValue</code>为<code>undefined</code>、<code>null</code>时，设定为全局对象(运行于严格模式时除外，这种情况下<code>ThisBinding</code>等于<code>thisValue</code>)。</p>\n<h3 id=\"那thisValue从何而来？\"><a href=\"#那thisValue从何而来？\" class=\"headerlink\" title=\"那thisValue从何而来？\"></a>那thisValue从何而来？</h3><p>这里我们需要回到之前提到的五种调用函数的方式：</p>\n<h4 id=\"1-作为属性调用\"><a href=\"#1-作为属性调用\" class=\"headerlink\" title=\"1. 作为属性调用\"></a>1. 作为属性调用</h4><h4 id=\"2-作为变量调用\"><a href=\"#2-作为变量调用\" class=\"headerlink\" title=\"2. 作为变量调用\"></a>2. 作为变量调用</h4><p>用ECMAScript的说法，这两种方式称为Function Calls，包含两个要素：MemberExpression和Arguments list。</p>\n<blockquote>\n<ol>\n<li>令ref为执行MemberExpression后得到的结果</li>\n<li>令func为GetValue(ref)</li>\n<li>若Type(ref)是引用，则\n a) 若IsPropertyReference(ref)为true，令thisValue为GetBase(ref)\n b) 否则，ref的基本对象是一个Environment Record，令thisValue为执行GetBase(ref)的具体方法ImplicitThisValue得到的结果</li>\n<li>否则，Type(ref)不是引用，则令thisValue为undefined</li>\n<li>令this等于thisValue，argument values等于argList，调用func内部方法[[Call]]，并将结果返回</li>\n</ol>\n<p><em>ECMA 5, 11.2.3 Function Calls</em></p>\n</blockquote>\n<p>那么，从本质来讲，<code>thisValue</code>成为函数表达式的baseValue(见上面第6步。译者注：baseValue为<code>GetBase</code>方法得到的结果)。</p>\n<p>当函数作为属性调用时，baseValue就是在点号(或中括号)前面的标识符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// (Comments apply to example invocation only)</span></span><br><span class=\"line\">        <span class=\"comment\">// MemberExpression = foo.bar</span></span><br><span class=\"line\">        <span class=\"comment\">// thisValue = foo</span></span><br><span class=\"line\">        <span class=\"comment\">// ThisBinding = foo</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar();  <span class=\"comment\">// foo</span></span><br><span class=\"line\">foo[<span class=\"string\">&#x27;bar&#x27;</span>]();  <span class=\"comment\">// foo</span></span><br></pre></td></tr></table></figure>\n\n<p>对于作为变量调用的情况，<code>baseValue</code>则是变量对象(VariableObject，即上面提到的Environment Record)，变量对象属于声明式Environment Record。ECMA 10.2.1.1讲解道，声明式Environment Record的ImplicitThisValue为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;;</span><br><span class=\"line\">bar();  <span class=\"comment\">// thisValue is undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>重温上面提到过的10.4.3 Entering Function Code后，我们可以看到，除非在严格模式下，<code>thisValue</code>为<code>undefined</code>会使<code>ThisBinding</code>的值为全局对象。因此<code>this</code>在一个作为变量调用的函数中指向全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (Comments apply to example invocation only)</span></span><br><span class=\"line\">    <span class=\"comment\">// MemberExpression = bar</span></span><br><span class=\"line\">    <span class=\"comment\">// thisValue = undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// ThisBinding = global object (e.g. window)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-通过Function-prototype-apply调用\"><a href=\"#3-通过Function-prototype-apply调用\" class=\"headerlink\" title=\"3. 通过Function.prototype.apply调用\"></a>3. 通过Function.prototype.apply调用</h4><h4 id=\"4-通过Function-prototype-use调用\"><a href=\"#4-通过Function-prototype-use调用\" class=\"headerlink\" title=\"4. 通过Function.prototype.use调用\"></a>4. 通过Function.prototype.use调用</h4><p>(规范参见15.3.4.3 Function.prototype.apply，15.3.4.4 Function.prototype.use)</p>\n<p>这两个小节描述了在<code>call</code>和<code>apply</code>调用函数时，函数中的<code>this</code>参数(它的第一个参数)的实际值是如何作为<code>thisValue</code>传递给10.4.3 Entering Function Code的。(注意，这一点不同于ECMA 3，后者规定<code>thisArg</code>的值为基本类型时需要转换为对象类型，为<code>null</code>或<code>undefined</code>时需要转化为全局对象——但这些区别通常可以忽略，因为<code>thisArg</code>的值会在目标函数调用时进行相同的转换过程(参见已讲过的10.4.3 Entering Function Code))</p>\n<h4 id=\"5-通过new作为构造器调用\"><a href=\"#5-通过new作为构造器调用\" class=\"headerlink\" title=\"5. 通过new作为构造器调用\"></a>5. 通过new作为构造器调用</h4><blockquote>\n<p>当函数对象F的内部方法[[Construct]]被调用时，执行以下步骤：</p>\n<ol>\n<li>令obj为新生成的原生ECMAScript对象</li>\n<li>令thisValue等于obj，args为传入[[Construct]]的参数列表，调用F内部方法[[Call]]，并将结果保存为result</li>\n<li>返回obj</li>\n</ol>\n<p><em>ECMA 5, 13.2.2 [[Construct]]</em></p>\n</blockquote>\n<p>显而易见，作为构造器调用函数会生成一个新的对象，它被赋给<code>thisValue</code>。这种方式与其它<code>this</code>的使用方式截然不同。</p>\n<h2 id=\"释疑\"><a href=\"#释疑\" class=\"headerlink\" title=\"释疑\"></a>释疑</h2><h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>在ECMAScript的严格模式下，<code>thisValue</code>不会强制转化为一个对象。<code>this</code>的值为<code>null</code>或<code>undefined</code>时不会转化为全局对象，并且基本类型的值不会转化为包装类型对象。</p>\n<h3 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h3><p><code>Function.prototype.bind</code>是ECMAScript 5新添加的一个方法，使用主流框架的开发者对它已经非常熟悉。基于<code>call</code>/<code>apply</code>，<code>bind</code>可以通过简单的语法预设执行环境中<code>thisValue</code>的值。这在事件响应函数中非常有用，例如一个监听按钮点击事件的函数，它的<code>ThisBinding</code>默认为<code>onclick</code>属性的<code>baseValue</code>，即按钮元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bad Example: fails because ThisBinding of handler will be button</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sorter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">sort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">&#x27;sorting&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">requestSorting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;sortButton&#x27;</span>).onclick = sorter.requestSorting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Good Example: sorter baked into ThisBinding of handler</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sorter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">sort</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">&#x27;sorting&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">requestSorting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;sortButton&#x27;</span>).onclick = sorter.requestSorting.bind(sorter);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h2><p><a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf\">ECMA 262 5th Edition (PDF)</a></p>\n<ul>\n<li>11.1.1 Definition of this</li>\n<li>10.4.3 Entering Function Code</li>\n<li>11.2.3 Function Calls</li>\n<li>13.2.1 [[Call]]</li>\n<li>10.2.1.1 Declarative Environment Record (ImplicitThisValue)</li>\n<li>13.2.2 [[Construct]]</li>\n<li>15.3.4.3 Function.prototype.apply</li>\n<li>15.3.4.4 Function.prototype.call</li>\n<li>15.3.4.5 Function.prototype.bind</li>\n<li>Annex C The Strict Mode of ECMAScript</li>\n</ul>"},{"layout":"post","title":"如何保证调用构造函数也会得到一个实例","date":"2011-03-10T05:36:00.000Z","status":"publish","_content":"\n题目比较绕，其实意思很简单，先不解释，给出如下两个场景：\n\n## 情景1\n\n在js中，面向对象编程方法越来越流行，构造函数作为基础概念，使用的频率较高。\n\n```js\nfunction spring(name){\n    this.name = name;\n}\nvar firstIns = new spring('shang chun');   //an instance of spring\n```\n\n众所周知，构造函数本身也是一个函数，这就意味着它可以被随意调用。随着岁月的积累或协作人员之间信息不对称，很有可能不慎如下调用了这个构造函数：\n\n```js\nvar secondeIns = spring('wang qiang');   // 'this' refer to window now\n```\n\n这样的代码并不会报错，但是却给全局对象`window`增加了`name`属性，这样的失误需要一种合适的方法避免。\n\n<!-- more -->\n\n## 情景2\n\n想想看，如果我们想要马上调用新生成的实例，是不是只能这样去写\n\n```js\n(new spring('shang chun')).hasOwnProperty('name');\n```\n\n有没有更好的方法呢？\n\n## 解决方案\n\n事情回到了起点，我们想要的实际上是一个只要调用就无论如何都返回一个实例的构造函数，不管用不用`new`操作符。最近在看YUI3的源码，发现他们给出一种很好的解决方案，示例：\n\n```js\nfunction spring(name) {\n    var _this = this;\n    var insanceOf = function(o, type){\n        return (o && o.hasOwnProperty && (o instanceof type));\n    };\n    if (!instanceOf(_this, spring)) {\n         _this = new spring(name);\n    } else {\n         _this.name = name;\n    }\n    return _this;\n}\n\nvar ins = new spring('shang chun');  // normal constructor\nins.name;  // outputs 'shang chun'\n\nspring('shang chun').name;  // outputs 'shang chun'\n```\n\n","source":"_posts/scope-safe-constructor.md","raw":"---\nlayout: post\ntitle: \"如何保证调用构造函数也会得到一个实例\"\ndate: 2011-03-10 13:36\nstatus: publish\ntags: [Instanceof, Scope-safe Constructor]\n---\n\n题目比较绕，其实意思很简单，先不解释，给出如下两个场景：\n\n## 情景1\n\n在js中，面向对象编程方法越来越流行，构造函数作为基础概念，使用的频率较高。\n\n```js\nfunction spring(name){\n    this.name = name;\n}\nvar firstIns = new spring('shang chun');   //an instance of spring\n```\n\n众所周知，构造函数本身也是一个函数，这就意味着它可以被随意调用。随着岁月的积累或协作人员之间信息不对称，很有可能不慎如下调用了这个构造函数：\n\n```js\nvar secondeIns = spring('wang qiang');   // 'this' refer to window now\n```\n\n这样的代码并不会报错，但是却给全局对象`window`增加了`name`属性，这样的失误需要一种合适的方法避免。\n\n<!-- more -->\n\n## 情景2\n\n想想看，如果我们想要马上调用新生成的实例，是不是只能这样去写\n\n```js\n(new spring('shang chun')).hasOwnProperty('name');\n```\n\n有没有更好的方法呢？\n\n## 解决方案\n\n事情回到了起点，我们想要的实际上是一个只要调用就无论如何都返回一个实例的构造函数，不管用不用`new`操作符。最近在看YUI3的源码，发现他们给出一种很好的解决方案，示例：\n\n```js\nfunction spring(name) {\n    var _this = this;\n    var insanceOf = function(o, type){\n        return (o && o.hasOwnProperty && (o instanceof type));\n    };\n    if (!instanceOf(_this, spring)) {\n         _this = new spring(name);\n    } else {\n         _this.name = name;\n    }\n    return _this;\n}\n\nvar ins = new spring('shang chun');  // normal constructor\nins.name;  // outputs 'shang chun'\n\nspring('shang chun').name;  // outputs 'shang chun'\n```\n\n","slug":"scope-safe-constructor","published":1,"updated":"2021-10-05T09:36:49.474Z","comments":1,"photos":[],"link":"","_id":"cl1klgupv001l8e857vjp6bv8","content":"<p>题目比较绕，其实意思很简单，先不解释，给出如下两个场景：</p>\n<h2 id=\"情景1\"><a href=\"#情景1\" class=\"headerlink\" title=\"情景1\"></a>情景1</h2><p>在js中，面向对象编程方法越来越流行，构造函数作为基础概念，使用的频率较高。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spring</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstIns = <span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>);   <span class=\"comment\">//an instance of spring</span></span><br></pre></td></tr></table></figure>\n\n<p>众所周知，构造函数本身也是一个函数，这就意味着它可以被随意调用。随着岁月的积累或协作人员之间信息不对称，很有可能不慎如下调用了这个构造函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> secondeIns = spring(<span class=\"string\">&#x27;wang qiang&#x27;</span>);   <span class=\"comment\">// &#x27;this&#x27; refer to window now</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的代码并不会报错，但是却给全局对象<code>window</code>增加了<code>name</code>属性，这样的失误需要一种合适的方法避免。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"情景2\"><a href=\"#情景2\" class=\"headerlink\" title=\"情景2\"></a>情景2</h2><p>想想看，如果我们想要马上调用新生成的实例，是不是只能这样去写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>)).hasOwnProperty(<span class=\"string\">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有没有更好的方法呢？</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>事情回到了起点，我们想要的实际上是一个只要调用就无论如何都返回一个实例的构造函数，不管用不用<code>new</code>操作符。最近在看YUI3的源码，发现他们给出一种很好的解决方案，示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spring</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> insanceOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, type</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (o &amp;&amp; o.hasOwnProperty &amp;&amp; (o <span class=\"keyword\">instanceof</span> type));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceOf(_this, spring)) &#123;</span><br><span class=\"line\">         _this = <span class=\"keyword\">new</span> spring(name);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         _this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ins = <span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>);  <span class=\"comment\">// normal constructor</span></span><br><span class=\"line\">ins.name;  <span class=\"comment\">// outputs &#x27;shang chun&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">spring(<span class=\"string\">&#x27;shang chun&#x27;</span>).name;  <span class=\"comment\">// outputs &#x27;shang chun&#x27;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>题目比较绕，其实意思很简单，先不解释，给出如下两个场景：</p>\n<h2 id=\"情景1\"><a href=\"#情景1\" class=\"headerlink\" title=\"情景1\"></a>情景1</h2><p>在js中，面向对象编程方法越来越流行，构造函数作为基础概念，使用的频率较高。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spring</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstIns = <span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>);   <span class=\"comment\">//an instance of spring</span></span><br></pre></td></tr></table></figure>\n\n<p>众所周知，构造函数本身也是一个函数，这就意味着它可以被随意调用。随着岁月的积累或协作人员之间信息不对称，很有可能不慎如下调用了这个构造函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> secondeIns = spring(<span class=\"string\">&#x27;wang qiang&#x27;</span>);   <span class=\"comment\">// &#x27;this&#x27; refer to window now</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的代码并不会报错，但是却给全局对象<code>window</code>增加了<code>name</code>属性，这样的失误需要一种合适的方法避免。</p>","more":"<h2 id=\"情景2\"><a href=\"#情景2\" class=\"headerlink\" title=\"情景2\"></a>情景2</h2><p>想想看，如果我们想要马上调用新生成的实例，是不是只能这样去写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>)).hasOwnProperty(<span class=\"string\">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有没有更好的方法呢？</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>事情回到了起点，我们想要的实际上是一个只要调用就无论如何都返回一个实例的构造函数，不管用不用<code>new</code>操作符。最近在看YUI3的源码，发现他们给出一种很好的解决方案，示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spring</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> insanceOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, type</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (o &amp;&amp; o.hasOwnProperty &amp;&amp; (o <span class=\"keyword\">instanceof</span> type));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instanceOf(_this, spring)) &#123;</span><br><span class=\"line\">         _this = <span class=\"keyword\">new</span> spring(name);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         _this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ins = <span class=\"keyword\">new</span> spring(<span class=\"string\">&#x27;shang chun&#x27;</span>);  <span class=\"comment\">// normal constructor</span></span><br><span class=\"line\">ins.name;  <span class=\"comment\">// outputs &#x27;shang chun&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">spring(<span class=\"string\">&#x27;shang chun&#x27;</span>).name;  <span class=\"comment\">// outputs &#x27;shang chun&#x27;</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"YUI onDOMReady滞后window.onload原因浅析","date":"2011-03-11T06:12:00.000Z","status":"publish","_content":"\n## 开篇\n\n我很好奇其他前端工程师在wp后台写新文章的时候是在用可视化还是html模式。反正我是一路打着标签过来的，呵呵。\n\n## 缘起\n\n一直以来，我都先验的认为dom ready事件肯定发生在load之前。但是，最近的一个ticket上线后发现一个很奇怪的现象：在IE下，有时会发生页面load时仍没有捕捉到dom ready的时间。通过多次观察，发现发生这种现象一般是较为简单的页面。\n\n## 分析\n\n首先，在反复检查代码后排除了自身bug的问题。然后，去找到YUI（我们团队主要以YUI2作为基础库，并准备近期升级到YUI3）的`onDOMReady`实现，希望通过分析源码找到问题的起源，将`onDOMReady`在不含frame的IE中分支拣出来，代码量并不多：\n\n<!-- more -->\n\n```js\n// Process onAvailable/onContentReady items when the\n// DOM is ready.\nYAHOO.util.Event.onDOMReady(\n    YAHOO.util.Event._tryPreloadAttach,\n    YAHOO.util.Event, true);\n\nvar n = document.createElement('p');\n\nEU._dri = setInterval(function() {\n    try {\n        // throws an error if doc is not ready\n        n.doScroll('left');\n        clearInterval(EU._dri);\n        EU._dri = null;\n        EU._ready();\n        n = null;\n    } catch (ex) {\n    }\n}, EU.POLL_INTERVAL);\n```\n\n实现的思路非常清晰：创建一个段落元素，然后轮询这个元素是否可以运行`doScroll`方法，在IE中，所有元素都有`doScroll`方法，而且如果文档没有完全解析完成的话，运行这个方法会报错。YUI正是运用了IE的这个特点来判定dom ready。而问题恰恰出在轮询而不是原生事件上，因为轮询有一个时间差（40毫秒），如果在下次嗅探之前文档加载完成，那么YUI所得到的dom ready时间就会滞后，进一步，如果页面并不包括很多图片等额外元素时，那么在下一次嗅探前dom ready且迅速触发load的话，就会出现YUI得到的dom ready时间比load时间更晚的怪象。\n\n## 修正\n\n了解清楚问题的真正原因，问题的解决办法也就非常容易想到。最简单的办法是在load触发后滞后一段时间再执行需要dom ready时间的方法。进一步，因为在Firefox、Chrome、Safari等现代浏览器可以直接利用DOMContentLoaded事件即时捕捉到dom ready的时间，没有必要滞后执行，所以可以做下相应的判断。这种细节的处理才能显示出对用户体验的追求和优秀前端的价值。\n","source":"_posts/yui-domready-after-load.md","raw":"---\nlayout: post\ntitle: \"YUI onDOMReady滞后window.onload原因浅析\"\ndate: 2011-03-11 14:12\nstatus: publish\ntags: [YUI2, domready, load]\n---\n\n## 开篇\n\n我很好奇其他前端工程师在wp后台写新文章的时候是在用可视化还是html模式。反正我是一路打着标签过来的，呵呵。\n\n## 缘起\n\n一直以来，我都先验的认为dom ready事件肯定发生在load之前。但是，最近的一个ticket上线后发现一个很奇怪的现象：在IE下，有时会发生页面load时仍没有捕捉到dom ready的时间。通过多次观察，发现发生这种现象一般是较为简单的页面。\n\n## 分析\n\n首先，在反复检查代码后排除了自身bug的问题。然后，去找到YUI（我们团队主要以YUI2作为基础库，并准备近期升级到YUI3）的`onDOMReady`实现，希望通过分析源码找到问题的起源，将`onDOMReady`在不含frame的IE中分支拣出来，代码量并不多：\n\n<!-- more -->\n\n```js\n// Process onAvailable/onContentReady items when the\n// DOM is ready.\nYAHOO.util.Event.onDOMReady(\n    YAHOO.util.Event._tryPreloadAttach,\n    YAHOO.util.Event, true);\n\nvar n = document.createElement('p');\n\nEU._dri = setInterval(function() {\n    try {\n        // throws an error if doc is not ready\n        n.doScroll('left');\n        clearInterval(EU._dri);\n        EU._dri = null;\n        EU._ready();\n        n = null;\n    } catch (ex) {\n    }\n}, EU.POLL_INTERVAL);\n```\n\n实现的思路非常清晰：创建一个段落元素，然后轮询这个元素是否可以运行`doScroll`方法，在IE中，所有元素都有`doScroll`方法，而且如果文档没有完全解析完成的话，运行这个方法会报错。YUI正是运用了IE的这个特点来判定dom ready。而问题恰恰出在轮询而不是原生事件上，因为轮询有一个时间差（40毫秒），如果在下次嗅探之前文档加载完成，那么YUI所得到的dom ready时间就会滞后，进一步，如果页面并不包括很多图片等额外元素时，那么在下一次嗅探前dom ready且迅速触发load的话，就会出现YUI得到的dom ready时间比load时间更晚的怪象。\n\n## 修正\n\n了解清楚问题的真正原因，问题的解决办法也就非常容易想到。最简单的办法是在load触发后滞后一段时间再执行需要dom ready时间的方法。进一步，因为在Firefox、Chrome、Safari等现代浏览器可以直接利用DOMContentLoaded事件即时捕捉到dom ready的时间，没有必要滞后执行，所以可以做下相应的判断。这种细节的处理才能显示出对用户体验的追求和优秀前端的价值。\n","slug":"yui-domready-after-load","published":1,"updated":"2021-10-04T12:57:16.038Z","comments":1,"photos":[],"link":"","_id":"cl1klgupw001n8e85elwqebpi","content":"<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p>我很好奇其他前端工程师在wp后台写新文章的时候是在用可视化还是html模式。反正我是一路打着标签过来的，呵呵。</p>\n<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>一直以来，我都先验的认为dom ready事件肯定发生在load之前。但是，最近的一个ticket上线后发现一个很奇怪的现象：在IE下，有时会发生页面load时仍没有捕捉到dom ready的时间。通过多次观察，发现发生这种现象一般是较为简单的页面。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>首先，在反复检查代码后排除了自身bug的问题。然后，去找到YUI（我们团队主要以YUI2作为基础库，并准备近期升级到YUI3）的<code>onDOMReady</code>实现，希望通过分析源码找到问题的起源，将<code>onDOMReady</code>在不含frame的IE中分支拣出来，代码量并不多：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Process onAvailable/onContentReady items when the</span></span><br><span class=\"line\"><span class=\"comment\">// DOM is ready.</span></span><br><span class=\"line\">YAHOO.util.Event.onDOMReady(</span><br><span class=\"line\">    YAHOO.util.Event._tryPreloadAttach,</span><br><span class=\"line\">    YAHOO.util.Event, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EU._dri = <span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// throws an error if doc is not ready</span></span><br><span class=\"line\">        n.doScroll(<span class=\"string\">&#x27;left&#x27;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearInterval</span>(EU._dri);</span><br><span class=\"line\">        EU._dri = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        EU._ready();</span><br><span class=\"line\">        n = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, EU.POLL_INTERVAL);</span><br></pre></td></tr></table></figure>\n\n<p>实现的思路非常清晰：创建一个段落元素，然后轮询这个元素是否可以运行<code>doScroll</code>方法，在IE中，所有元素都有<code>doScroll</code>方法，而且如果文档没有完全解析完成的话，运行这个方法会报错。YUI正是运用了IE的这个特点来判定dom ready。而问题恰恰出在轮询而不是原生事件上，因为轮询有一个时间差（40毫秒），如果在下次嗅探之前文档加载完成，那么YUI所得到的dom ready时间就会滞后，进一步，如果页面并不包括很多图片等额外元素时，那么在下一次嗅探前dom ready且迅速触发load的话，就会出现YUI得到的dom ready时间比load时间更晚的怪象。</p>\n<h2 id=\"修正\"><a href=\"#修正\" class=\"headerlink\" title=\"修正\"></a>修正</h2><p>了解清楚问题的真正原因，问题的解决办法也就非常容易想到。最简单的办法是在load触发后滞后一段时间再执行需要dom ready时间的方法。进一步，因为在Firefox、Chrome、Safari等现代浏览器可以直接利用DOMContentLoaded事件即时捕捉到dom ready的时间，没有必要滞后执行，所以可以做下相应的判断。这种细节的处理才能显示出对用户体验的追求和优秀前端的价值。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p>我很好奇其他前端工程师在wp后台写新文章的时候是在用可视化还是html模式。反正我是一路打着标签过来的，呵呵。</p>\n<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>一直以来，我都先验的认为dom ready事件肯定发生在load之前。但是，最近的一个ticket上线后发现一个很奇怪的现象：在IE下，有时会发生页面load时仍没有捕捉到dom ready的时间。通过多次观察，发现发生这种现象一般是较为简单的页面。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>首先，在反复检查代码后排除了自身bug的问题。然后，去找到YUI（我们团队主要以YUI2作为基础库，并准备近期升级到YUI3）的<code>onDOMReady</code>实现，希望通过分析源码找到问题的起源，将<code>onDOMReady</code>在不含frame的IE中分支拣出来，代码量并不多：</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Process onAvailable/onContentReady items when the</span></span><br><span class=\"line\"><span class=\"comment\">// DOM is ready.</span></span><br><span class=\"line\">YAHOO.util.Event.onDOMReady(</span><br><span class=\"line\">    YAHOO.util.Event._tryPreloadAttach,</span><br><span class=\"line\">    YAHOO.util.Event, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EU._dri = <span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// throws an error if doc is not ready</span></span><br><span class=\"line\">        n.doScroll(<span class=\"string\">&#x27;left&#x27;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearInterval</span>(EU._dri);</span><br><span class=\"line\">        EU._dri = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        EU._ready();</span><br><span class=\"line\">        n = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, EU.POLL_INTERVAL);</span><br></pre></td></tr></table></figure>\n\n<p>实现的思路非常清晰：创建一个段落元素，然后轮询这个元素是否可以运行<code>doScroll</code>方法，在IE中，所有元素都有<code>doScroll</code>方法，而且如果文档没有完全解析完成的话，运行这个方法会报错。YUI正是运用了IE的这个特点来判定dom ready。而问题恰恰出在轮询而不是原生事件上，因为轮询有一个时间差（40毫秒），如果在下次嗅探之前文档加载完成，那么YUI所得到的dom ready时间就会滞后，进一步，如果页面并不包括很多图片等额外元素时，那么在下一次嗅探前dom ready且迅速触发load的话，就会出现YUI得到的dom ready时间比load时间更晚的怪象。</p>\n<h2 id=\"修正\"><a href=\"#修正\" class=\"headerlink\" title=\"修正\"></a>修正</h2><p>了解清楚问题的真正原因，问题的解决办法也就非常容易想到。最简单的办法是在load触发后滞后一段时间再执行需要dom ready时间的方法。进一步，因为在Firefox、Chrome、Safari等现代浏览器可以直接利用DOMContentLoaded事件即时捕捉到dom ready的时间，没有必要滞后执行，所以可以做下相应的判断。这种细节的处理才能显示出对用户体验的追求和优秀前端的价值。</p>"},{"layout":"post","title":"浅析YUI3","date":"2011-05-21T13:16:00.000Z","status":"publish","_content":"\n最近因为忙于YUI2到YUI3的迁移，没时间更新博客。现在闲暇一些，觉得似乎写一点自己对于YUI3的理解再合适不过。\n\n主要内容有以下几点：\n\n1. 全局命名空间\n2. 改变一切的模块\n3. Combo\n4. 链式调用\n5. 更广泛的自定义事件\n6. 一些问题\n\n## 全局命名空间\nYUI3为了保持向前兼容，采用了新的全局命名空间`YUI`。新的命名空间与YUI2的全局命名空间`YAHOO`最大的不同就是：`YUI`是一个构造函数，而且是一个[无论如何也返回一个实例的构造函数](http://shangchun.net/scope-safe-contructor.html)。\n\n## 改变一切的模块\n\nYUI2时代，一般都是将某方面的全部方法写在统一的命名空间下，例如DOM相关的方法均在`YAHOO.util.Dom`，在需要使用这些方法时我们直接调用即可。YUI2真正体现了**基础方法库**\\(function library\\)这样一种定位。\n\n<!-- more -->\n\nYUI3最大的变化和进步在于，它采用了革新性的底层组织方式，其核心就是模块\\(module\\)。在YUI3中，每个方法不再属于某个文件、某个命名空间，而是属于某个模块。每个模块代表一个独立的功能，例如`DOM`、`Event`等。下面是一个简单的例子：\n\n```js\nYUI.add('new-module', function (Y) {\n    Y.sayHelloWorld = function (id) {\n        var el = Y.DOM.byId(id);\n        Y.DOM.set(el, 'innerHTML', 'Hello, world!');\n    };\n}, '1.0.0', { requires: ['dom'] });\n```\n\n通过调用`YUI`构造器本身的`add`静态方法，我们声明了一个新的模块，模块的名称为new-module，模块为`YUI`的实例`Y`挂载了`sayHelloWorld`方法，因为这个方法使用了dom模块的方法`byId`，所以要在`add`的第四个参数中标明new-module模块依赖于dom模块。\n\n添加模块的目的是为了使用它，下面给出调用new-module的示例：\n\n```js\n// html\n<div id=\"entry\"></div>\n\n// js\nYUI().use('new-module', function(Y) {\n    Y.sayHelloWorld('entry');   // <div id=\"entry\">Hello, world!</div>\n});\n```\n\n通过调用YUI实例的`use`方法，在列出模块名称之后，我们可以随意使用它们挂载的方法。需要提醒的是，YUI的[loader](http://developer.yahoo.com/yui/3/yui/#loader)会发现new-module模块依赖于dom模块，然后它去check当前页面是否已经有dom模块，没有的话则动态加载。\n\n总结一下，发现模块为我们带来了这些好处：\n\n- **遗弃domready**：在YUI2中，页面通常要在domready之后调用js方法。在YUI3中可以省掉这一步了，因为只有在所有需要的模块都加载完毕后才会调用js方法，而我们通常都是在&lt;body&gt;最后面引入js，此时dom基本已经就绪。当然，YUI3仍然提供domready事件监听方法。\n- **沙箱**(Sandbox)：在使用模块时，我们只能调用这些模块以及它们依赖的所有模块给YUI实例挂载的方法。这种机制可以限定你的代码在一定范围内执行，而不是肆意妄为。\n- **自动加载**：我们不必再手动添加&lt;script&gt;标签引入js，更不必为js文件间的顺序依赖问题揪心，YUI的loader会为你摆平，而它的依据正是各个模块中的`requires`参数。\n- **开发框架**(Framework)：基于这种方法的声明/调用机制，YUI3更像一个js开发框架而不仅仅是一个方法库。我们可以将自己需要的功能作为一个个模块，可以细分为全局通用模块、分站通用模块、分站应用模块等层级。YUI3为此提供了非常简便的接口。\n\n我觉得用这样一句话形容模块对于YUI的意义最好不过：“[Inception](http://movie.douban.com/subject/3541415/)”中Cobb所说的“a very simple idea that changed everything”。\n\n至于模块如何设计、如何分级，将是一个非常有挑战的问题。我准备在适当的时间做下经验总结，现在暂不展开讲。\n\n## Combo\n在YUI3框架中，每个模块都对应一个独立的js文件\\(也有所有子模块组成一个模块的特殊情况，在此不细较\\)，日常开发中，往往需要动态加载大量的模块，造成http请求数较YUI2时代翻几番。众所周知的是，在YUI团队的[Best Practices for Speeding Up Your Web Site](http://developer.yahoo.com/performance/rules.html)一文中提到的第一条准则就是降低http请求数。如果模块化带来的更小粒度更大规模的js文件使得页面加载速度更慢，那么它所有的优势将不再具有吸引力。好消息是，YUI团队很好的解决了这一问题，他们引入了combo的思想，即使用服务器端技术，收到包含多个js文件请求的url之后，合并这些文件为一个大文件返回。\n\n关于Combo的具体文章，可以参考[在服务端合并和压缩JavaScript和CSS文件](http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server)。\n\n## 链式调用\n\njQuery因为方便的链式调用而风靡全球，其write less do more的核心理念也随之深入人心。欣喜的是，YUI团队汲取了这一优点，在YUI3中引入了新的[Node/NodeList](http://developer.yahoo.com/yui/3/node)对象，并取代DOM成为YUI3 Core。这一变化无疑将增加YUI3代码的书写效率，成为有一个显著的加分点。\n\n## 更广泛的自定义事件\n\nYUI3提供了简约而强大的custom event：更加dom-like的调用方法，可以冒泡，可以经历各个事件阶段，可以定义默认动作，可以设定传播范围是模块内部还是模块之间等等。目前对于这部分仍然不甚熟悉，有兴趣的朋友可以参考Luke Smith做的这个[讲座](http://developer.yahoo.com/yui/theater/video.php?v=smith-yuiconf2009-events)。\n\n## 一些问题\n\nYUI3并不完美，目前为止仍然存在一些问题，列举如下：\n\n- 文档仍然不够详尽，很多时候只能去查源代码。例如YUI2中`getRegion`方法在YUI3中的对应方法为`node.get('region')`。\n- Node实例只能通过`get`方法取id，value等自身属性，可以参考jQuery采用更简洁的api，例如`val()`, `height()`, `text()`等。\n- 得到一个定制的YUI实例时，需要将自己开发的模块的`path`、`requires`信息作为参数传进去，而在声明自定义模块时仍需要设定`requires`，这种冗余设计是可以做优化的。\n- 使用Node操作Form时非常繁琐。例如要获取一个text表单项只能使用`ndForm.one('input[name=\"xxx\"]')`，而不能`ndForm.get('xxx')`。\n- 在存在name=\"id\"项的表单中，存在因`Y.Selector.test`失效而产生的各种问题。例如`Y.one('#input-id').ancestor('form')`取不到等等。\n- 没有公开的Form的`serialize`方法。\n</ul>\n\nok，这就是我对YUI3的一些浅薄见解。欢迎讨论和指正。随着经验的不断积累，后续会奉上更深入的一些分析。\n","source":"_posts/yui3-intro.md","raw":"---\nlayout: post\ntitle: \"浅析YUI3\"\ndate: 2011-05-21 21:16\nstatus: publish\ntags: [YUI]\n---\n\n最近因为忙于YUI2到YUI3的迁移，没时间更新博客。现在闲暇一些，觉得似乎写一点自己对于YUI3的理解再合适不过。\n\n主要内容有以下几点：\n\n1. 全局命名空间\n2. 改变一切的模块\n3. Combo\n4. 链式调用\n5. 更广泛的自定义事件\n6. 一些问题\n\n## 全局命名空间\nYUI3为了保持向前兼容，采用了新的全局命名空间`YUI`。新的命名空间与YUI2的全局命名空间`YAHOO`最大的不同就是：`YUI`是一个构造函数，而且是一个[无论如何也返回一个实例的构造函数](http://shangchun.net/scope-safe-contructor.html)。\n\n## 改变一切的模块\n\nYUI2时代，一般都是将某方面的全部方法写在统一的命名空间下，例如DOM相关的方法均在`YAHOO.util.Dom`，在需要使用这些方法时我们直接调用即可。YUI2真正体现了**基础方法库**\\(function library\\)这样一种定位。\n\n<!-- more -->\n\nYUI3最大的变化和进步在于，它采用了革新性的底层组织方式，其核心就是模块\\(module\\)。在YUI3中，每个方法不再属于某个文件、某个命名空间，而是属于某个模块。每个模块代表一个独立的功能，例如`DOM`、`Event`等。下面是一个简单的例子：\n\n```js\nYUI.add('new-module', function (Y) {\n    Y.sayHelloWorld = function (id) {\n        var el = Y.DOM.byId(id);\n        Y.DOM.set(el, 'innerHTML', 'Hello, world!');\n    };\n}, '1.0.0', { requires: ['dom'] });\n```\n\n通过调用`YUI`构造器本身的`add`静态方法，我们声明了一个新的模块，模块的名称为new-module，模块为`YUI`的实例`Y`挂载了`sayHelloWorld`方法，因为这个方法使用了dom模块的方法`byId`，所以要在`add`的第四个参数中标明new-module模块依赖于dom模块。\n\n添加模块的目的是为了使用它，下面给出调用new-module的示例：\n\n```js\n// html\n<div id=\"entry\"></div>\n\n// js\nYUI().use('new-module', function(Y) {\n    Y.sayHelloWorld('entry');   // <div id=\"entry\">Hello, world!</div>\n});\n```\n\n通过调用YUI实例的`use`方法，在列出模块名称之后，我们可以随意使用它们挂载的方法。需要提醒的是，YUI的[loader](http://developer.yahoo.com/yui/3/yui/#loader)会发现new-module模块依赖于dom模块，然后它去check当前页面是否已经有dom模块，没有的话则动态加载。\n\n总结一下，发现模块为我们带来了这些好处：\n\n- **遗弃domready**：在YUI2中，页面通常要在domready之后调用js方法。在YUI3中可以省掉这一步了，因为只有在所有需要的模块都加载完毕后才会调用js方法，而我们通常都是在&lt;body&gt;最后面引入js，此时dom基本已经就绪。当然，YUI3仍然提供domready事件监听方法。\n- **沙箱**(Sandbox)：在使用模块时，我们只能调用这些模块以及它们依赖的所有模块给YUI实例挂载的方法。这种机制可以限定你的代码在一定范围内执行，而不是肆意妄为。\n- **自动加载**：我们不必再手动添加&lt;script&gt;标签引入js，更不必为js文件间的顺序依赖问题揪心，YUI的loader会为你摆平，而它的依据正是各个模块中的`requires`参数。\n- **开发框架**(Framework)：基于这种方法的声明/调用机制，YUI3更像一个js开发框架而不仅仅是一个方法库。我们可以将自己需要的功能作为一个个模块，可以细分为全局通用模块、分站通用模块、分站应用模块等层级。YUI3为此提供了非常简便的接口。\n\n我觉得用这样一句话形容模块对于YUI的意义最好不过：“[Inception](http://movie.douban.com/subject/3541415/)”中Cobb所说的“a very simple idea that changed everything”。\n\n至于模块如何设计、如何分级，将是一个非常有挑战的问题。我准备在适当的时间做下经验总结，现在暂不展开讲。\n\n## Combo\n在YUI3框架中，每个模块都对应一个独立的js文件\\(也有所有子模块组成一个模块的特殊情况，在此不细较\\)，日常开发中，往往需要动态加载大量的模块，造成http请求数较YUI2时代翻几番。众所周知的是，在YUI团队的[Best Practices for Speeding Up Your Web Site](http://developer.yahoo.com/performance/rules.html)一文中提到的第一条准则就是降低http请求数。如果模块化带来的更小粒度更大规模的js文件使得页面加载速度更慢，那么它所有的优势将不再具有吸引力。好消息是，YUI团队很好的解决了这一问题，他们引入了combo的思想，即使用服务器端技术，收到包含多个js文件请求的url之后，合并这些文件为一个大文件返回。\n\n关于Combo的具体文章，可以参考[在服务端合并和压缩JavaScript和CSS文件](http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server)。\n\n## 链式调用\n\njQuery因为方便的链式调用而风靡全球，其write less do more的核心理念也随之深入人心。欣喜的是，YUI团队汲取了这一优点，在YUI3中引入了新的[Node/NodeList](http://developer.yahoo.com/yui/3/node)对象，并取代DOM成为YUI3 Core。这一变化无疑将增加YUI3代码的书写效率，成为有一个显著的加分点。\n\n## 更广泛的自定义事件\n\nYUI3提供了简约而强大的custom event：更加dom-like的调用方法，可以冒泡，可以经历各个事件阶段，可以定义默认动作，可以设定传播范围是模块内部还是模块之间等等。目前对于这部分仍然不甚熟悉，有兴趣的朋友可以参考Luke Smith做的这个[讲座](http://developer.yahoo.com/yui/theater/video.php?v=smith-yuiconf2009-events)。\n\n## 一些问题\n\nYUI3并不完美，目前为止仍然存在一些问题，列举如下：\n\n- 文档仍然不够详尽，很多时候只能去查源代码。例如YUI2中`getRegion`方法在YUI3中的对应方法为`node.get('region')`。\n- Node实例只能通过`get`方法取id，value等自身属性，可以参考jQuery采用更简洁的api，例如`val()`, `height()`, `text()`等。\n- 得到一个定制的YUI实例时，需要将自己开发的模块的`path`、`requires`信息作为参数传进去，而在声明自定义模块时仍需要设定`requires`，这种冗余设计是可以做优化的。\n- 使用Node操作Form时非常繁琐。例如要获取一个text表单项只能使用`ndForm.one('input[name=\"xxx\"]')`，而不能`ndForm.get('xxx')`。\n- 在存在name=\"id\"项的表单中，存在因`Y.Selector.test`失效而产生的各种问题。例如`Y.one('#input-id').ancestor('form')`取不到等等。\n- 没有公开的Form的`serialize`方法。\n</ul>\n\nok，这就是我对YUI3的一些浅薄见解。欢迎讨论和指正。随着经验的不断积累，后续会奉上更深入的一些分析。\n","slug":"yui3-intro","published":1,"updated":"2021-10-04T12:57:16.046Z","comments":1,"photos":[],"link":"","_id":"cl1klgupw001q8e850gz4dlzg","content":"<p>最近因为忙于YUI2到YUI3的迁移，没时间更新博客。现在闲暇一些，觉得似乎写一点自己对于YUI3的理解再合适不过。</p>\n<p>主要内容有以下几点：</p>\n<ol>\n<li>全局命名空间</li>\n<li>改变一切的模块</li>\n<li>Combo</li>\n<li>链式调用</li>\n<li>更广泛的自定义事件</li>\n<li>一些问题</li>\n</ol>\n<h2 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h2><p>YUI3为了保持向前兼容，采用了新的全局命名空间<code>YUI</code>。新的命名空间与YUI2的全局命名空间<code>YAHOO</code>最大的不同就是：<code>YUI</code>是一个构造函数，而且是一个<a href=\"http://shangchun.net/scope-safe-contructor.html\">无论如何也返回一个实例的构造函数</a>。</p>\n<h2 id=\"改变一切的模块\"><a href=\"#改变一切的模块\" class=\"headerlink\" title=\"改变一切的模块\"></a>改变一切的模块</h2><p>YUI2时代，一般都是将某方面的全部方法写在统一的命名空间下，例如DOM相关的方法均在<code>YAHOO.util.Dom</code>，在需要使用这些方法时我们直接调用即可。YUI2真正体现了<strong>基础方法库</strong>(function library)这样一种定位。</p>\n<span id=\"more\"></span>\n\n<p>YUI3最大的变化和进步在于，它采用了革新性的底层组织方式，其核心就是模块(module)。在YUI3中，每个方法不再属于某个文件、某个命名空间，而是属于某个模块。每个模块代表一个独立的功能，例如<code>DOM</code>、<code>Event</code>等。下面是一个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YUI.add(<span class=\"string\">&#x27;new-module&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.sayHelloWorld = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> el = Y.DOM.byId(id);</span><br><span class=\"line\">        Y.DOM.set(el, <span class=\"string\">&#x27;innerHTML&#x27;</span>, <span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;1.0.0&#x27;</span>, &#123; <span class=\"attr\">requires</span>: [<span class=\"string\">&#x27;dom&#x27;</span>] &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过调用<code>YUI</code>构造器本身的<code>add</code>静态方法，我们声明了一个新的模块，模块的名称为new-module，模块为<code>YUI</code>的实例<code>Y</code>挂载了<code>sayHelloWorld</code>方法，因为这个方法使用了dom模块的方法<code>byId</code>，所以要在<code>add</code>的第四个参数中标明new-module模块依赖于dom模块。</p>\n<p>添加模块的目的是为了使用它，下面给出调用new-module的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">&quot;entry&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;new-module&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.sayHelloWorld(<span class=\"string\">&#x27;entry&#x27;</span>);   <span class=\"comment\">// &lt;div id=&quot;entry&quot;&gt;Hello, world!&lt;/div&gt;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过调用YUI实例的<code>use</code>方法，在列出模块名称之后，我们可以随意使用它们挂载的方法。需要提醒的是，YUI的<a href=\"http://developer.yahoo.com/yui/3/yui/#loader\">loader</a>会发现new-module模块依赖于dom模块，然后它去check当前页面是否已经有dom模块，没有的话则动态加载。</p>\n<p>总结一下，发现模块为我们带来了这些好处：</p>\n<ul>\n<li><strong>遗弃domready</strong>：在YUI2中，页面通常要在domready之后调用js方法。在YUI3中可以省掉这一步了，因为只有在所有需要的模块都加载完毕后才会调用js方法，而我们通常都是在&lt;body&gt;最后面引入js，此时dom基本已经就绪。当然，YUI3仍然提供domready事件监听方法。</li>\n<li><strong>沙箱</strong>(Sandbox)：在使用模块时，我们只能调用这些模块以及它们依赖的所有模块给YUI实例挂载的方法。这种机制可以限定你的代码在一定范围内执行，而不是肆意妄为。</li>\n<li><strong>自动加载</strong>：我们不必再手动添加&lt;script&gt;标签引入js，更不必为js文件间的顺序依赖问题揪心，YUI的loader会为你摆平，而它的依据正是各个模块中的<code>requires</code>参数。</li>\n<li><strong>开发框架</strong>(Framework)：基于这种方法的声明/调用机制，YUI3更像一个js开发框架而不仅仅是一个方法库。我们可以将自己需要的功能作为一个个模块，可以细分为全局通用模块、分站通用模块、分站应用模块等层级。YUI3为此提供了非常简便的接口。</li>\n</ul>\n<p>我觉得用这样一句话形容模块对于YUI的意义最好不过：“<a href=\"http://movie.douban.com/subject/3541415/\">Inception</a>”中Cobb所说的“a very simple idea that changed everything”。</p>\n<p>至于模块如何设计、如何分级，将是一个非常有挑战的问题。我准备在适当的时间做下经验总结，现在暂不展开讲。</p>\n<h2 id=\"Combo\"><a href=\"#Combo\" class=\"headerlink\" title=\"Combo\"></a>Combo</h2><p>在YUI3框架中，每个模块都对应一个独立的js文件(也有所有子模块组成一个模块的特殊情况，在此不细较)，日常开发中，往往需要动态加载大量的模块，造成http请求数较YUI2时代翻几番。众所周知的是，在YUI团队的<a href=\"http://developer.yahoo.com/performance/rules.html\">Best Practices for Speeding Up Your Web Site</a>一文中提到的第一条准则就是降低http请求数。如果模块化带来的更小粒度更大规模的js文件使得页面加载速度更慢，那么它所有的优势将不再具有吸引力。好消息是，YUI团队很好的解决了这一问题，他们引入了combo的思想，即使用服务器端技术，收到包含多个js文件请求的url之后，合并这些文件为一个大文件返回。</p>\n<p>关于Combo的具体文章，可以参考<a href=\"http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server\">在服务端合并和压缩JavaScript和CSS文件</a>。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>jQuery因为方便的链式调用而风靡全球，其write less do more的核心理念也随之深入人心。欣喜的是，YUI团队汲取了这一优点，在YUI3中引入了新的<a href=\"http://developer.yahoo.com/yui/3/node\">Node/NodeList</a>对象，并取代DOM成为YUI3 Core。这一变化无疑将增加YUI3代码的书写效率，成为有一个显著的加分点。</p>\n<h2 id=\"更广泛的自定义事件\"><a href=\"#更广泛的自定义事件\" class=\"headerlink\" title=\"更广泛的自定义事件\"></a>更广泛的自定义事件</h2><p>YUI3提供了简约而强大的custom event：更加dom-like的调用方法，可以冒泡，可以经历各个事件阶段，可以定义默认动作，可以设定传播范围是模块内部还是模块之间等等。目前对于这部分仍然不甚熟悉，有兴趣的朋友可以参考Luke Smith做的这个<a href=\"http://developer.yahoo.com/yui/theater/video.php?v=smith-yuiconf2009-events\">讲座</a>。</p>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><p>YUI3并不完美，目前为止仍然存在一些问题，列举如下：</p>\n<ul>\n<li>文档仍然不够详尽，很多时候只能去查源代码。例如YUI2中<code>getRegion</code>方法在YUI3中的对应方法为<code>node.get(&#39;region&#39;)</code>。</li>\n<li>Node实例只能通过<code>get</code>方法取id，value等自身属性，可以参考jQuery采用更简洁的api，例如<code>val()</code>, <code>height()</code>, <code>text()</code>等。</li>\n<li>得到一个定制的YUI实例时，需要将自己开发的模块的<code>path</code>、<code>requires</code>信息作为参数传进去，而在声明自定义模块时仍需要设定<code>requires</code>，这种冗余设计是可以做优化的。</li>\n<li>使用Node操作Form时非常繁琐。例如要获取一个text表单项只能使用<code>ndForm.one(&#39;input[name=&quot;xxx&quot;]&#39;)</code>，而不能<code>ndForm.get(&#39;xxx&#39;)</code>。</li>\n<li>在存在name=”id”项的表单中，存在因<code>Y.Selector.test</code>失效而产生的各种问题。例如<code>Y.one(&#39;#input-id&#39;).ancestor(&#39;form&#39;)</code>取不到等等。</li>\n<li>没有公开的Form的<code>serialize</code>方法。</ul></li>\n</ul>\n<p>ok，这就是我对YUI3的一些浅薄见解。欢迎讨论和指正。随着经验的不断积累，后续会奉上更深入的一些分析。</p>\n","site":{"data":{}},"excerpt":"<p>最近因为忙于YUI2到YUI3的迁移，没时间更新博客。现在闲暇一些，觉得似乎写一点自己对于YUI3的理解再合适不过。</p>\n<p>主要内容有以下几点：</p>\n<ol>\n<li>全局命名空间</li>\n<li>改变一切的模块</li>\n<li>Combo</li>\n<li>链式调用</li>\n<li>更广泛的自定义事件</li>\n<li>一些问题</li>\n</ol>\n<h2 id=\"全局命名空间\"><a href=\"#全局命名空间\" class=\"headerlink\" title=\"全局命名空间\"></a>全局命名空间</h2><p>YUI3为了保持向前兼容，采用了新的全局命名空间<code>YUI</code>。新的命名空间与YUI2的全局命名空间<code>YAHOO</code>最大的不同就是：<code>YUI</code>是一个构造函数，而且是一个<a href=\"http://shangchun.net/scope-safe-contructor.html\">无论如何也返回一个实例的构造函数</a>。</p>\n<h2 id=\"改变一切的模块\"><a href=\"#改变一切的模块\" class=\"headerlink\" title=\"改变一切的模块\"></a>改变一切的模块</h2><p>YUI2时代，一般都是将某方面的全部方法写在统一的命名空间下，例如DOM相关的方法均在<code>YAHOO.util.Dom</code>，在需要使用这些方法时我们直接调用即可。YUI2真正体现了<strong>基础方法库</strong>(function library)这样一种定位。</p>","more":"<p>YUI3最大的变化和进步在于，它采用了革新性的底层组织方式，其核心就是模块(module)。在YUI3中，每个方法不再属于某个文件、某个命名空间，而是属于某个模块。每个模块代表一个独立的功能，例如<code>DOM</code>、<code>Event</code>等。下面是一个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YUI.add(<span class=\"string\">&#x27;new-module&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.sayHelloWorld = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> el = Y.DOM.byId(id);</span><br><span class=\"line\">        Y.DOM.set(el, <span class=\"string\">&#x27;innerHTML&#x27;</span>, <span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;1.0.0&#x27;</span>, &#123; <span class=\"attr\">requires</span>: [<span class=\"string\">&#x27;dom&#x27;</span>] &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过调用<code>YUI</code>构造器本身的<code>add</code>静态方法，我们声明了一个新的模块，模块的名称为new-module，模块为<code>YUI</code>的实例<code>Y</code>挂载了<code>sayHelloWorld</code>方法，因为这个方法使用了dom模块的方法<code>byId</code>，所以要在<code>add</code>的第四个参数中标明new-module模块依赖于dom模块。</p>\n<p>添加模块的目的是为了使用它，下面给出调用new-module的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">&quot;entry&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;new-module&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">    Y.sayHelloWorld(<span class=\"string\">&#x27;entry&#x27;</span>);   <span class=\"comment\">// &lt;div id=&quot;entry&quot;&gt;Hello, world!&lt;/div&gt;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过调用YUI实例的<code>use</code>方法，在列出模块名称之后，我们可以随意使用它们挂载的方法。需要提醒的是，YUI的<a href=\"http://developer.yahoo.com/yui/3/yui/#loader\">loader</a>会发现new-module模块依赖于dom模块，然后它去check当前页面是否已经有dom模块，没有的话则动态加载。</p>\n<p>总结一下，发现模块为我们带来了这些好处：</p>\n<ul>\n<li><strong>遗弃domready</strong>：在YUI2中，页面通常要在domready之后调用js方法。在YUI3中可以省掉这一步了，因为只有在所有需要的模块都加载完毕后才会调用js方法，而我们通常都是在&lt;body&gt;最后面引入js，此时dom基本已经就绪。当然，YUI3仍然提供domready事件监听方法。</li>\n<li><strong>沙箱</strong>(Sandbox)：在使用模块时，我们只能调用这些模块以及它们依赖的所有模块给YUI实例挂载的方法。这种机制可以限定你的代码在一定范围内执行，而不是肆意妄为。</li>\n<li><strong>自动加载</strong>：我们不必再手动添加&lt;script&gt;标签引入js，更不必为js文件间的顺序依赖问题揪心，YUI的loader会为你摆平，而它的依据正是各个模块中的<code>requires</code>参数。</li>\n<li><strong>开发框架</strong>(Framework)：基于这种方法的声明/调用机制，YUI3更像一个js开发框架而不仅仅是一个方法库。我们可以将自己需要的功能作为一个个模块，可以细分为全局通用模块、分站通用模块、分站应用模块等层级。YUI3为此提供了非常简便的接口。</li>\n</ul>\n<p>我觉得用这样一句话形容模块对于YUI的意义最好不过：“<a href=\"http://movie.douban.com/subject/3541415/\">Inception</a>”中Cobb所说的“a very simple idea that changed everything”。</p>\n<p>至于模块如何设计、如何分级，将是一个非常有挑战的问题。我准备在适当的时间做下经验总结，现在暂不展开讲。</p>\n<h2 id=\"Combo\"><a href=\"#Combo\" class=\"headerlink\" title=\"Combo\"></a>Combo</h2><p>在YUI3框架中，每个模块都对应一个独立的js文件(也有所有子模块组成一个模块的特殊情况，在此不细较)，日常开发中，往往需要动态加载大量的模块，造成http请求数较YUI2时代翻几番。众所周知的是，在YUI团队的<a href=\"http://developer.yahoo.com/performance/rules.html\">Best Practices for Speeding Up Your Web Site</a>一文中提到的第一条准则就是降低http请求数。如果模块化带来的更小粒度更大规模的js文件使得页面加载速度更慢，那么它所有的优势将不再具有吸引力。好消息是，YUI团队很好的解决了这一问题，他们引入了combo的思想，即使用服务器端技术，收到包含多个js文件请求的url之后，合并这些文件为一个大文件返回。</p>\n<p>关于Combo的具体文章，可以参考<a href=\"http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server\">在服务端合并和压缩JavaScript和CSS文件</a>。</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>jQuery因为方便的链式调用而风靡全球，其write less do more的核心理念也随之深入人心。欣喜的是，YUI团队汲取了这一优点，在YUI3中引入了新的<a href=\"http://developer.yahoo.com/yui/3/node\">Node/NodeList</a>对象，并取代DOM成为YUI3 Core。这一变化无疑将增加YUI3代码的书写效率，成为有一个显著的加分点。</p>\n<h2 id=\"更广泛的自定义事件\"><a href=\"#更广泛的自定义事件\" class=\"headerlink\" title=\"更广泛的自定义事件\"></a>更广泛的自定义事件</h2><p>YUI3提供了简约而强大的custom event：更加dom-like的调用方法，可以冒泡，可以经历各个事件阶段，可以定义默认动作，可以设定传播范围是模块内部还是模块之间等等。目前对于这部分仍然不甚熟悉，有兴趣的朋友可以参考Luke Smith做的这个<a href=\"http://developer.yahoo.com/yui/theater/video.php?v=smith-yuiconf2009-events\">讲座</a>。</p>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><p>YUI3并不完美，目前为止仍然存在一些问题，列举如下：</p>\n<ul>\n<li>文档仍然不够详尽，很多时候只能去查源代码。例如YUI2中<code>getRegion</code>方法在YUI3中的对应方法为<code>node.get(&#39;region&#39;)</code>。</li>\n<li>Node实例只能通过<code>get</code>方法取id，value等自身属性，可以参考jQuery采用更简洁的api，例如<code>val()</code>, <code>height()</code>, <code>text()</code>等。</li>\n<li>得到一个定制的YUI实例时，需要将自己开发的模块的<code>path</code>、<code>requires</code>信息作为参数传进去，而在声明自定义模块时仍需要设定<code>requires</code>，这种冗余设计是可以做优化的。</li>\n<li>使用Node操作Form时非常繁琐。例如要获取一个text表单项只能使用<code>ndForm.one(&#39;input[name=&quot;xxx&quot;]&#39;)</code>，而不能<code>ndForm.get(&#39;xxx&#39;)</code>。</li>\n<li>在存在name=”id”项的表单中，存在因<code>Y.Selector.test</code>失效而产生的各种问题。例如<code>Y.one(&#39;#input-id&#39;).ancestor(&#39;form&#39;)</code>取不到等等。</li>\n<li>没有公开的Form的<code>serialize</code>方法。</ul></li>\n</ul>\n<p>ok，这就是我对YUI3的一些浅薄见解。欢迎讨论和指正。随着经验的不断积累，后续会奉上更深入的一些分析。</p>"},{"layout":"post","title":"YUI经验谈-自定义事件默认行为","date":"2014-02-14T02:00:00.000Z","comments":1,"status":"publish","_content":"\n纵观主流JS库和框架，YUI在自定义事件方面做的尤为出色。如果需要挑出一个代表性的feature，那么非**事件默认行为**莫属。\n\n## 是什么\n\nYUI自定义事件在总体上模仿了DOM事件的设计思想。DOM中的一些事件是有默认行为的，详细见[DOM3 Event - Default actions and cancelable events](https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel)一节。简单来说，所谓默认行为，是指该事件在通常情况下所表现出来的动作，例如：\n\n- 一个链接节点的`click`事件，默认行为是转向该链接href属性对应的地址\n- 表单的submit事件，默认行为是将表单包含的数据提交给表单的action\n\n说通常情况下，是因为有时开发者会在事件的回调函数中调用\n\n```\ne.preventDefault();\n```\n\n来阻止默认行为的发生。\n\n<!-- more -->\n\n<center><img alt=\"Event Default Action\" src=\"/images/event-default-action.png\" /></center>\n\nYUI自定义事件遵循了同样的思路，甚至API也和DOM完全一致。\n\n## 有啥用\n\n事件默认行为，本质上，是一种**管理事件和行为的对应关系**的机制。这种机制既不像回调那样死板，也不像消息那样开放。通过将通用处理逻辑作为事件默认行为，满足常见需求的同时，为定制化需求提供了一定开放性，整体上更加灵活。\n\n在DOM事件中，和默认行为相关的场景并不少见：\n\n- 监听到链接的`click`事件时，在链接地址中加入追踪参数，利用默认行为跳转到新地址\n- 阻止表单`submit`事件默认行为，改为异步提交表单，提供更好的用户体验\n\n在自定义事件的应用中，也会遇到一些类似的例子。例如：\n\n- 注册时，有一些邮箱虽然是可用的，但对于EDM不给力，在这种情况下，阻止表单项验证成功的默认行为，展示建议用户使用其它邮箱的提示\n- 表单验证组件在检查表单项失败后触发`failure`事件，对应的默认行为是在表单项下方显示错误信息。这样的处理在大部分情况下是完全OK的。不过有一天，交互设计师在一个特定场景下提出所有提示都应该放在整个表单顶部，得益于这种灵活的机制，实现这种定制化逻辑十分轻松\n- 字符计数插件在输入变化时会默认更新字符数提示。在评价内容中，有更复杂的提示逻辑和展示效果，这时阻止默认行为，实现定制化内容即可\n\n\n## 怎么用\n\n下面以表单项验证组件为例，展示如何使用事件默认行为。\n\n首先创建`FieldValidator`组件，并使其具备`EventTarget`的功能，实现自定义事件机制：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    var instance = this;\n    // ...\n};\nY.augment(FieldValidator, Y.EventTarget);\n```\n\n使用`publish`声明检查成功和失败的自定义事件，主要目的是定义事件的默认行为：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    // ...\n\n    // 声明检查成功事件，设置默认行为\n    instance.publish('success', {\n        emitFacade: true,\n        defaultFn: function (e) {\n            e.field.next('.tip').setHTML('ok');\n        }\n    });\n\n    // 声明检查失败事件，设置默认行为\n    instance.publish('failure', {\n        emitFacade: true,\n        defaultFn: function (e) {\n            e.field.next('.tip').setHTML('error');\n        }\n    });\n};\n```\n\n接下来注册表单项的`focus`、`blur`事件，在`blur`触发时检查表单内容，并触发自定义事件：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    // ...\n\n    ndField.on({\n        focus: function (e) {\n            ndField.next('.tip').setHTML('');\n        },\n        blur: function (e) {\n            if (validateFn(this.get('value'))) {\n                // 检查通过，触发检查成功事件\n                instance.fire('success', { field: ndField });\n            } else {\n                // 检查未通过，触发检查失败事件\n                instance.fire('failure', { field: ndField });\n            }\n        }\n    });\n};\n```\n\n现在就可以使用这个组件了，一般情况下，我们不需要阻止默认行为，下面是一个具体示例：\n\n```js\n// 检查邮箱\nnew FieldValidator(Y.one('[name=\"email\"]'), function (value) {\n    return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(value);\n});\n```\n\n一切看起来都很美，直到有一天你接到一个需求：Yahoo邮箱在检查通过时需要展示EDM不给力的提示，这时候默认行为就可以来拯救你了：\n\n```js\nvar validator = new FieldValidator(Y.one('[name=\"email\"]'), function (value) {\n    return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(value);\n});\nvalidator.on('success', function (e) {\n\tif (e.field.get('value').indexOf('@yahoo.com') !== -1) {\n        // 阻止默认行为\n        e.preventDefault();\n\n\t    // 定制化行为\n\t\te.field.next('.tip').setHTML('换个邮箱吧，yahoo.com邮箱收不到优惠通知哦');\n\t}\n});\n```\n\n在`success`事件的回调中，通过阻止默认行为，不再执行提示内容为OK的默认逻辑，而是切换成判断雅虎邮箱，并给出特定提示的定制化逻辑。\n\n完整代码展示，请移步[JSFiddle](http://jsfiddle.net/springuper/h4XAY/)。\n\n## 要注意\n\n一个好的idea，最容易被滥用。默认行为不是万能药，只适合一些这样的场景：\n\n- 需要通过事件进行消息广播。如果callback就可以解决问题，那么明智之举是使用callback\n- 存在定制化需求的预期，即有些情况下需要中止默认行为的发生，换之以定制化行为\n\n\n## 参考\n\n- [DOM3 Event - Default actions and cancelable events](https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel)\n- [YUI EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n","source":"_posts/yui3-event-default-action.md","raw":"---\nlayout: post\ntitle: \"YUI经验谈-自定义事件默认行为\"\ndate: 2014-02-14 10:00\ncomments: true\nstatus: publish\ntags: [YUI, Event, JavaScript]\n---\n\n纵观主流JS库和框架，YUI在自定义事件方面做的尤为出色。如果需要挑出一个代表性的feature，那么非**事件默认行为**莫属。\n\n## 是什么\n\nYUI自定义事件在总体上模仿了DOM事件的设计思想。DOM中的一些事件是有默认行为的，详细见[DOM3 Event - Default actions and cancelable events](https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel)一节。简单来说，所谓默认行为，是指该事件在通常情况下所表现出来的动作，例如：\n\n- 一个链接节点的`click`事件，默认行为是转向该链接href属性对应的地址\n- 表单的submit事件，默认行为是将表单包含的数据提交给表单的action\n\n说通常情况下，是因为有时开发者会在事件的回调函数中调用\n\n```\ne.preventDefault();\n```\n\n来阻止默认行为的发生。\n\n<!-- more -->\n\n<center><img alt=\"Event Default Action\" src=\"/images/event-default-action.png\" /></center>\n\nYUI自定义事件遵循了同样的思路，甚至API也和DOM完全一致。\n\n## 有啥用\n\n事件默认行为，本质上，是一种**管理事件和行为的对应关系**的机制。这种机制既不像回调那样死板，也不像消息那样开放。通过将通用处理逻辑作为事件默认行为，满足常见需求的同时，为定制化需求提供了一定开放性，整体上更加灵活。\n\n在DOM事件中，和默认行为相关的场景并不少见：\n\n- 监听到链接的`click`事件时，在链接地址中加入追踪参数，利用默认行为跳转到新地址\n- 阻止表单`submit`事件默认行为，改为异步提交表单，提供更好的用户体验\n\n在自定义事件的应用中，也会遇到一些类似的例子。例如：\n\n- 注册时，有一些邮箱虽然是可用的，但对于EDM不给力，在这种情况下，阻止表单项验证成功的默认行为，展示建议用户使用其它邮箱的提示\n- 表单验证组件在检查表单项失败后触发`failure`事件，对应的默认行为是在表单项下方显示错误信息。这样的处理在大部分情况下是完全OK的。不过有一天，交互设计师在一个特定场景下提出所有提示都应该放在整个表单顶部，得益于这种灵活的机制，实现这种定制化逻辑十分轻松\n- 字符计数插件在输入变化时会默认更新字符数提示。在评价内容中，有更复杂的提示逻辑和展示效果，这时阻止默认行为，实现定制化内容即可\n\n\n## 怎么用\n\n下面以表单项验证组件为例，展示如何使用事件默认行为。\n\n首先创建`FieldValidator`组件，并使其具备`EventTarget`的功能，实现自定义事件机制：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    var instance = this;\n    // ...\n};\nY.augment(FieldValidator, Y.EventTarget);\n```\n\n使用`publish`声明检查成功和失败的自定义事件，主要目的是定义事件的默认行为：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    // ...\n\n    // 声明检查成功事件，设置默认行为\n    instance.publish('success', {\n        emitFacade: true,\n        defaultFn: function (e) {\n            e.field.next('.tip').setHTML('ok');\n        }\n    });\n\n    // 声明检查失败事件，设置默认行为\n    instance.publish('failure', {\n        emitFacade: true,\n        defaultFn: function (e) {\n            e.field.next('.tip').setHTML('error');\n        }\n    });\n};\n```\n\n接下来注册表单项的`focus`、`blur`事件，在`blur`触发时检查表单内容，并触发自定义事件：\n\n```js\nvar FieldValidator = function (ndField, validateFn) {\n    // ...\n\n    ndField.on({\n        focus: function (e) {\n            ndField.next('.tip').setHTML('');\n        },\n        blur: function (e) {\n            if (validateFn(this.get('value'))) {\n                // 检查通过，触发检查成功事件\n                instance.fire('success', { field: ndField });\n            } else {\n                // 检查未通过，触发检查失败事件\n                instance.fire('failure', { field: ndField });\n            }\n        }\n    });\n};\n```\n\n现在就可以使用这个组件了，一般情况下，我们不需要阻止默认行为，下面是一个具体示例：\n\n```js\n// 检查邮箱\nnew FieldValidator(Y.one('[name=\"email\"]'), function (value) {\n    return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(value);\n});\n```\n\n一切看起来都很美，直到有一天你接到一个需求：Yahoo邮箱在检查通过时需要展示EDM不给力的提示，这时候默认行为就可以来拯救你了：\n\n```js\nvar validator = new FieldValidator(Y.one('[name=\"email\"]'), function (value) {\n    return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(value);\n});\nvalidator.on('success', function (e) {\n\tif (e.field.get('value').indexOf('@yahoo.com') !== -1) {\n        // 阻止默认行为\n        e.preventDefault();\n\n\t    // 定制化行为\n\t\te.field.next('.tip').setHTML('换个邮箱吧，yahoo.com邮箱收不到优惠通知哦');\n\t}\n});\n```\n\n在`success`事件的回调中，通过阻止默认行为，不再执行提示内容为OK的默认逻辑，而是切换成判断雅虎邮箱，并给出特定提示的定制化逻辑。\n\n完整代码展示，请移步[JSFiddle](http://jsfiddle.net/springuper/h4XAY/)。\n\n## 要注意\n\n一个好的idea，最容易被滥用。默认行为不是万能药，只适合一些这样的场景：\n\n- 需要通过事件进行消息广播。如果callback就可以解决问题，那么明智之举是使用callback\n- 存在定制化需求的预期，即有些情况下需要中止默认行为的发生，换之以定制化行为\n\n\n## 参考\n\n- [DOM3 Event - Default actions and cancelable events](https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel)\n- [YUI EventTarget](http://yuilibrary.com/yui/docs/event-custom/index.html)\n","slug":"yui3-event-default-action","published":1,"updated":"2021-10-05T09:27:48.617Z","photos":[],"link":"","_id":"cl1klgupx001r8e850b7ocwk7","content":"<p>纵观主流JS库和框架，YUI在自定义事件方面做的尤为出色。如果需要挑出一个代表性的feature，那么非<strong>事件默认行为</strong>莫属。</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>YUI自定义事件在总体上模仿了DOM事件的设计思想。DOM中的一些事件是有默认行为的，详细见<a href=\"https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel\">DOM3 Event - Default actions and cancelable events</a>一节。简单来说，所谓默认行为，是指该事件在通常情况下所表现出来的动作，例如：</p>\n<ul>\n<li>一个链接节点的<code>click</code>事件，默认行为是转向该链接href属性对应的地址</li>\n<li>表单的submit事件，默认行为是将表单包含的数据提交给表单的action</li>\n</ul>\n<p>说通常情况下，是因为有时开发者会在事件的回调函数中调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e.preventDefault();</span><br></pre></td></tr></table></figure>\n\n<p>来阻止默认行为的发生。</p>\n<span id=\"more\"></span>\n\n<center><img alt=\"Event Default Action\" src=\"/images/event-default-action.png\" /></center>\n\n<p>YUI自定义事件遵循了同样的思路，甚至API也和DOM完全一致。</p>\n<h2 id=\"有啥用\"><a href=\"#有啥用\" class=\"headerlink\" title=\"有啥用\"></a>有啥用</h2><p>事件默认行为，本质上，是一种<strong>管理事件和行为的对应关系</strong>的机制。这种机制既不像回调那样死板，也不像消息那样开放。通过将通用处理逻辑作为事件默认行为，满足常见需求的同时，为定制化需求提供了一定开放性，整体上更加灵活。</p>\n<p>在DOM事件中，和默认行为相关的场景并不少见：</p>\n<ul>\n<li>监听到链接的<code>click</code>事件时，在链接地址中加入追踪参数，利用默认行为跳转到新地址</li>\n<li>阻止表单<code>submit</code>事件默认行为，改为异步提交表单，提供更好的用户体验</li>\n</ul>\n<p>在自定义事件的应用中，也会遇到一些类似的例子。例如：</p>\n<ul>\n<li>注册时，有一些邮箱虽然是可用的，但对于EDM不给力，在这种情况下，阻止表单项验证成功的默认行为，展示建议用户使用其它邮箱的提示</li>\n<li>表单验证组件在检查表单项失败后触发<code>failure</code>事件，对应的默认行为是在表单项下方显示错误信息。这样的处理在大部分情况下是完全OK的。不过有一天，交互设计师在一个特定场景下提出所有提示都应该放在整个表单顶部，得益于这种灵活的机制，实现这种定制化逻辑十分轻松</li>\n<li>字符计数插件在输入变化时会默认更新字符数提示。在评价内容中，有更复杂的提示逻辑和展示效果，这时阻止默认行为，实现定制化内容即可</li>\n</ul>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p>下面以表单项验证组件为例，展示如何使用事件默认行为。</p>\n<p>首先创建<code>FieldValidator</code>组件，并使其具备<code>EventTarget</code>的功能，实现自定义事件机制：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.augment(FieldValidator, Y.EventTarget);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>publish</code>声明检查成功和失败的自定义事件，主要目的是定义事件的默认行为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明检查成功事件，设置默认行为</span></span><br><span class=\"line\">    instance.publish(<span class=\"string\">&#x27;success&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;ok&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明检查失败事件，设置默认行为</span></span><br><span class=\"line\">    instance.publish(<span class=\"string\">&#x27;failure&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;error&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来注册表单项的<code>focus</code>、<code>blur</code>事件，在<code>blur</code>触发时检查表单内容，并触发自定义事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ndField.on(&#123;</span><br><span class=\"line\">        <span class=\"attr\">focus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            ndField.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">blur</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (validateFn(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;value&#x27;</span>))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 检查通过，触发检查成功事件</span></span><br><span class=\"line\">                instance.fire(<span class=\"string\">&#x27;success&#x27;</span>, &#123; <span class=\"attr\">field</span>: ndField &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 检查未通过，触发检查失败事件</span></span><br><span class=\"line\">                instance.fire(<span class=\"string\">&#x27;failure&#x27;</span>, &#123; <span class=\"attr\">field</span>: ndField &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在就可以使用这个组件了，一般情况下，我们不需要阻止默认行为，下面是一个具体示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查邮箱</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> FieldValidator(Y.one(<span class=\"string\">&#x27;[name=&quot;email&quot;]&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"regexp\">/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/</span>.test(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>一切看起来都很美，直到有一天你接到一个需求：Yahoo邮箱在检查通过时需要展示EDM不给力的提示，这时候默认行为就可以来拯救你了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> validator = <span class=\"keyword\">new</span> FieldValidator(Y.one(<span class=\"string\">&#x27;[name=&quot;email&quot;]&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"regexp\">/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/</span>.test(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">validator.on(<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (e.field.get(<span class=\"string\">&#x27;value&#x27;</span>).indexOf(<span class=\"string\">&#x27;@yahoo.com&#x27;</span>) !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阻止默认行为</span></span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"comment\">// 定制化行为</span></span><br><span class=\"line\">\t\te.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;换个邮箱吧，yahoo.com邮箱收不到优惠通知哦&#x27;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>success</code>事件的回调中，通过阻止默认行为，不再执行提示内容为OK的默认逻辑，而是切换成判断雅虎邮箱，并给出特定提示的定制化逻辑。</p>\n<p>完整代码展示，请移步<a href=\"http://jsfiddle.net/springuper/h4XAY/\">JSFiddle</a>。</p>\n<h2 id=\"要注意\"><a href=\"#要注意\" class=\"headerlink\" title=\"要注意\"></a>要注意</h2><p>一个好的idea，最容易被滥用。默认行为不是万能药，只适合一些这样的场景：</p>\n<ul>\n<li>需要通过事件进行消息广播。如果callback就可以解决问题，那么明智之举是使用callback</li>\n<li>存在定制化需求的预期，即有些情况下需要中止默认行为的发生，换之以定制化行为</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel\">DOM3 Event - Default actions and cancelable events</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUI EventTarget</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>纵观主流JS库和框架，YUI在自定义事件方面做的尤为出色。如果需要挑出一个代表性的feature，那么非<strong>事件默认行为</strong>莫属。</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>YUI自定义事件在总体上模仿了DOM事件的设计思想。DOM中的一些事件是有默认行为的，详细见<a href=\"https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel\">DOM3 Event - Default actions and cancelable events</a>一节。简单来说，所谓默认行为，是指该事件在通常情况下所表现出来的动作，例如：</p>\n<ul>\n<li>一个链接节点的<code>click</code>事件，默认行为是转向该链接href属性对应的地址</li>\n<li>表单的submit事件，默认行为是将表单包含的数据提交给表单的action</li>\n</ul>\n<p>说通常情况下，是因为有时开发者会在事件的回调函数中调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e.preventDefault();</span><br></pre></td></tr></table></figure>\n\n<p>来阻止默认行为的发生。</p>","more":"<center><img alt=\"Event Default Action\" src=\"/images/event-default-action.png\" /></center>\n\n<p>YUI自定义事件遵循了同样的思路，甚至API也和DOM完全一致。</p>\n<h2 id=\"有啥用\"><a href=\"#有啥用\" class=\"headerlink\" title=\"有啥用\"></a>有啥用</h2><p>事件默认行为，本质上，是一种<strong>管理事件和行为的对应关系</strong>的机制。这种机制既不像回调那样死板，也不像消息那样开放。通过将通用处理逻辑作为事件默认行为，满足常见需求的同时，为定制化需求提供了一定开放性，整体上更加灵活。</p>\n<p>在DOM事件中，和默认行为相关的场景并不少见：</p>\n<ul>\n<li>监听到链接的<code>click</code>事件时，在链接地址中加入追踪参数，利用默认行为跳转到新地址</li>\n<li>阻止表单<code>submit</code>事件默认行为，改为异步提交表单，提供更好的用户体验</li>\n</ul>\n<p>在自定义事件的应用中，也会遇到一些类似的例子。例如：</p>\n<ul>\n<li>注册时，有一些邮箱虽然是可用的，但对于EDM不给力，在这种情况下，阻止表单项验证成功的默认行为，展示建议用户使用其它邮箱的提示</li>\n<li>表单验证组件在检查表单项失败后触发<code>failure</code>事件，对应的默认行为是在表单项下方显示错误信息。这样的处理在大部分情况下是完全OK的。不过有一天，交互设计师在一个特定场景下提出所有提示都应该放在整个表单顶部，得益于这种灵活的机制，实现这种定制化逻辑十分轻松</li>\n<li>字符计数插件在输入变化时会默认更新字符数提示。在评价内容中，有更复杂的提示逻辑和展示效果，这时阻止默认行为，实现定制化内容即可</li>\n</ul>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p>下面以表单项验证组件为例，展示如何使用事件默认行为。</p>\n<p>首先创建<code>FieldValidator</code>组件，并使其具备<code>EventTarget</code>的功能，实现自定义事件机制：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Y.augment(FieldValidator, Y.EventTarget);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>publish</code>声明检查成功和失败的自定义事件，主要目的是定义事件的默认行为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明检查成功事件，设置默认行为</span></span><br><span class=\"line\">    instance.publish(<span class=\"string\">&#x27;success&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;ok&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明检查失败事件，设置默认行为</span></span><br><span class=\"line\">    instance.publish(<span class=\"string\">&#x27;failure&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">emitFacade</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">defaultFn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;error&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来注册表单项的<code>focus</code>、<code>blur</code>事件，在<code>blur</code>触发时检查表单内容，并触发自定义事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FieldValidator = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ndField, validateFn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ndField.on(&#123;</span><br><span class=\"line\">        <span class=\"attr\">focus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            ndField.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">blur</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (validateFn(<span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;value&#x27;</span>))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 检查通过，触发检查成功事件</span></span><br><span class=\"line\">                instance.fire(<span class=\"string\">&#x27;success&#x27;</span>, &#123; <span class=\"attr\">field</span>: ndField &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 检查未通过，触发检查失败事件</span></span><br><span class=\"line\">                instance.fire(<span class=\"string\">&#x27;failure&#x27;</span>, &#123; <span class=\"attr\">field</span>: ndField &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在就可以使用这个组件了，一般情况下，我们不需要阻止默认行为，下面是一个具体示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查邮箱</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> FieldValidator(Y.one(<span class=\"string\">&#x27;[name=&quot;email&quot;]&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"regexp\">/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/</span>.test(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>一切看起来都很美，直到有一天你接到一个需求：Yahoo邮箱在检查通过时需要展示EDM不给力的提示，这时候默认行为就可以来拯救你了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> validator = <span class=\"keyword\">new</span> FieldValidator(Y.one(<span class=\"string\">&#x27;[name=&quot;email&quot;]&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"regexp\">/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/</span>.test(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">validator.on(<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (e.field.get(<span class=\"string\">&#x27;value&#x27;</span>).indexOf(<span class=\"string\">&#x27;@yahoo.com&#x27;</span>) !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阻止默认行为</span></span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"comment\">// 定制化行为</span></span><br><span class=\"line\">\t\te.field.next(<span class=\"string\">&#x27;.tip&#x27;</span>).setHTML(<span class=\"string\">&#x27;换个邮箱吧，yahoo.com邮箱收不到优惠通知哦&#x27;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>success</code>事件的回调中，通过阻止默认行为，不再执行提示内容为OK的默认逻辑，而是切换成判断雅虎邮箱，并给出特定提示的定制化逻辑。</p>\n<p>完整代码展示，请移步<a href=\"http://jsfiddle.net/springuper/h4XAY/\">JSFiddle</a>。</p>\n<h2 id=\"要注意\"><a href=\"#要注意\" class=\"headerlink\" title=\"要注意\"></a>要注意</h2><p>一个好的idea，最容易被滥用。默认行为不是万能药，只适合一些这样的场景：</p>\n<ul>\n<li>需要通过事件进行消息广播。如果callback就可以解决问题，那么明智之举是使用callback</li>\n<li>存在定制化需求的预期，即有些情况下需要中止默认行为的发生，换之以定制化行为</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel\">DOM3 Event - Default actions and cancelable events</a></li>\n<li><a href=\"http://yuilibrary.com/yui/docs/event-custom/index.html\">YUI EventTarget</a></li>\n</ul>"},{"layout":"post","title":"YUI3在美团","date":"2011-08-04T11:51:00.000Z","status":"publish","_content":"\n<div style=\"text-align:center;\"><div style=\"width:425px; margin:0 auto;\" id=\"__ss_8759550\"><object id=\"__sse8759550\" width=\"425\" height=\"355\"><param name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" /><param name=\"allowFullScreen\" value=\"true\"/><param name=\"allowScriptAccess\" value=\"always\"/><embed name=\"__sse8759550\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"></embed></object></div></div>\n\n<p style=\"text-align:center; text-indent:0;\"><a href=\"/assets/YUI3-in-Meituan.key_.zip\">keynote下载</a> | <a href=\"/assets/YUI3-in-Meituan.pdf.zip\">pdf下载</a></p>\n\n<!-- more -->\n\n## Notes：\n\n1. 常荣幸和大家一起分享我们团队在YUI3方面的一些实践。\n\n2. 我叫尚春，他们都叫我春哥。这里是我的博客和email。我在2010年12月11日毕业后进入美团工作，到现在已有7个多月的工作经验。这段时间，在师傅的指导下迅速成长，对前端的认识不断深入。\n\n3. 此次分享主要涉及两方面的内容。首先是关于选择YUI3作为基础库的原因，这里我们重点介绍下YUI3的模块机制；然后我们主要就我们实际迁移中遇到的一些挑战作详细表述，例如划分模块、加载策略等。\n\n4. 简要介绍下我们的前端团队。我们是一支小而精悍的队伍，为美团网视觉界面和用户交互提供充足动力。\n\n    - 我们崇尚的是“快”，通过快速开发、快速部署、快速迭代来完成任务、优化功能\n    - 我们坚持“在行进中开火”\n    - 我们认为做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒\n\n    这些信条可能更加适合我们这样的小团队。\n\n5. 我们首先要回答的问题是：为什么选择YUI3。第一个原因，我们原来采用的是YUI2。作为YUI团队的作品，YUI2非常正统、稳定。第二个原因，YUI团队已经把重心转移到YUI3，基本不再维护YUI2。但这都不是最有说服力的原因。\n\n6. 最为重要的原因是YUI3本身，它足够的优秀。YUI3具有很多新的特性，例如模块机制、选择器的全面应用、更强大的自定义事件、组件框架等等。如果说YUI2是库时代杰出典范之一的话，YUI3就是框架时代一颗璀璨的明星。\n\n7. 时间有限，我们重点介绍下YUI3的模块机制。模块是YUI3最大的变化，没有之一。这一底层设计机制改变了原有YUI2时代的规则。它为我们带来了自动加载、沙箱、combo等等特性，解放生产力的同时，提高了多人协作上的便利。使用YUI3添加模块、调用模块比较简单。\n\n8. 我们把源码进行适当简化，主要理解一下内部的机制。YUI构造器的add方法是这样定义的，即将模块的信息注册在YUI构造器的静态属性Env中。\n\n9. YUI的use方法主要流程是：计算调用模块所依赖的所有模块，将这些模块进行排序并输出，通过attach方法将这些模块的api依次捆绑在YUI实例（沙箱）上,将载满api的YUI实例传递到回调函数中。\n\n10. 与直接嵌入script标签相比，模块的特点有：\n\n    - 注册模块与调用模块分离，两者不是紧密耦合关系\n    - 所有模块都加载并绑定后才会执行回调函数，多个use间是异步关系。但，当所有模块都具备的情况下，多个use又是同步关系\n    - 通过实例绑定调用模块的api，实现了一种简便的沙箱机制。这一机制有利于协同开发\n    - 在模块定义时的一些元信息将所有模块有序组织起来，形成一个系统\n\n11. YUI3的所有模块分为四个层级，它们构成了YUI3的架构。\n\n    - 最底层是种子文件YUI，它定义了YUI构造器以及yui模块，主要包括Lang，UA，封装的Array, Object, 以及Get等等\n    - 第二层为核心工具层，主要是一些工具模块，例如DOM，Node，Event\n    - 第三层为组件框架层，主要是为构建组件提供丰富灵活的机制\n    - 第四层为组件层，包括了IO，JSON，Animation等重要模块\n\n12. 我们遇到很多挑战：\n\n    - 如何将原来的功能划分为模块，如何将所有模块组织起来，这是比较大的一个挑战\n    - Combo服务的实现。yahoo的combo只能提供YUI自身模块，而且速度在国内并不占优势。我们采用了minify，进行了一些修改和配置，能够在线上线下提供combo的支持\n    - 模块加载策略的研究\n    - 版本管理的问题。原来我们采用了query string的方式进行版本管理，现在则是用embedding的方式\n\n13. 目前，我们已经将大多数后台系统迁移到了YUI3。本季度我们要完成主站的迁移工作。\n\n14. 在介绍迁移之前，先看一下原来我们组织js的方式。这里主要包含三类文件：二次开发的核心文件core.js和一些widget文件，应用层级的文件，例如app-deal.js，来自第三方的文件，例如jquery.js。这种方式非常简单，但在web app时代已经不再适合较为复杂的前端开发，维护成本比较高。\n\n15. 那如何划分模块呢，我们总结了如下几条原则：\n\n    - 抽象与应用必须脱离。更通用的功能应该放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法\n    - 职责单一。保持每个模块的职责足够简单，方便维护和可持续开发\n    - 粒度得当。有了combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现\n    - 我们的模块体系应该是开放的，不符合YUI规范的第三方模块，我们可以借鉴整合进来，使我们的基础框架更加完善，更加性感\n\n16. 美团的JS架构，按照抽象与应用程度，分为四层：\n\n    - 最底层交给强悍的YUI3，为我们提供很跨浏览器的api和很好的框架\n    - 第二层是我们二次开发的一些核心方法和控件库。mt-base中包含strtotime，getRadioValue等基础方法，对Cookie的简单操作，一些封装的页面动画等。w-base，w-autocomplete等包含一些封装的控件，提供更加高效的用户体验，且便于后端人员调用\n    - 第三层包含美团各个分站点的一些通用模块。例如mis-base包含后台mis系统的消息系统、checkFormChanged等通用方法。这一层更加接近应用\n    - 最上面一层，应用模块，这些模块的方法都是用来解决实际问题的。例如mis-deal用来处理mis系统中所有deal相关页面的交互，finance-pay用来处理财务系统中的付款相关页面的交互。一些零碎的应用方法我们放在对应站点的misc模块中\n\n20. 为了保持向前兼容，我们定义了新的全局对象M。我们对YUI进行了简单的封装，可以使用M.add添加模块，使用M.use调用模块。请注意，每次使用M.use都会新生成一个config的实例，这个config信息主要包含一些combo服务器信息，我们自己开发模块的信息。这样loader就知道该如何计算依赖的模块了。在对use的封装中，我们还引入了debug的功能。［代码演示］\n\n24. 目前我们采用的加载方式是：预加载通用基础模块，例如yui，node，event，io等，然后是站点级别的一些操作，例如mis系统的widget初始化、消息系统初始化等，最后是页面级别的一个特定应用入口。\n\n25. 我们对基于PHP loader的服务器端loader进行了尝试，并准备近期进行部署。\n\n    服务器端loader优势在于速度，同时，将其整合在框架中降低了维护成本，简便易用。\n\n26. 通过使用服务器端loader，可以做到一次性加载。\n\n\n","source":"_posts/yui3-in-meituan.md","raw":"---\nlayout: post\ntitle: \"YUI3在美团\"\ndate: 2011-08-04 19:51\nstatus: publish\ntags: [YUI, Meituan]\n---\n\n<div style=\"text-align:center;\"><div style=\"width:425px; margin:0 auto;\" id=\"__ss_8759550\"><object id=\"__sse8759550\" width=\"425\" height=\"355\"><param name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" /><param name=\"allowFullScreen\" value=\"true\"/><param name=\"allowScriptAccess\" value=\"always\"/><embed name=\"__sse8759550\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"></embed></object></div></div>\n\n<p style=\"text-align:center; text-indent:0;\"><a href=\"/assets/YUI3-in-Meituan.key_.zip\">keynote下载</a> | <a href=\"/assets/YUI3-in-Meituan.pdf.zip\">pdf下载</a></p>\n\n<!-- more -->\n\n## Notes：\n\n1. 常荣幸和大家一起分享我们团队在YUI3方面的一些实践。\n\n2. 我叫尚春，他们都叫我春哥。这里是我的博客和email。我在2010年12月11日毕业后进入美团工作，到现在已有7个多月的工作经验。这段时间，在师傅的指导下迅速成长，对前端的认识不断深入。\n\n3. 此次分享主要涉及两方面的内容。首先是关于选择YUI3作为基础库的原因，这里我们重点介绍下YUI3的模块机制；然后我们主要就我们实际迁移中遇到的一些挑战作详细表述，例如划分模块、加载策略等。\n\n4. 简要介绍下我们的前端团队。我们是一支小而精悍的队伍，为美团网视觉界面和用户交互提供充足动力。\n\n    - 我们崇尚的是“快”，通过快速开发、快速部署、快速迭代来完成任务、优化功能\n    - 我们坚持“在行进中开火”\n    - 我们认为做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒\n\n    这些信条可能更加适合我们这样的小团队。\n\n5. 我们首先要回答的问题是：为什么选择YUI3。第一个原因，我们原来采用的是YUI2。作为YUI团队的作品，YUI2非常正统、稳定。第二个原因，YUI团队已经把重心转移到YUI3，基本不再维护YUI2。但这都不是最有说服力的原因。\n\n6. 最为重要的原因是YUI3本身，它足够的优秀。YUI3具有很多新的特性，例如模块机制、选择器的全面应用、更强大的自定义事件、组件框架等等。如果说YUI2是库时代杰出典范之一的话，YUI3就是框架时代一颗璀璨的明星。\n\n7. 时间有限，我们重点介绍下YUI3的模块机制。模块是YUI3最大的变化，没有之一。这一底层设计机制改变了原有YUI2时代的规则。它为我们带来了自动加载、沙箱、combo等等特性，解放生产力的同时，提高了多人协作上的便利。使用YUI3添加模块、调用模块比较简单。\n\n8. 我们把源码进行适当简化，主要理解一下内部的机制。YUI构造器的add方法是这样定义的，即将模块的信息注册在YUI构造器的静态属性Env中。\n\n9. YUI的use方法主要流程是：计算调用模块所依赖的所有模块，将这些模块进行排序并输出，通过attach方法将这些模块的api依次捆绑在YUI实例（沙箱）上,将载满api的YUI实例传递到回调函数中。\n\n10. 与直接嵌入script标签相比，模块的特点有：\n\n    - 注册模块与调用模块分离，两者不是紧密耦合关系\n    - 所有模块都加载并绑定后才会执行回调函数，多个use间是异步关系。但，当所有模块都具备的情况下，多个use又是同步关系\n    - 通过实例绑定调用模块的api，实现了一种简便的沙箱机制。这一机制有利于协同开发\n    - 在模块定义时的一些元信息将所有模块有序组织起来，形成一个系统\n\n11. YUI3的所有模块分为四个层级，它们构成了YUI3的架构。\n\n    - 最底层是种子文件YUI，它定义了YUI构造器以及yui模块，主要包括Lang，UA，封装的Array, Object, 以及Get等等\n    - 第二层为核心工具层，主要是一些工具模块，例如DOM，Node，Event\n    - 第三层为组件框架层，主要是为构建组件提供丰富灵活的机制\n    - 第四层为组件层，包括了IO，JSON，Animation等重要模块\n\n12. 我们遇到很多挑战：\n\n    - 如何将原来的功能划分为模块，如何将所有模块组织起来，这是比较大的一个挑战\n    - Combo服务的实现。yahoo的combo只能提供YUI自身模块，而且速度在国内并不占优势。我们采用了minify，进行了一些修改和配置，能够在线上线下提供combo的支持\n    - 模块加载策略的研究\n    - 版本管理的问题。原来我们采用了query string的方式进行版本管理，现在则是用embedding的方式\n\n13. 目前，我们已经将大多数后台系统迁移到了YUI3。本季度我们要完成主站的迁移工作。\n\n14. 在介绍迁移之前，先看一下原来我们组织js的方式。这里主要包含三类文件：二次开发的核心文件core.js和一些widget文件，应用层级的文件，例如app-deal.js，来自第三方的文件，例如jquery.js。这种方式非常简单，但在web app时代已经不再适合较为复杂的前端开发，维护成本比较高。\n\n15. 那如何划分模块呢，我们总结了如下几条原则：\n\n    - 抽象与应用必须脱离。更通用的功能应该放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法\n    - 职责单一。保持每个模块的职责足够简单，方便维护和可持续开发\n    - 粒度得当。有了combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现\n    - 我们的模块体系应该是开放的，不符合YUI规范的第三方模块，我们可以借鉴整合进来，使我们的基础框架更加完善，更加性感\n\n16. 美团的JS架构，按照抽象与应用程度，分为四层：\n\n    - 最底层交给强悍的YUI3，为我们提供很跨浏览器的api和很好的框架\n    - 第二层是我们二次开发的一些核心方法和控件库。mt-base中包含strtotime，getRadioValue等基础方法，对Cookie的简单操作，一些封装的页面动画等。w-base，w-autocomplete等包含一些封装的控件，提供更加高效的用户体验，且便于后端人员调用\n    - 第三层包含美团各个分站点的一些通用模块。例如mis-base包含后台mis系统的消息系统、checkFormChanged等通用方法。这一层更加接近应用\n    - 最上面一层，应用模块，这些模块的方法都是用来解决实际问题的。例如mis-deal用来处理mis系统中所有deal相关页面的交互，finance-pay用来处理财务系统中的付款相关页面的交互。一些零碎的应用方法我们放在对应站点的misc模块中\n\n20. 为了保持向前兼容，我们定义了新的全局对象M。我们对YUI进行了简单的封装，可以使用M.add添加模块，使用M.use调用模块。请注意，每次使用M.use都会新生成一个config的实例，这个config信息主要包含一些combo服务器信息，我们自己开发模块的信息。这样loader就知道该如何计算依赖的模块了。在对use的封装中，我们还引入了debug的功能。［代码演示］\n\n24. 目前我们采用的加载方式是：预加载通用基础模块，例如yui，node，event，io等，然后是站点级别的一些操作，例如mis系统的widget初始化、消息系统初始化等，最后是页面级别的一个特定应用入口。\n\n25. 我们对基于PHP loader的服务器端loader进行了尝试，并准备近期进行部署。\n\n    服务器端loader优势在于速度，同时，将其整合在框架中降低了维护成本，简便易用。\n\n26. 通过使用服务器端loader，可以做到一次性加载。\n\n\n","slug":"yui3-in-meituan","published":1,"updated":"2021-10-04T12:57:16.034Z","comments":1,"photos":[],"link":"","_id":"cl1klgupx001t8e85crkb8vli","content":"<div style=\"text-align:center;\"><div style=\"width:425px; margin:0 auto;\" id=\"__ss_8759550\"><object id=\"__sse8759550\" width=\"425\" height=\"355\"><param name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" /><param name=\"allowFullScreen\" value=\"true\"/><param name=\"allowScriptAccess\" value=\"always\"/><embed name=\"__sse8759550\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"></embed></object></div></div>\n\n<p style=\"text-align:center; text-indent:0;\"><a href=\"/assets/YUI3-in-Meituan.key_.zip\">keynote下载</a> | <a href=\"/assets/YUI3-in-Meituan.pdf.zip\">pdf下载</a></p>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Notes：\"><a href=\"#Notes：\" class=\"headerlink\" title=\"Notes：\"></a>Notes：</h2><ol>\n<li><p>常荣幸和大家一起分享我们团队在YUI3方面的一些实践。</p>\n</li>\n<li><p>我叫尚春，他们都叫我春哥。这里是我的博客和email。我在2010年12月11日毕业后进入美团工作，到现在已有7个多月的工作经验。这段时间，在师傅的指导下迅速成长，对前端的认识不断深入。</p>\n</li>\n<li><p>此次分享主要涉及两方面的内容。首先是关于选择YUI3作为基础库的原因，这里我们重点介绍下YUI3的模块机制；然后我们主要就我们实际迁移中遇到的一些挑战作详细表述，例如划分模块、加载策略等。</p>\n</li>\n<li><p>简要介绍下我们的前端团队。我们是一支小而精悍的队伍，为美团网视觉界面和用户交互提供充足动力。</p>\n<ul>\n<li>我们崇尚的是“快”，通过快速开发、快速部署、快速迭代来完成任务、优化功能</li>\n<li>我们坚持“在行进中开火”</li>\n<li>我们认为做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒</li>\n</ul>\n<p> 这些信条可能更加适合我们这样的小团队。</p>\n</li>\n<li><p>我们首先要回答的问题是：为什么选择YUI3。第一个原因，我们原来采用的是YUI2。作为YUI团队的作品，YUI2非常正统、稳定。第二个原因，YUI团队已经把重心转移到YUI3，基本不再维护YUI2。但这都不是最有说服力的原因。</p>\n</li>\n<li><p>最为重要的原因是YUI3本身，它足够的优秀。YUI3具有很多新的特性，例如模块机制、选择器的全面应用、更强大的自定义事件、组件框架等等。如果说YUI2是库时代杰出典范之一的话，YUI3就是框架时代一颗璀璨的明星。</p>\n</li>\n<li><p>时间有限，我们重点介绍下YUI3的模块机制。模块是YUI3最大的变化，没有之一。这一底层设计机制改变了原有YUI2时代的规则。它为我们带来了自动加载、沙箱、combo等等特性，解放生产力的同时，提高了多人协作上的便利。使用YUI3添加模块、调用模块比较简单。</p>\n</li>\n<li><p>我们把源码进行适当简化，主要理解一下内部的机制。YUI构造器的add方法是这样定义的，即将模块的信息注册在YUI构造器的静态属性Env中。</p>\n</li>\n<li><p>YUI的use方法主要流程是：计算调用模块所依赖的所有模块，将这些模块进行排序并输出，通过attach方法将这些模块的api依次捆绑在YUI实例（沙箱）上,将载满api的YUI实例传递到回调函数中。</p>\n</li>\n<li><p>与直接嵌入script标签相比，模块的特点有：</p>\n<ul>\n<li>注册模块与调用模块分离，两者不是紧密耦合关系</li>\n<li>所有模块都加载并绑定后才会执行回调函数，多个use间是异步关系。但，当所有模块都具备的情况下，多个use又是同步关系</li>\n<li>通过实例绑定调用模块的api，实现了一种简便的沙箱机制。这一机制有利于协同开发</li>\n<li>在模块定义时的一些元信息将所有模块有序组织起来，形成一个系统</li>\n</ul>\n</li>\n<li><p>YUI3的所有模块分为四个层级，它们构成了YUI3的架构。</p>\n<ul>\n<li>最底层是种子文件YUI，它定义了YUI构造器以及yui模块，主要包括Lang，UA，封装的Array, Object, 以及Get等等</li>\n<li>第二层为核心工具层，主要是一些工具模块，例如DOM，Node，Event</li>\n<li>第三层为组件框架层，主要是为构建组件提供丰富灵活的机制</li>\n<li>第四层为组件层，包括了IO，JSON，Animation等重要模块</li>\n</ul>\n</li>\n<li><p>我们遇到很多挑战：</p>\n<ul>\n<li>如何将原来的功能划分为模块，如何将所有模块组织起来，这是比较大的一个挑战</li>\n<li>Combo服务的实现。yahoo的combo只能提供YUI自身模块，而且速度在国内并不占优势。我们采用了minify，进行了一些修改和配置，能够在线上线下提供combo的支持</li>\n<li>模块加载策略的研究</li>\n<li>版本管理的问题。原来我们采用了query string的方式进行版本管理，现在则是用embedding的方式</li>\n</ul>\n</li>\n<li><p>目前，我们已经将大多数后台系统迁移到了YUI3。本季度我们要完成主站的迁移工作。</p>\n</li>\n<li><p>在介绍迁移之前，先看一下原来我们组织js的方式。这里主要包含三类文件：二次开发的核心文件core.js和一些widget文件，应用层级的文件，例如app-deal.js，来自第三方的文件，例如jquery.js。这种方式非常简单，但在web app时代已经不再适合较为复杂的前端开发，维护成本比较高。</p>\n</li>\n<li><p>那如何划分模块呢，我们总结了如下几条原则：</p>\n<ul>\n<li>抽象与应用必须脱离。更通用的功能应该放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法</li>\n<li>职责单一。保持每个模块的职责足够简单，方便维护和可持续开发</li>\n<li>粒度得当。有了combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现</li>\n<li>我们的模块体系应该是开放的，不符合YUI规范的第三方模块，我们可以借鉴整合进来，使我们的基础框架更加完善，更加性感</li>\n</ul>\n</li>\n<li><p>美团的JS架构，按照抽象与应用程度，分为四层：</p>\n<ul>\n<li>最底层交给强悍的YUI3，为我们提供很跨浏览器的api和很好的框架</li>\n<li>第二层是我们二次开发的一些核心方法和控件库。mt-base中包含strtotime，getRadioValue等基础方法，对Cookie的简单操作，一些封装的页面动画等。w-base，w-autocomplete等包含一些封装的控件，提供更加高效的用户体验，且便于后端人员调用</li>\n<li>第三层包含美团各个分站点的一些通用模块。例如mis-base包含后台mis系统的消息系统、checkFormChanged等通用方法。这一层更加接近应用</li>\n<li>最上面一层，应用模块，这些模块的方法都是用来解决实际问题的。例如mis-deal用来处理mis系统中所有deal相关页面的交互，finance-pay用来处理财务系统中的付款相关页面的交互。一些零碎的应用方法我们放在对应站点的misc模块中</li>\n</ul>\n</li>\n<li><p>为了保持向前兼容，我们定义了新的全局对象M。我们对YUI进行了简单的封装，可以使用M.add添加模块，使用M.use调用模块。请注意，每次使用M.use都会新生成一个config的实例，这个config信息主要包含一些combo服务器信息，我们自己开发模块的信息。这样loader就知道该如何计算依赖的模块了。在对use的封装中，我们还引入了debug的功能。［代码演示］</p>\n</li>\n<li><p>目前我们采用的加载方式是：预加载通用基础模块，例如yui，node，event，io等，然后是站点级别的一些操作，例如mis系统的widget初始化、消息系统初始化等，最后是页面级别的一个特定应用入口。</p>\n</li>\n<li><p>我们对基于PHP loader的服务器端loader进行了尝试，并准备近期进行部署。</p>\n<p>服务器端loader优势在于速度，同时，将其整合在框架中降低了维护成本，简便易用。</p>\n</li>\n<li><p>通过使用服务器端loader，可以做到一次性加载。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<div style=\"text-align:center;\"><div style=\"width:425px; margin:0 auto;\" id=\"__ss_8759550\"><object id=\"__sse8759550\" width=\"425\" height=\"355\"><param name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" /><param name=\"allowFullScreen\" value=\"true\"/><param name=\"allowScriptAccess\" value=\"always\"/><embed name=\"__sse8759550\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=yui3-110802225931-phpapp02&stripped_title=yui3-8759550&userName=springuper\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"></embed></object></div></div>\n\n<p style=\"text-align:center; text-indent:0;\"><a href=\"/assets/YUI3-in-Meituan.key_.zip\">keynote下载</a> | <a href=\"/assets/YUI3-in-Meituan.pdf.zip\">pdf下载</a></p>","more":"<h2 id=\"Notes：\"><a href=\"#Notes：\" class=\"headerlink\" title=\"Notes：\"></a>Notes：</h2><ol>\n<li><p>常荣幸和大家一起分享我们团队在YUI3方面的一些实践。</p>\n</li>\n<li><p>我叫尚春，他们都叫我春哥。这里是我的博客和email。我在2010年12月11日毕业后进入美团工作，到现在已有7个多月的工作经验。这段时间，在师傅的指导下迅速成长，对前端的认识不断深入。</p>\n</li>\n<li><p>此次分享主要涉及两方面的内容。首先是关于选择YUI3作为基础库的原因，这里我们重点介绍下YUI3的模块机制；然后我们主要就我们实际迁移中遇到的一些挑战作详细表述，例如划分模块、加载策略等。</p>\n</li>\n<li><p>简要介绍下我们的前端团队。我们是一支小而精悍的队伍，为美团网视觉界面和用户交互提供充足动力。</p>\n<ul>\n<li>我们崇尚的是“快”，通过快速开发、快速部署、快速迭代来完成任务、优化功能</li>\n<li>我们坚持“在行进中开火”</li>\n<li>我们认为做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒</li>\n</ul>\n<p> 这些信条可能更加适合我们这样的小团队。</p>\n</li>\n<li><p>我们首先要回答的问题是：为什么选择YUI3。第一个原因，我们原来采用的是YUI2。作为YUI团队的作品，YUI2非常正统、稳定。第二个原因，YUI团队已经把重心转移到YUI3，基本不再维护YUI2。但这都不是最有说服力的原因。</p>\n</li>\n<li><p>最为重要的原因是YUI3本身，它足够的优秀。YUI3具有很多新的特性，例如模块机制、选择器的全面应用、更强大的自定义事件、组件框架等等。如果说YUI2是库时代杰出典范之一的话，YUI3就是框架时代一颗璀璨的明星。</p>\n</li>\n<li><p>时间有限，我们重点介绍下YUI3的模块机制。模块是YUI3最大的变化，没有之一。这一底层设计机制改变了原有YUI2时代的规则。它为我们带来了自动加载、沙箱、combo等等特性，解放生产力的同时，提高了多人协作上的便利。使用YUI3添加模块、调用模块比较简单。</p>\n</li>\n<li><p>我们把源码进行适当简化，主要理解一下内部的机制。YUI构造器的add方法是这样定义的，即将模块的信息注册在YUI构造器的静态属性Env中。</p>\n</li>\n<li><p>YUI的use方法主要流程是：计算调用模块所依赖的所有模块，将这些模块进行排序并输出，通过attach方法将这些模块的api依次捆绑在YUI实例（沙箱）上,将载满api的YUI实例传递到回调函数中。</p>\n</li>\n<li><p>与直接嵌入script标签相比，模块的特点有：</p>\n<ul>\n<li>注册模块与调用模块分离，两者不是紧密耦合关系</li>\n<li>所有模块都加载并绑定后才会执行回调函数，多个use间是异步关系。但，当所有模块都具备的情况下，多个use又是同步关系</li>\n<li>通过实例绑定调用模块的api，实现了一种简便的沙箱机制。这一机制有利于协同开发</li>\n<li>在模块定义时的一些元信息将所有模块有序组织起来，形成一个系统</li>\n</ul>\n</li>\n<li><p>YUI3的所有模块分为四个层级，它们构成了YUI3的架构。</p>\n<ul>\n<li>最底层是种子文件YUI，它定义了YUI构造器以及yui模块，主要包括Lang，UA，封装的Array, Object, 以及Get等等</li>\n<li>第二层为核心工具层，主要是一些工具模块，例如DOM，Node，Event</li>\n<li>第三层为组件框架层，主要是为构建组件提供丰富灵活的机制</li>\n<li>第四层为组件层，包括了IO，JSON，Animation等重要模块</li>\n</ul>\n</li>\n<li><p>我们遇到很多挑战：</p>\n<ul>\n<li>如何将原来的功能划分为模块，如何将所有模块组织起来，这是比较大的一个挑战</li>\n<li>Combo服务的实现。yahoo的combo只能提供YUI自身模块，而且速度在国内并不占优势。我们采用了minify，进行了一些修改和配置，能够在线上线下提供combo的支持</li>\n<li>模块加载策略的研究</li>\n<li>版本管理的问题。原来我们采用了query string的方式进行版本管理，现在则是用embedding的方式</li>\n</ul>\n</li>\n<li><p>目前，我们已经将大多数后台系统迁移到了YUI3。本季度我们要完成主站的迁移工作。</p>\n</li>\n<li><p>在介绍迁移之前，先看一下原来我们组织js的方式。这里主要包含三类文件：二次开发的核心文件core.js和一些widget文件，应用层级的文件，例如app-deal.js，来自第三方的文件，例如jquery.js。这种方式非常简单，但在web app时代已经不再适合较为复杂的前端开发，维护成本比较高。</p>\n</li>\n<li><p>那如何划分模块呢，我们总结了如下几条原则：</p>\n<ul>\n<li>抽象与应用必须脱离。更通用的功能应该放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法</li>\n<li>职责单一。保持每个模块的职责足够简单，方便维护和可持续开发</li>\n<li>粒度得当。有了combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现</li>\n<li>我们的模块体系应该是开放的，不符合YUI规范的第三方模块，我们可以借鉴整合进来，使我们的基础框架更加完善，更加性感</li>\n</ul>\n</li>\n<li><p>美团的JS架构，按照抽象与应用程度，分为四层：</p>\n<ul>\n<li>最底层交给强悍的YUI3，为我们提供很跨浏览器的api和很好的框架</li>\n<li>第二层是我们二次开发的一些核心方法和控件库。mt-base中包含strtotime，getRadioValue等基础方法，对Cookie的简单操作，一些封装的页面动画等。w-base，w-autocomplete等包含一些封装的控件，提供更加高效的用户体验，且便于后端人员调用</li>\n<li>第三层包含美团各个分站点的一些通用模块。例如mis-base包含后台mis系统的消息系统、checkFormChanged等通用方法。这一层更加接近应用</li>\n<li>最上面一层，应用模块，这些模块的方法都是用来解决实际问题的。例如mis-deal用来处理mis系统中所有deal相关页面的交互，finance-pay用来处理财务系统中的付款相关页面的交互。一些零碎的应用方法我们放在对应站点的misc模块中</li>\n</ul>\n</li>\n<li><p>为了保持向前兼容，我们定义了新的全局对象M。我们对YUI进行了简单的封装，可以使用M.add添加模块，使用M.use调用模块。请注意，每次使用M.use都会新生成一个config的实例，这个config信息主要包含一些combo服务器信息，我们自己开发模块的信息。这样loader就知道该如何计算依赖的模块了。在对use的封装中，我们还引入了debug的功能。［代码演示］</p>\n</li>\n<li><p>目前我们采用的加载方式是：预加载通用基础模块，例如yui，node，event，io等，然后是站点级别的一些操作，例如mis系统的widget初始化、消息系统初始化等，最后是页面级别的一个特定应用入口。</p>\n</li>\n<li><p>我们对基于PHP loader的服务器端loader进行了尝试，并准备近期进行部署。</p>\n<p>服务器端loader优势在于速度，同时，将其整合在框架中降低了维护成本，简便易用。</p>\n</li>\n<li><p>通过使用服务器端loader，可以做到一次性加载。</p>\n</li>\n</ol>"},{"layout":"post","title":"YUI3在美团的实践","date":"2013-05-10T14:35:00.000Z","comments":1,"status":"publish","_content":"\n美团网在2010年引爆了团购行业，并在2012年销售额超过55亿，实现了全面盈利。在业务规模不断增长的背后，作为研发队伍中和用户最接近的前端团队承担着非常大的压力，比如用户量急剧上升带来的产品多样化，业务运营系统的界面交互日益复杂，代码膨胀造成维护成本增加等等。面对这些挑战，我们持续改进前端技术架构，在提升用户体验和工作效率的同时，成功支撑了美团业务的快速发展，这一切都得益于构建在YUI3框架之上稳定高效的前端代码。在应用YUI3的过程中，我们团队积累了一些经验，这里总结成篇，分享给大家。\n\n## 为什么选择YUI3\n\n使用什么前端基础框架是建立前端团队最重要的技术决策之一。美团项目初期因为要加快开发进度，选择了当时团队最熟悉的YUI2（前框架时代杰出的类库），保证美团能够更快更早地上线，抢占市场先机。不久由于前端技术发展很快，YUI2的缺点逐渐凸显，例如开发方式落后、影响工作效率等等，于是我们开始考虑基础库的迁移。\n\n经过一段时间对主流前端库、框架的反复考量，我们认为YUI3是最适合我们团队使用的基础框架。\n\n首先，国内的开源框架及其社区刚开始起步，在代码质量、架构设计和理念创新上还难以跟YUI3比肩，所以基本排除在外。其次，国外像YUI3这样面向用户产品、文档丰富、扩展性良好的成熟框架屈指可数，例如ExtJS和Dojo则更适合业务复杂的传统企业级开发。最后，使用jQuery这种类库构建同YUI3一样强大的框架对创业团队来说并不可取，美团快速发展、竞争多变的业务特点决定了我们必须把主要精力放在更高一层的业务开发上，而不是去重复发明一个蹩脚的YUI。\n\nYUI3成为最终选择有以下几个直接的原因：\n\n- 非常优秀，是真正的框架，真正的重型武器，具有强劲的持续开发能力，可以应对业务的快速发展。不管是规模不断增长的用户产品，还是交互日趋复杂的业务系统（美团有超过100个业务系统作全电子化的运营支撑），YUI3都游刃有余。\n- 代码整齐规范，容易维护，适合有洁癖的工程师，同时能够显著提高团队协作时的开发效率。因为人手紧缺，后端工程师也需要参与前端开发，一致的代码风格使前后端配合轻松简单。\n- 有出色的架构设计，是很好的框架范本，通过研究学习可以帮助工程师成长，培养良好的工程思维。人是美团最重要的产品。\n\n随着团队成长，我们最后引入了YUI3，在迁移过程中，遇到了很多技术上的和工程上的挑战，但是我们一直在前进，一直在行进中开火。从结果来看，YUI3为我们团队提供了先进生产力，为快速开发、快速部署、快速迭代提供了源源不断的力量。\n\nYUI3的优秀主要表现在模块和组件框架的出色设计，下面我们着重介绍这两方面的一些实践经验。\n\n<!-- more -->\n\n## 改变一切的模块\n\n前端开发日益复杂化，代码组织成为一个显著的问题。受到后端代码普遍采用的模块机制启发，很多前端模块机制应运而生。目前比较著名的有CommonJS和AMD。但早在2008年8月13日，YUI3 Preview Release 1中就已经给出了YUI团队的解决方案，并在2009年9月29日YUI3正式版发布时定型。\n\n以下是使用YUI3进行模块化开发的简单例子\n\n```javascript\n// 定义模块\nYUI.add('greeting', function (Y) {\n\tY.sayHello = function () {\n\t\tconsole.log('Hello, world!');\n\t};\n});\n\n// 调用模块\nYUI().use('greeting', function (Y) {\n\tY.sayHello(); // output 'Hello, world!'\n});\n```\n\n模块的引入，使得更细粒度的按功能进行代码组织成为可能，也为方便的进行扩展和分层提供了基础，自底向上的彻底改变了YUI3。一套完整的模块机制，还包括解决关系依赖、自动加载的Loader和提高加载效率的Combo。\n\n面对如此彻底的改变，我们需要解决很多挑战：\n\n- 如何将原来的功能划分为模块？\n- 如何管理模块元信息？\n- 如何高效的获取模块？\n\n### 划分模块\n\n经过两年来不断的实践和总结，我们归纳了如下几条划分模块的原则：\n\n- **抽象与应用脱离**。更通用的功能放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法。\n- **职责单一**。保持每个模块的足够简单和专一，方便维护和可持续开发。\n- **粒度得当**。有了Combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现。\n- **海纳百川**。我们的模块体系应该是开放的，不符合YUI规范的第三方模块，可以借鉴整合进来，使我们的基础框架更加完善，更加性感。\n\n<center>\n  <img alt=\"美团前端架构\" src=\"/images/mt-fe-architecture.png\" />\n</center>\n\n按照模块的层次划分，美团的JS框架可以分为四个层次：\n\n1. **最底层交给强悍的YUI3**，为我们提供跨浏览器兼容的API和良好的框架设计。\n2. **第二层是我们二次开发的核心方法、组件（Component）和控件（Widget）**。现已独立为前端核心库，为美团所有系统提供前端支持。核心库的种子文件中定义了全局变量M，除了对YUI3进行封装的代码以外，还包含了对语言层面的扩展，以及一些基础工具类。核心库有一个非常重要的组成部分，就是我们功能丰富的控件集合，比如常用的自动完成、排序表格、气泡提示、对话框等基础控件。除了这些，核心库还包含了常用的基础组件、插件（Plugin）、扩展（Extension）以及单元测试代码。\n3. **第三层包含各个系统的一些通用模块**。例如www-base模块包含美团主站（www）的消息系统、用户行为追踪系统等通用功能。这一层更加接近应用。\n4. **最上面一层，应用模块**。这些模块的方法都是用来解决实际业务问题。例如www-deal用来处理美团主站所有deal相关功能的交互，finance-pay用来处理财务系统中付款相关的交互。一些零碎的应用方法我们放在对应系统的misc模块中，避免模块碎片化。\n\n这套框架仍在不断演变，以便更好的支撑业务需求。其中一个明显的方向是，在第二层和第三层之间，出现一个为了更好整合所有内部业务系统前端通用资源的中间层。\n\n### 管理模块元信息\n\n模块元信息主要包括模块名称、路径、依赖关系等内容。其中最为重要的是依赖关系，这决定了有哪些模块需要加载。为了实现自动加载，需要将所有模块的元信息提供给YUI的Loader。\n\n最初，为了更快的从YUI2迁移到YUI3，模块元信息放在PHP中进行维护。随着时间的推移，渐渐显示出很多弊端。首先，在定义模块的js文件中已经包含模块名称、依赖关系等信息，和PHP中内容重复。其次，这些元信息最终直接输出到html中，没有有效利用缓存。\n\n随后，我们使用NodeJS开发了一系列脚本，收集所有模块元信息，保存为独立js文件，并实现了自动化。为了防止出错，在Git Hooks和上线脚本中都加入了校验过程。工程师需要做的，只是修改模块定义中的元信息。\n\n最近一段时间，我们的精力主要放在两个方面：\n\n- **自动生成依赖**。随着模块粒度细化和模块数量的增长，依赖关系日益复杂，依靠人工配置经常出现过多依赖或过少依赖等问题。我们准备开发一套自动扫描模块引用API，并确定依赖关系的机制。\n- **自动打包依赖模块**。如果在代码发布时，就已根据页面模块调用计算好所有依赖模块，并进行打包，可以避免引用全部模块元信息、Loader计算依赖等过程，提高网站性能。\n\n### Combo\n\nCombo可以一次请求多个文件，能够有效解决多个模块加载带来的性能问题。Yahoo提供了Combo服务，但只能提供YUI3模块，而且速度在国内并不理想。为了提供更好的体验，让用户访问速度更快，我们最终考虑搭建自己的Combo服务，并把Combo发布到CDN上。\n\n以下是一个Combo请求的例子：\n\n```\nhttp://c.meituan.net/combo/?f=mt-yui-core.v3.5.1.js;fecore/mt/js/base.js\n```\n\n为了节约时间，我们最开始采用了开源的minify，经过一些修改和配置，就可以在生产和开发环境提供Combo服务。使用一段时间后，发现minify过于复杂，以至于添加一些定制功能相当困难。我们需要的只是简单的文件合并功能，在明确需求和开发量后，着手开发自己的Combo程序。从最初的仅支持文件合并，后来陆续添加了服务器／浏览器端缓存、文件集别名、调试模式、CSS图片相对路径转URI、错误日志等特性，全部代码仅有300多行。经过两年时间以及每天几千万PV的考验，服务一直非常稳定。\n\n## 灵活健壮的组件框架\n\nYUI3之所以成为纯粹的框架，真正的原因在于提供了一套灵活、健壮的组件框架。借助这套框架，可以轻松的将业务场景进行解耦、分层，并持续的进行改进。通过不断的实践，我们越发认为这是YUI3的精髓所在。\n\n从YUI3定义的开发范式和源代码中可以看出，YUI团队非常重视AOP（Aspect Oriented Programming）和OOP（Object Oriented Programming），这一点可以在接下来的介绍中有所体会。\n\n### EventTarget、Attribute和Base\n\n在介绍组件框架之前，有必要首先了解下EventTarget。YUI3创建了一套类似DOM事件的自定义事件体系，支持冒泡传播、默认行为等功能。EventTarget提供了操作自定义事件的接口，可以让任意一个对象拥有定义、监听、触发、注销自定义事件的功能。YUI组件框架中的所有类，以及在此框架之上开发的所有组件，都继承了EventTarget。\n\nAttribute是组件框架中最底层的类，实现了数据和逻辑的完美解耦。为什么说是完美呢？存储在attribute（Attribute提供的数据存取接口）中的数据发生变化时，会触发相应的事件，为相关的逻辑处理提供了便捷的接口。从下面这个简单的例子可以感受到这一点：\n\n```javascript\n// 在name属性变化时，触发nameChange事件\nthis.on('nameChange', function (e) {\n\tconsole.log(e.newVal);\n});\n\n// 修改name属性\nthis.set('name', 'meituan'); // output 'meituan'\n```\n\n实践中发现，妥善处理属性的分类非常重要。供实例进行操作的属性适合作为attribute，例如表单验证组件FormChecker的fields属性，方便应用层进行表单项的增删改。在类方法内部使用的一些属性可以作为私有属性，例如计时器、监听器句柄。供所有类的实例使用的一些常量适合作为类的静态属性，例如一些模板、样式类。\n\nBase是组件框架的核心类。它模拟了C++、Java等语言的经典继承方式和生命周期管理，借助Attribute来实现数据与逻辑的分离，并提供扩展、插件支持，从而获得了良好的扩展性以及强大的可持续开发能力。YUI团队通过多年来对业务实践的抽象，最终演化而成一种开发范式，这，就是一切组件的基石——Base，实至名归。\n\n依照这种范式，我们开发了一系列组件，例如之前提到的FormChecker，以及延迟加载器LazyLoader、地图的封装Map等。最显著的体会是，开发思路更为清晰，代码结构更有条理，维护变得简单轻松。\n\n```javascript\n// 构造方法\nFormChecker.prototype.initializer = function () {\n\tvar form = this.get('form');\n\tthis._handle = form.on('submit', function (e) {\n\t\t// check fields\n\t});\n};\n// 析构方法\nFormChecker.prototype.destructor = function () {\n\tthis._handle.detach();\n};\n\n// 创建实例时，自动执行构造方法\nvar checker = new FormChecker({ form: Y.one('#buy-form') });\n// 销毁实例时，自动执行析构方法\nchecker.destroy();\n```\n\n### Extension和Plugin\n\nExtension（扩展）是为了解决多重继承，以一种类似组合的方式在类上添加功能的模式，它本身不能创建实例。这种设计非常像Ruby等语言中的Mixin。Plugin（插件）的作用是在对象上添加一些功能，这些功能也可以很方便的移除。\n\n它们有什么区别呢？简单来说，Extension是在类上加一些功能，所有类的实例都拥有这些功能。Plugin只是在某些类的实例中添加功能。举两个典型的例子：一些节点需要使用动画效果，这个功能适合作为Plugin。气泡提示控件需要支持多种对齐方式，所有实例都需要此功能，因此使用YUI3的WidgetPositionAlign扩展。\n\n```javascript\n// 传统的函数方式实现动画\nEffect.fadeIn(nodeTip);\n\n// 插件方式实现动画\nnodeTip.plug(NodeEffect);\nnodeTip.effect.fadeIn();\n```\n\nExtension和Plugin很好的解决了我们遇到的诸多功能重用问题。我们开发了提供全屏功能的WidgetFullScreen、自动对齐对话框的DialogAutoAlign等扩展，以及进行异步查询的AsyncSearch、提供动画效果的NodeEffect等插件。将这些偏重OOP的编程思想应用在前端开发中，比较深刻的体会是：有更多的概念清晰、定位明确的开发模式可以选择。\n\n### Widget体系\n\nWidget（控件）建立在Base之上，主要增加了UI层面的功能，例如`renderUI`、`bindUI`、`syncUI`等生命周期方法，`HTML_PARSER`等渐进增强功能，以及样式类、HTML结构和DOM事件的统一管理。Widget提供了控件开发的通用范式。\n\n由于前端资源相对紧张，我们倾向于大量使用控件，尤其在业务系统这样更注重功能的场景。主要出于两点考虑：\n\n- **减少不必要的重复劳动，提高产出**。通过将交互、业务逻辑合理抽象，一次解决一类问题，One Shot One Kill。\n- **节约前端工程师资源**。通过自动加载和初始化控件、封装简单易用的后端方法、制作Demo和使用手册等措施，降低使用门槛，后端工程师只需要知道参数的数据结构就可以轻松调用，提高了开发效率。\n\n以下是一个自动加载控件的例子\n\n```html\n// 页面初始化时，会扫描所有带有data-widget属性的节点，自动加载对应控件，并根据data-params数据进行初始化\n<a href=\"…\" data-widget=\"bubbleTip\" data-params='{ \"tip\": \"全新改版，支持随时退款\" }'>下载手机版</a>\n```\n\n目前，我们已经构建了一个包含近30个控件的Widget体系，为所有系统提供丰富、便捷、集成的解决方案。\n\n## 行进中开火\n\n在整个YUI3的实践中，我们犯过很多错误，例如全局只有一个YUI实例、Combo的CSS图片依赖等等，但这些并没有成为放弃的理由。从今天回过头来看，YUI3带给我们团队的，不只是更高的开发效率、更好的可持续开发能力，还有它本身的设计思路、源码书写、辅助工具等诸多方面潜移默化的影响。这些回报的价值，比起较高的使用门槛、犯过的一些错误，要贵重百倍。\n\n指导这一切的，是我们始终坚持的 **“行进中开火”**。在互联网这个高速发展的行业里，对于我们这种小规模的创业团队，一天不前进，就意味落后。做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒。每天都做得更好一点，日积月累，我们才会在激烈的竞争中占据越来越大的优势。\n\nYUI3并非完美，存在着学习成本高、对社区不够开放等问题。我们所做的更远非完美，但经过不断的尝试和经验的积累，已经渐渐摸索出一条明确的路线，并会坚持不懈的继续走下去。\n\n关于YUI3和我们团队更多的信息请关注 http://fe.meituan.com\n\n\n\n","source":"_posts/yui3-practice.md","raw":"---\nlayout: post\ntitle: \"YUI3在美团的实践\"\ndate: 2013-05-10 22:35\ncomments: true\nstatus: publish\ntags: [YUI, Framework, JavaScript]\n---\n\n美团网在2010年引爆了团购行业，并在2012年销售额超过55亿，实现了全面盈利。在业务规模不断增长的背后，作为研发队伍中和用户最接近的前端团队承担着非常大的压力，比如用户量急剧上升带来的产品多样化，业务运营系统的界面交互日益复杂，代码膨胀造成维护成本增加等等。面对这些挑战，我们持续改进前端技术架构，在提升用户体验和工作效率的同时，成功支撑了美团业务的快速发展，这一切都得益于构建在YUI3框架之上稳定高效的前端代码。在应用YUI3的过程中，我们团队积累了一些经验，这里总结成篇，分享给大家。\n\n## 为什么选择YUI3\n\n使用什么前端基础框架是建立前端团队最重要的技术决策之一。美团项目初期因为要加快开发进度，选择了当时团队最熟悉的YUI2（前框架时代杰出的类库），保证美团能够更快更早地上线，抢占市场先机。不久由于前端技术发展很快，YUI2的缺点逐渐凸显，例如开发方式落后、影响工作效率等等，于是我们开始考虑基础库的迁移。\n\n经过一段时间对主流前端库、框架的反复考量，我们认为YUI3是最适合我们团队使用的基础框架。\n\n首先，国内的开源框架及其社区刚开始起步，在代码质量、架构设计和理念创新上还难以跟YUI3比肩，所以基本排除在外。其次，国外像YUI3这样面向用户产品、文档丰富、扩展性良好的成熟框架屈指可数，例如ExtJS和Dojo则更适合业务复杂的传统企业级开发。最后，使用jQuery这种类库构建同YUI3一样强大的框架对创业团队来说并不可取，美团快速发展、竞争多变的业务特点决定了我们必须把主要精力放在更高一层的业务开发上，而不是去重复发明一个蹩脚的YUI。\n\nYUI3成为最终选择有以下几个直接的原因：\n\n- 非常优秀，是真正的框架，真正的重型武器，具有强劲的持续开发能力，可以应对业务的快速发展。不管是规模不断增长的用户产品，还是交互日趋复杂的业务系统（美团有超过100个业务系统作全电子化的运营支撑），YUI3都游刃有余。\n- 代码整齐规范，容易维护，适合有洁癖的工程师，同时能够显著提高团队协作时的开发效率。因为人手紧缺，后端工程师也需要参与前端开发，一致的代码风格使前后端配合轻松简单。\n- 有出色的架构设计，是很好的框架范本，通过研究学习可以帮助工程师成长，培养良好的工程思维。人是美团最重要的产品。\n\n随着团队成长，我们最后引入了YUI3，在迁移过程中，遇到了很多技术上的和工程上的挑战，但是我们一直在前进，一直在行进中开火。从结果来看，YUI3为我们团队提供了先进生产力，为快速开发、快速部署、快速迭代提供了源源不断的力量。\n\nYUI3的优秀主要表现在模块和组件框架的出色设计，下面我们着重介绍这两方面的一些实践经验。\n\n<!-- more -->\n\n## 改变一切的模块\n\n前端开发日益复杂化，代码组织成为一个显著的问题。受到后端代码普遍采用的模块机制启发，很多前端模块机制应运而生。目前比较著名的有CommonJS和AMD。但早在2008年8月13日，YUI3 Preview Release 1中就已经给出了YUI团队的解决方案，并在2009年9月29日YUI3正式版发布时定型。\n\n以下是使用YUI3进行模块化开发的简单例子\n\n```javascript\n// 定义模块\nYUI.add('greeting', function (Y) {\n\tY.sayHello = function () {\n\t\tconsole.log('Hello, world!');\n\t};\n});\n\n// 调用模块\nYUI().use('greeting', function (Y) {\n\tY.sayHello(); // output 'Hello, world!'\n});\n```\n\n模块的引入，使得更细粒度的按功能进行代码组织成为可能，也为方便的进行扩展和分层提供了基础，自底向上的彻底改变了YUI3。一套完整的模块机制，还包括解决关系依赖、自动加载的Loader和提高加载效率的Combo。\n\n面对如此彻底的改变，我们需要解决很多挑战：\n\n- 如何将原来的功能划分为模块？\n- 如何管理模块元信息？\n- 如何高效的获取模块？\n\n### 划分模块\n\n经过两年来不断的实践和总结，我们归纳了如下几条划分模块的原则：\n\n- **抽象与应用脱离**。更通用的功能放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法。\n- **职责单一**。保持每个模块的足够简单和专一，方便维护和可持续开发。\n- **粒度得当**。有了Combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现。\n- **海纳百川**。我们的模块体系应该是开放的，不符合YUI规范的第三方模块，可以借鉴整合进来，使我们的基础框架更加完善，更加性感。\n\n<center>\n  <img alt=\"美团前端架构\" src=\"/images/mt-fe-architecture.png\" />\n</center>\n\n按照模块的层次划分，美团的JS框架可以分为四个层次：\n\n1. **最底层交给强悍的YUI3**，为我们提供跨浏览器兼容的API和良好的框架设计。\n2. **第二层是我们二次开发的核心方法、组件（Component）和控件（Widget）**。现已独立为前端核心库，为美团所有系统提供前端支持。核心库的种子文件中定义了全局变量M，除了对YUI3进行封装的代码以外，还包含了对语言层面的扩展，以及一些基础工具类。核心库有一个非常重要的组成部分，就是我们功能丰富的控件集合，比如常用的自动完成、排序表格、气泡提示、对话框等基础控件。除了这些，核心库还包含了常用的基础组件、插件（Plugin）、扩展（Extension）以及单元测试代码。\n3. **第三层包含各个系统的一些通用模块**。例如www-base模块包含美团主站（www）的消息系统、用户行为追踪系统等通用功能。这一层更加接近应用。\n4. **最上面一层，应用模块**。这些模块的方法都是用来解决实际业务问题。例如www-deal用来处理美团主站所有deal相关功能的交互，finance-pay用来处理财务系统中付款相关的交互。一些零碎的应用方法我们放在对应系统的misc模块中，避免模块碎片化。\n\n这套框架仍在不断演变，以便更好的支撑业务需求。其中一个明显的方向是，在第二层和第三层之间，出现一个为了更好整合所有内部业务系统前端通用资源的中间层。\n\n### 管理模块元信息\n\n模块元信息主要包括模块名称、路径、依赖关系等内容。其中最为重要的是依赖关系，这决定了有哪些模块需要加载。为了实现自动加载，需要将所有模块的元信息提供给YUI的Loader。\n\n最初，为了更快的从YUI2迁移到YUI3，模块元信息放在PHP中进行维护。随着时间的推移，渐渐显示出很多弊端。首先，在定义模块的js文件中已经包含模块名称、依赖关系等信息，和PHP中内容重复。其次，这些元信息最终直接输出到html中，没有有效利用缓存。\n\n随后，我们使用NodeJS开发了一系列脚本，收集所有模块元信息，保存为独立js文件，并实现了自动化。为了防止出错，在Git Hooks和上线脚本中都加入了校验过程。工程师需要做的，只是修改模块定义中的元信息。\n\n最近一段时间，我们的精力主要放在两个方面：\n\n- **自动生成依赖**。随着模块粒度细化和模块数量的增长，依赖关系日益复杂，依靠人工配置经常出现过多依赖或过少依赖等问题。我们准备开发一套自动扫描模块引用API，并确定依赖关系的机制。\n- **自动打包依赖模块**。如果在代码发布时，就已根据页面模块调用计算好所有依赖模块，并进行打包，可以避免引用全部模块元信息、Loader计算依赖等过程，提高网站性能。\n\n### Combo\n\nCombo可以一次请求多个文件，能够有效解决多个模块加载带来的性能问题。Yahoo提供了Combo服务，但只能提供YUI3模块，而且速度在国内并不理想。为了提供更好的体验，让用户访问速度更快，我们最终考虑搭建自己的Combo服务，并把Combo发布到CDN上。\n\n以下是一个Combo请求的例子：\n\n```\nhttp://c.meituan.net/combo/?f=mt-yui-core.v3.5.1.js;fecore/mt/js/base.js\n```\n\n为了节约时间，我们最开始采用了开源的minify，经过一些修改和配置，就可以在生产和开发环境提供Combo服务。使用一段时间后，发现minify过于复杂，以至于添加一些定制功能相当困难。我们需要的只是简单的文件合并功能，在明确需求和开发量后，着手开发自己的Combo程序。从最初的仅支持文件合并，后来陆续添加了服务器／浏览器端缓存、文件集别名、调试模式、CSS图片相对路径转URI、错误日志等特性，全部代码仅有300多行。经过两年时间以及每天几千万PV的考验，服务一直非常稳定。\n\n## 灵活健壮的组件框架\n\nYUI3之所以成为纯粹的框架，真正的原因在于提供了一套灵活、健壮的组件框架。借助这套框架，可以轻松的将业务场景进行解耦、分层，并持续的进行改进。通过不断的实践，我们越发认为这是YUI3的精髓所在。\n\n从YUI3定义的开发范式和源代码中可以看出，YUI团队非常重视AOP（Aspect Oriented Programming）和OOP（Object Oriented Programming），这一点可以在接下来的介绍中有所体会。\n\n### EventTarget、Attribute和Base\n\n在介绍组件框架之前，有必要首先了解下EventTarget。YUI3创建了一套类似DOM事件的自定义事件体系，支持冒泡传播、默认行为等功能。EventTarget提供了操作自定义事件的接口，可以让任意一个对象拥有定义、监听、触发、注销自定义事件的功能。YUI组件框架中的所有类，以及在此框架之上开发的所有组件，都继承了EventTarget。\n\nAttribute是组件框架中最底层的类，实现了数据和逻辑的完美解耦。为什么说是完美呢？存储在attribute（Attribute提供的数据存取接口）中的数据发生变化时，会触发相应的事件，为相关的逻辑处理提供了便捷的接口。从下面这个简单的例子可以感受到这一点：\n\n```javascript\n// 在name属性变化时，触发nameChange事件\nthis.on('nameChange', function (e) {\n\tconsole.log(e.newVal);\n});\n\n// 修改name属性\nthis.set('name', 'meituan'); // output 'meituan'\n```\n\n实践中发现，妥善处理属性的分类非常重要。供实例进行操作的属性适合作为attribute，例如表单验证组件FormChecker的fields属性，方便应用层进行表单项的增删改。在类方法内部使用的一些属性可以作为私有属性，例如计时器、监听器句柄。供所有类的实例使用的一些常量适合作为类的静态属性，例如一些模板、样式类。\n\nBase是组件框架的核心类。它模拟了C++、Java等语言的经典继承方式和生命周期管理，借助Attribute来实现数据与逻辑的分离，并提供扩展、插件支持，从而获得了良好的扩展性以及强大的可持续开发能力。YUI团队通过多年来对业务实践的抽象，最终演化而成一种开发范式，这，就是一切组件的基石——Base，实至名归。\n\n依照这种范式，我们开发了一系列组件，例如之前提到的FormChecker，以及延迟加载器LazyLoader、地图的封装Map等。最显著的体会是，开发思路更为清晰，代码结构更有条理，维护变得简单轻松。\n\n```javascript\n// 构造方法\nFormChecker.prototype.initializer = function () {\n\tvar form = this.get('form');\n\tthis._handle = form.on('submit', function (e) {\n\t\t// check fields\n\t});\n};\n// 析构方法\nFormChecker.prototype.destructor = function () {\n\tthis._handle.detach();\n};\n\n// 创建实例时，自动执行构造方法\nvar checker = new FormChecker({ form: Y.one('#buy-form') });\n// 销毁实例时，自动执行析构方法\nchecker.destroy();\n```\n\n### Extension和Plugin\n\nExtension（扩展）是为了解决多重继承，以一种类似组合的方式在类上添加功能的模式，它本身不能创建实例。这种设计非常像Ruby等语言中的Mixin。Plugin（插件）的作用是在对象上添加一些功能，这些功能也可以很方便的移除。\n\n它们有什么区别呢？简单来说，Extension是在类上加一些功能，所有类的实例都拥有这些功能。Plugin只是在某些类的实例中添加功能。举两个典型的例子：一些节点需要使用动画效果，这个功能适合作为Plugin。气泡提示控件需要支持多种对齐方式，所有实例都需要此功能，因此使用YUI3的WidgetPositionAlign扩展。\n\n```javascript\n// 传统的函数方式实现动画\nEffect.fadeIn(nodeTip);\n\n// 插件方式实现动画\nnodeTip.plug(NodeEffect);\nnodeTip.effect.fadeIn();\n```\n\nExtension和Plugin很好的解决了我们遇到的诸多功能重用问题。我们开发了提供全屏功能的WidgetFullScreen、自动对齐对话框的DialogAutoAlign等扩展，以及进行异步查询的AsyncSearch、提供动画效果的NodeEffect等插件。将这些偏重OOP的编程思想应用在前端开发中，比较深刻的体会是：有更多的概念清晰、定位明确的开发模式可以选择。\n\n### Widget体系\n\nWidget（控件）建立在Base之上，主要增加了UI层面的功能，例如`renderUI`、`bindUI`、`syncUI`等生命周期方法，`HTML_PARSER`等渐进增强功能，以及样式类、HTML结构和DOM事件的统一管理。Widget提供了控件开发的通用范式。\n\n由于前端资源相对紧张，我们倾向于大量使用控件，尤其在业务系统这样更注重功能的场景。主要出于两点考虑：\n\n- **减少不必要的重复劳动，提高产出**。通过将交互、业务逻辑合理抽象，一次解决一类问题，One Shot One Kill。\n- **节约前端工程师资源**。通过自动加载和初始化控件、封装简单易用的后端方法、制作Demo和使用手册等措施，降低使用门槛，后端工程师只需要知道参数的数据结构就可以轻松调用，提高了开发效率。\n\n以下是一个自动加载控件的例子\n\n```html\n// 页面初始化时，会扫描所有带有data-widget属性的节点，自动加载对应控件，并根据data-params数据进行初始化\n<a href=\"…\" data-widget=\"bubbleTip\" data-params='{ \"tip\": \"全新改版，支持随时退款\" }'>下载手机版</a>\n```\n\n目前，我们已经构建了一个包含近30个控件的Widget体系，为所有系统提供丰富、便捷、集成的解决方案。\n\n## 行进中开火\n\n在整个YUI3的实践中，我们犯过很多错误，例如全局只有一个YUI实例、Combo的CSS图片依赖等等，但这些并没有成为放弃的理由。从今天回过头来看，YUI3带给我们团队的，不只是更高的开发效率、更好的可持续开发能力，还有它本身的设计思路、源码书写、辅助工具等诸多方面潜移默化的影响。这些回报的价值，比起较高的使用门槛、犯过的一些错误，要贵重百倍。\n\n指导这一切的，是我们始终坚持的 **“行进中开火”**。在互联网这个高速发展的行业里，对于我们这种小规模的创业团队，一天不前进，就意味落后。做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒。每天都做得更好一点，日积月累，我们才会在激烈的竞争中占据越来越大的优势。\n\nYUI3并非完美，存在着学习成本高、对社区不够开放等问题。我们所做的更远非完美，但经过不断的尝试和经验的积累，已经渐渐摸索出一条明确的路线，并会坚持不懈的继续走下去。\n\n关于YUI3和我们团队更多的信息请关注 http://fe.meituan.com\n\n\n\n","slug":"yui3-practice","published":1,"updated":"2021-10-05T09:29:40.997Z","photos":[],"link":"","_id":"cl1klguqn005q8e8523wveq4y","content":"<p>美团网在2010年引爆了团购行业，并在2012年销售额超过55亿，实现了全面盈利。在业务规模不断增长的背后，作为研发队伍中和用户最接近的前端团队承担着非常大的压力，比如用户量急剧上升带来的产品多样化，业务运营系统的界面交互日益复杂，代码膨胀造成维护成本增加等等。面对这些挑战，我们持续改进前端技术架构，在提升用户体验和工作效率的同时，成功支撑了美团业务的快速发展，这一切都得益于构建在YUI3框架之上稳定高效的前端代码。在应用YUI3的过程中，我们团队积累了一些经验，这里总结成篇，分享给大家。</p>\n<h2 id=\"为什么选择YUI3\"><a href=\"#为什么选择YUI3\" class=\"headerlink\" title=\"为什么选择YUI3\"></a>为什么选择YUI3</h2><p>使用什么前端基础框架是建立前端团队最重要的技术决策之一。美团项目初期因为要加快开发进度，选择了当时团队最熟悉的YUI2（前框架时代杰出的类库），保证美团能够更快更早地上线，抢占市场先机。不久由于前端技术发展很快，YUI2的缺点逐渐凸显，例如开发方式落后、影响工作效率等等，于是我们开始考虑基础库的迁移。</p>\n<p>经过一段时间对主流前端库、框架的反复考量，我们认为YUI3是最适合我们团队使用的基础框架。</p>\n<p>首先，国内的开源框架及其社区刚开始起步，在代码质量、架构设计和理念创新上还难以跟YUI3比肩，所以基本排除在外。其次，国外像YUI3这样面向用户产品、文档丰富、扩展性良好的成熟框架屈指可数，例如ExtJS和Dojo则更适合业务复杂的传统企业级开发。最后，使用jQuery这种类库构建同YUI3一样强大的框架对创业团队来说并不可取，美团快速发展、竞争多变的业务特点决定了我们必须把主要精力放在更高一层的业务开发上，而不是去重复发明一个蹩脚的YUI。</p>\n<p>YUI3成为最终选择有以下几个直接的原因：</p>\n<ul>\n<li>非常优秀，是真正的框架，真正的重型武器，具有强劲的持续开发能力，可以应对业务的快速发展。不管是规模不断增长的用户产品，还是交互日趋复杂的业务系统（美团有超过100个业务系统作全电子化的运营支撑），YUI3都游刃有余。</li>\n<li>代码整齐规范，容易维护，适合有洁癖的工程师，同时能够显著提高团队协作时的开发效率。因为人手紧缺，后端工程师也需要参与前端开发，一致的代码风格使前后端配合轻松简单。</li>\n<li>有出色的架构设计，是很好的框架范本，通过研究学习可以帮助工程师成长，培养良好的工程思维。人是美团最重要的产品。</li>\n</ul>\n<p>随着团队成长，我们最后引入了YUI3，在迁移过程中，遇到了很多技术上的和工程上的挑战，但是我们一直在前进，一直在行进中开火。从结果来看，YUI3为我们团队提供了先进生产力，为快速开发、快速部署、快速迭代提供了源源不断的力量。</p>\n<p>YUI3的优秀主要表现在模块和组件框架的出色设计，下面我们着重介绍这两方面的一些实践经验。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"改变一切的模块\"><a href=\"#改变一切的模块\" class=\"headerlink\" title=\"改变一切的模块\"></a>改变一切的模块</h2><p>前端开发日益复杂化，代码组织成为一个显著的问题。受到后端代码普遍采用的模块机制启发，很多前端模块机制应运而生。目前比较著名的有CommonJS和AMD。但早在2008年8月13日，YUI3 Preview Release 1中就已经给出了YUI团队的解决方案，并在2009年9月29日YUI3正式版发布时定型。</p>\n<p>以下是使用YUI3进行模块化开发的简单例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">&#x27;greeting&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">\tY.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用模块</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;greeting&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">\tY.sayHello(); <span class=\"comment\">// output &#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>模块的引入，使得更细粒度的按功能进行代码组织成为可能，也为方便的进行扩展和分层提供了基础，自底向上的彻底改变了YUI3。一套完整的模块机制，还包括解决关系依赖、自动加载的Loader和提高加载效率的Combo。</p>\n<p>面对如此彻底的改变，我们需要解决很多挑战：</p>\n<ul>\n<li>如何将原来的功能划分为模块？</li>\n<li>如何管理模块元信息？</li>\n<li>如何高效的获取模块？</li>\n</ul>\n<h3 id=\"划分模块\"><a href=\"#划分模块\" class=\"headerlink\" title=\"划分模块\"></a>划分模块</h3><p>经过两年来不断的实践和总结，我们归纳了如下几条划分模块的原则：</p>\n<ul>\n<li><strong>抽象与应用脱离</strong>。更通用的功能放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法。</li>\n<li><strong>职责单一</strong>。保持每个模块的足够简单和专一，方便维护和可持续开发。</li>\n<li><strong>粒度得当</strong>。有了Combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现。</li>\n<li><strong>海纳百川</strong>。我们的模块体系应该是开放的，不符合YUI规范的第三方模块，可以借鉴整合进来，使我们的基础框架更加完善，更加性感。</li>\n</ul>\n<center>\n  <img alt=\"美团前端架构\" src=\"/images/mt-fe-architecture.png\" />\n</center>\n\n<p>按照模块的层次划分，美团的JS框架可以分为四个层次：</p>\n<ol>\n<li><strong>最底层交给强悍的YUI3</strong>，为我们提供跨浏览器兼容的API和良好的框架设计。</li>\n<li><strong>第二层是我们二次开发的核心方法、组件（Component）和控件（Widget）</strong>。现已独立为前端核心库，为美团所有系统提供前端支持。核心库的种子文件中定义了全局变量M，除了对YUI3进行封装的代码以外，还包含了对语言层面的扩展，以及一些基础工具类。核心库有一个非常重要的组成部分，就是我们功能丰富的控件集合，比如常用的自动完成、排序表格、气泡提示、对话框等基础控件。除了这些，核心库还包含了常用的基础组件、插件（Plugin）、扩展（Extension）以及单元测试代码。</li>\n<li><strong>第三层包含各个系统的一些通用模块</strong>。例如www-base模块包含美团主站（www）的消息系统、用户行为追踪系统等通用功能。这一层更加接近应用。</li>\n<li><strong>最上面一层，应用模块</strong>。这些模块的方法都是用来解决实际业务问题。例如www-deal用来处理美团主站所有deal相关功能的交互，finance-pay用来处理财务系统中付款相关的交互。一些零碎的应用方法我们放在对应系统的misc模块中，避免模块碎片化。</li>\n</ol>\n<p>这套框架仍在不断演变，以便更好的支撑业务需求。其中一个明显的方向是，在第二层和第三层之间，出现一个为了更好整合所有内部业务系统前端通用资源的中间层。</p>\n<h3 id=\"管理模块元信息\"><a href=\"#管理模块元信息\" class=\"headerlink\" title=\"管理模块元信息\"></a>管理模块元信息</h3><p>模块元信息主要包括模块名称、路径、依赖关系等内容。其中最为重要的是依赖关系，这决定了有哪些模块需要加载。为了实现自动加载，需要将所有模块的元信息提供给YUI的Loader。</p>\n<p>最初，为了更快的从YUI2迁移到YUI3，模块元信息放在PHP中进行维护。随着时间的推移，渐渐显示出很多弊端。首先，在定义模块的js文件中已经包含模块名称、依赖关系等信息，和PHP中内容重复。其次，这些元信息最终直接输出到html中，没有有效利用缓存。</p>\n<p>随后，我们使用NodeJS开发了一系列脚本，收集所有模块元信息，保存为独立js文件，并实现了自动化。为了防止出错，在Git Hooks和上线脚本中都加入了校验过程。工程师需要做的，只是修改模块定义中的元信息。</p>\n<p>最近一段时间，我们的精力主要放在两个方面：</p>\n<ul>\n<li><strong>自动生成依赖</strong>。随着模块粒度细化和模块数量的增长，依赖关系日益复杂，依靠人工配置经常出现过多依赖或过少依赖等问题。我们准备开发一套自动扫描模块引用API，并确定依赖关系的机制。</li>\n<li><strong>自动打包依赖模块</strong>。如果在代码发布时，就已根据页面模块调用计算好所有依赖模块，并进行打包，可以避免引用全部模块元信息、Loader计算依赖等过程，提高网站性能。</li>\n</ul>\n<h3 id=\"Combo\"><a href=\"#Combo\" class=\"headerlink\" title=\"Combo\"></a>Combo</h3><p>Combo可以一次请求多个文件，能够有效解决多个模块加载带来的性能问题。Yahoo提供了Combo服务，但只能提供YUI3模块，而且速度在国内并不理想。为了提供更好的体验，让用户访问速度更快，我们最终考虑搭建自己的Combo服务，并把Combo发布到CDN上。</p>\n<p>以下是一个Combo请求的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://c.meituan.net/combo/?f=mt-yui-core.v3.5.1.js;fecore/mt/js/base.js</span><br></pre></td></tr></table></figure>\n\n<p>为了节约时间，我们最开始采用了开源的minify，经过一些修改和配置，就可以在生产和开发环境提供Combo服务。使用一段时间后，发现minify过于复杂，以至于添加一些定制功能相当困难。我们需要的只是简单的文件合并功能，在明确需求和开发量后，着手开发自己的Combo程序。从最初的仅支持文件合并，后来陆续添加了服务器／浏览器端缓存、文件集别名、调试模式、CSS图片相对路径转URI、错误日志等特性，全部代码仅有300多行。经过两年时间以及每天几千万PV的考验，服务一直非常稳定。</p>\n<h2 id=\"灵活健壮的组件框架\"><a href=\"#灵活健壮的组件框架\" class=\"headerlink\" title=\"灵活健壮的组件框架\"></a>灵活健壮的组件框架</h2><p>YUI3之所以成为纯粹的框架，真正的原因在于提供了一套灵活、健壮的组件框架。借助这套框架，可以轻松的将业务场景进行解耦、分层，并持续的进行改进。通过不断的实践，我们越发认为这是YUI3的精髓所在。</p>\n<p>从YUI3定义的开发范式和源代码中可以看出，YUI团队非常重视AOP（Aspect Oriented Programming）和OOP（Object Oriented Programming），这一点可以在接下来的介绍中有所体会。</p>\n<h3 id=\"EventTarget、Attribute和Base\"><a href=\"#EventTarget、Attribute和Base\" class=\"headerlink\" title=\"EventTarget、Attribute和Base\"></a>EventTarget、Attribute和Base</h3><p>在介绍组件框架之前，有必要首先了解下EventTarget。YUI3创建了一套类似DOM事件的自定义事件体系，支持冒泡传播、默认行为等功能。EventTarget提供了操作自定义事件的接口，可以让任意一个对象拥有定义、监听、触发、注销自定义事件的功能。YUI组件框架中的所有类，以及在此框架之上开发的所有组件，都继承了EventTarget。</p>\n<p>Attribute是组件框架中最底层的类，实现了数据和逻辑的完美解耦。为什么说是完美呢？存储在attribute（Attribute提供的数据存取接口）中的数据发生变化时，会触发相应的事件，为相关的逻辑处理提供了便捷的接口。从下面这个简单的例子可以感受到这一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在name属性变化时，触发nameChange事件</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.on(<span class=\"string\">&#x27;nameChange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(e.newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改name属性</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.set(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;meituan&#x27;</span>); <span class=\"comment\">// output &#x27;meituan&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>实践中发现，妥善处理属性的分类非常重要。供实例进行操作的属性适合作为attribute，例如表单验证组件FormChecker的fields属性，方便应用层进行表单项的增删改。在类方法内部使用的一些属性可以作为私有属性，例如计时器、监听器句柄。供所有类的实例使用的一些常量适合作为类的静态属性，例如一些模板、样式类。</p>\n<p>Base是组件框架的核心类。它模拟了C++、Java等语言的经典继承方式和生命周期管理，借助Attribute来实现数据与逻辑的分离，并提供扩展、插件支持，从而获得了良好的扩展性以及强大的可持续开发能力。YUI团队通过多年来对业务实践的抽象，最终演化而成一种开发范式，这，就是一切组件的基石——Base，实至名归。</p>\n<p>依照这种范式，我们开发了一系列组件，例如之前提到的FormChecker，以及延迟加载器LazyLoader、地图的封装Map等。最显著的体会是，开发思路更为清晰，代码结构更有条理，维护变得简单轻松。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">FormChecker.prototype.initializer = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> form = <span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;form&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>._handle = form.on(<span class=\"string\">&#x27;submit&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// check fields</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 析构方法</span></span><br><span class=\"line\">FormChecker.prototype.destructor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>._handle.detach();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建实例时，自动执行构造方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> checker = <span class=\"keyword\">new</span> FormChecker(&#123; <span class=\"attr\">form</span>: Y.one(<span class=\"string\">&#x27;#buy-form&#x27;</span>) &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 销毁实例时，自动执行析构方法</span></span><br><span class=\"line\">checker.destroy();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Extension和Plugin\"><a href=\"#Extension和Plugin\" class=\"headerlink\" title=\"Extension和Plugin\"></a>Extension和Plugin</h3><p>Extension（扩展）是为了解决多重继承，以一种类似组合的方式在类上添加功能的模式，它本身不能创建实例。这种设计非常像Ruby等语言中的Mixin。Plugin（插件）的作用是在对象上添加一些功能，这些功能也可以很方便的移除。</p>\n<p>它们有什么区别呢？简单来说，Extension是在类上加一些功能，所有类的实例都拥有这些功能。Plugin只是在某些类的实例中添加功能。举两个典型的例子：一些节点需要使用动画效果，这个功能适合作为Plugin。气泡提示控件需要支持多种对齐方式，所有实例都需要此功能，因此使用YUI3的WidgetPositionAlign扩展。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统的函数方式实现动画</span></span><br><span class=\"line\">Effect.fadeIn(nodeTip);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件方式实现动画</span></span><br><span class=\"line\">nodeTip.plug(NodeEffect);</span><br><span class=\"line\">nodeTip.effect.fadeIn();</span><br></pre></td></tr></table></figure>\n\n<p>Extension和Plugin很好的解决了我们遇到的诸多功能重用问题。我们开发了提供全屏功能的WidgetFullScreen、自动对齐对话框的DialogAutoAlign等扩展，以及进行异步查询的AsyncSearch、提供动画效果的NodeEffect等插件。将这些偏重OOP的编程思想应用在前端开发中，比较深刻的体会是：有更多的概念清晰、定位明确的开发模式可以选择。</p>\n<h3 id=\"Widget体系\"><a href=\"#Widget体系\" class=\"headerlink\" title=\"Widget体系\"></a>Widget体系</h3><p>Widget（控件）建立在Base之上，主要增加了UI层面的功能，例如<code>renderUI</code>、<code>bindUI</code>、<code>syncUI</code>等生命周期方法，<code>HTML_PARSER</code>等渐进增强功能，以及样式类、HTML结构和DOM事件的统一管理。Widget提供了控件开发的通用范式。</p>\n<p>由于前端资源相对紧张，我们倾向于大量使用控件，尤其在业务系统这样更注重功能的场景。主要出于两点考虑：</p>\n<ul>\n<li><strong>减少不必要的重复劳动，提高产出</strong>。通过将交互、业务逻辑合理抽象，一次解决一类问题，One Shot One Kill。</li>\n<li><strong>节约前端工程师资源</strong>。通过自动加载和初始化控件、封装简单易用的后端方法、制作Demo和使用手册等措施，降低使用门槛，后端工程师只需要知道参数的数据结构就可以轻松调用，提高了开发效率。</li>\n</ul>\n<p>以下是一个自动加载控件的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 页面初始化时，会扫描所有带有data-widget属性的节点，自动加载对应控件，并根据data-params数据进行初始化</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;…&quot;</span> <span class=\"attr\">data-widget</span>=<span class=\"string\">&quot;bubbleTip&quot;</span> <span class=\"attr\">data-params</span>=<span class=\"string\">&#x27;&#123; &quot;tip&quot;: &quot;全新改版，支持随时退款&quot; &#125;&#x27;</span>&gt;</span>下载手机版<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>目前，我们已经构建了一个包含近30个控件的Widget体系，为所有系统提供丰富、便捷、集成的解决方案。</p>\n<h2 id=\"行进中开火\"><a href=\"#行进中开火\" class=\"headerlink\" title=\"行进中开火\"></a>行进中开火</h2><p>在整个YUI3的实践中，我们犯过很多错误，例如全局只有一个YUI实例、Combo的CSS图片依赖等等，但这些并没有成为放弃的理由。从今天回过头来看，YUI3带给我们团队的，不只是更高的开发效率、更好的可持续开发能力，还有它本身的设计思路、源码书写、辅助工具等诸多方面潜移默化的影响。这些回报的价值，比起较高的使用门槛、犯过的一些错误，要贵重百倍。</p>\n<p>指导这一切的，是我们始终坚持的 <strong>“行进中开火”</strong>。在互联网这个高速发展的行业里，对于我们这种小规模的创业团队，一天不前进，就意味落后。做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒。每天都做得更好一点，日积月累，我们才会在激烈的竞争中占据越来越大的优势。</p>\n<p>YUI3并非完美，存在着学习成本高、对社区不够开放等问题。我们所做的更远非完美，但经过不断的尝试和经验的积累，已经渐渐摸索出一条明确的路线，并会坚持不懈的继续走下去。</p>\n<p>关于YUI3和我们团队更多的信息请关注 <a href=\"http://fe.meituan.com/\">http://fe.meituan.com</a></p>\n","site":{"data":{}},"excerpt":"<p>美团网在2010年引爆了团购行业，并在2012年销售额超过55亿，实现了全面盈利。在业务规模不断增长的背后，作为研发队伍中和用户最接近的前端团队承担着非常大的压力，比如用户量急剧上升带来的产品多样化，业务运营系统的界面交互日益复杂，代码膨胀造成维护成本增加等等。面对这些挑战，我们持续改进前端技术架构，在提升用户体验和工作效率的同时，成功支撑了美团业务的快速发展，这一切都得益于构建在YUI3框架之上稳定高效的前端代码。在应用YUI3的过程中，我们团队积累了一些经验，这里总结成篇，分享给大家。</p>\n<h2 id=\"为什么选择YUI3\"><a href=\"#为什么选择YUI3\" class=\"headerlink\" title=\"为什么选择YUI3\"></a>为什么选择YUI3</h2><p>使用什么前端基础框架是建立前端团队最重要的技术决策之一。美团项目初期因为要加快开发进度，选择了当时团队最熟悉的YUI2（前框架时代杰出的类库），保证美团能够更快更早地上线，抢占市场先机。不久由于前端技术发展很快，YUI2的缺点逐渐凸显，例如开发方式落后、影响工作效率等等，于是我们开始考虑基础库的迁移。</p>\n<p>经过一段时间对主流前端库、框架的反复考量，我们认为YUI3是最适合我们团队使用的基础框架。</p>\n<p>首先，国内的开源框架及其社区刚开始起步，在代码质量、架构设计和理念创新上还难以跟YUI3比肩，所以基本排除在外。其次，国外像YUI3这样面向用户产品、文档丰富、扩展性良好的成熟框架屈指可数，例如ExtJS和Dojo则更适合业务复杂的传统企业级开发。最后，使用jQuery这种类库构建同YUI3一样强大的框架对创业团队来说并不可取，美团快速发展、竞争多变的业务特点决定了我们必须把主要精力放在更高一层的业务开发上，而不是去重复发明一个蹩脚的YUI。</p>\n<p>YUI3成为最终选择有以下几个直接的原因：</p>\n<ul>\n<li>非常优秀，是真正的框架，真正的重型武器，具有强劲的持续开发能力，可以应对业务的快速发展。不管是规模不断增长的用户产品，还是交互日趋复杂的业务系统（美团有超过100个业务系统作全电子化的运营支撑），YUI3都游刃有余。</li>\n<li>代码整齐规范，容易维护，适合有洁癖的工程师，同时能够显著提高团队协作时的开发效率。因为人手紧缺，后端工程师也需要参与前端开发，一致的代码风格使前后端配合轻松简单。</li>\n<li>有出色的架构设计，是很好的框架范本，通过研究学习可以帮助工程师成长，培养良好的工程思维。人是美团最重要的产品。</li>\n</ul>\n<p>随着团队成长，我们最后引入了YUI3，在迁移过程中，遇到了很多技术上的和工程上的挑战，但是我们一直在前进，一直在行进中开火。从结果来看，YUI3为我们团队提供了先进生产力，为快速开发、快速部署、快速迭代提供了源源不断的力量。</p>\n<p>YUI3的优秀主要表现在模块和组件框架的出色设计，下面我们着重介绍这两方面的一些实践经验。</p>","more":"<h2 id=\"改变一切的模块\"><a href=\"#改变一切的模块\" class=\"headerlink\" title=\"改变一切的模块\"></a>改变一切的模块</h2><p>前端开发日益复杂化，代码组织成为一个显著的问题。受到后端代码普遍采用的模块机制启发，很多前端模块机制应运而生。目前比较著名的有CommonJS和AMD。但早在2008年8月13日，YUI3 Preview Release 1中就已经给出了YUI团队的解决方案，并在2009年9月29日YUI3正式版发布时定型。</p>\n<p>以下是使用YUI3进行模块化开发的简单例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义模块</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">&#x27;greeting&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">\tY.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用模块</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">&#x27;greeting&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">\tY.sayHello(); <span class=\"comment\">// output &#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>模块的引入，使得更细粒度的按功能进行代码组织成为可能，也为方便的进行扩展和分层提供了基础，自底向上的彻底改变了YUI3。一套完整的模块机制，还包括解决关系依赖、自动加载的Loader和提高加载效率的Combo。</p>\n<p>面对如此彻底的改变，我们需要解决很多挑战：</p>\n<ul>\n<li>如何将原来的功能划分为模块？</li>\n<li>如何管理模块元信息？</li>\n<li>如何高效的获取模块？</li>\n</ul>\n<h3 id=\"划分模块\"><a href=\"#划分模块\" class=\"headerlink\" title=\"划分模块\"></a>划分模块</h3><p>经过两年来不断的实践和总结，我们归纳了如下几条划分模块的原则：</p>\n<ul>\n<li><strong>抽象与应用脱离</strong>。更通用的功能放在更低的层级，应用层完全面向实际问题，在解决的过程中调用抽象出来的方法。</li>\n<li><strong>职责单一</strong>。保持每个模块的足够简单和专一，方便维护和可持续开发。</li>\n<li><strong>粒度得当</strong>。有了Combo，我们可以不必担心粒度太小，文件过多导致的速度问题。但是，从可维护的角度来考虑，粒度应该适当而不宜过小，避免海底捞针的情形出现。</li>\n<li><strong>海纳百川</strong>。我们的模块体系应该是开放的，不符合YUI规范的第三方模块，可以借鉴整合进来，使我们的基础框架更加完善，更加性感。</li>\n</ul>\n<center>\n  <img alt=\"美团前端架构\" src=\"/images/mt-fe-architecture.png\" />\n</center>\n\n<p>按照模块的层次划分，美团的JS框架可以分为四个层次：</p>\n<ol>\n<li><strong>最底层交给强悍的YUI3</strong>，为我们提供跨浏览器兼容的API和良好的框架设计。</li>\n<li><strong>第二层是我们二次开发的核心方法、组件（Component）和控件（Widget）</strong>。现已独立为前端核心库，为美团所有系统提供前端支持。核心库的种子文件中定义了全局变量M，除了对YUI3进行封装的代码以外，还包含了对语言层面的扩展，以及一些基础工具类。核心库有一个非常重要的组成部分，就是我们功能丰富的控件集合，比如常用的自动完成、排序表格、气泡提示、对话框等基础控件。除了这些，核心库还包含了常用的基础组件、插件（Plugin）、扩展（Extension）以及单元测试代码。</li>\n<li><strong>第三层包含各个系统的一些通用模块</strong>。例如www-base模块包含美团主站（www）的消息系统、用户行为追踪系统等通用功能。这一层更加接近应用。</li>\n<li><strong>最上面一层，应用模块</strong>。这些模块的方法都是用来解决实际业务问题。例如www-deal用来处理美团主站所有deal相关功能的交互，finance-pay用来处理财务系统中付款相关的交互。一些零碎的应用方法我们放在对应系统的misc模块中，避免模块碎片化。</li>\n</ol>\n<p>这套框架仍在不断演变，以便更好的支撑业务需求。其中一个明显的方向是，在第二层和第三层之间，出现一个为了更好整合所有内部业务系统前端通用资源的中间层。</p>\n<h3 id=\"管理模块元信息\"><a href=\"#管理模块元信息\" class=\"headerlink\" title=\"管理模块元信息\"></a>管理模块元信息</h3><p>模块元信息主要包括模块名称、路径、依赖关系等内容。其中最为重要的是依赖关系，这决定了有哪些模块需要加载。为了实现自动加载，需要将所有模块的元信息提供给YUI的Loader。</p>\n<p>最初，为了更快的从YUI2迁移到YUI3，模块元信息放在PHP中进行维护。随着时间的推移，渐渐显示出很多弊端。首先，在定义模块的js文件中已经包含模块名称、依赖关系等信息，和PHP中内容重复。其次，这些元信息最终直接输出到html中，没有有效利用缓存。</p>\n<p>随后，我们使用NodeJS开发了一系列脚本，收集所有模块元信息，保存为独立js文件，并实现了自动化。为了防止出错，在Git Hooks和上线脚本中都加入了校验过程。工程师需要做的，只是修改模块定义中的元信息。</p>\n<p>最近一段时间，我们的精力主要放在两个方面：</p>\n<ul>\n<li><strong>自动生成依赖</strong>。随着模块粒度细化和模块数量的增长，依赖关系日益复杂，依靠人工配置经常出现过多依赖或过少依赖等问题。我们准备开发一套自动扫描模块引用API，并确定依赖关系的机制。</li>\n<li><strong>自动打包依赖模块</strong>。如果在代码发布时，就已根据页面模块调用计算好所有依赖模块，并进行打包，可以避免引用全部模块元信息、Loader计算依赖等过程，提高网站性能。</li>\n</ul>\n<h3 id=\"Combo\"><a href=\"#Combo\" class=\"headerlink\" title=\"Combo\"></a>Combo</h3><p>Combo可以一次请求多个文件，能够有效解决多个模块加载带来的性能问题。Yahoo提供了Combo服务，但只能提供YUI3模块，而且速度在国内并不理想。为了提供更好的体验，让用户访问速度更快，我们最终考虑搭建自己的Combo服务，并把Combo发布到CDN上。</p>\n<p>以下是一个Combo请求的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://c.meituan.net/combo/?f=mt-yui-core.v3.5.1.js;fecore/mt/js/base.js</span><br></pre></td></tr></table></figure>\n\n<p>为了节约时间，我们最开始采用了开源的minify，经过一些修改和配置，就可以在生产和开发环境提供Combo服务。使用一段时间后，发现minify过于复杂，以至于添加一些定制功能相当困难。我们需要的只是简单的文件合并功能，在明确需求和开发量后，着手开发自己的Combo程序。从最初的仅支持文件合并，后来陆续添加了服务器／浏览器端缓存、文件集别名、调试模式、CSS图片相对路径转URI、错误日志等特性，全部代码仅有300多行。经过两年时间以及每天几千万PV的考验，服务一直非常稳定。</p>\n<h2 id=\"灵活健壮的组件框架\"><a href=\"#灵活健壮的组件框架\" class=\"headerlink\" title=\"灵活健壮的组件框架\"></a>灵活健壮的组件框架</h2><p>YUI3之所以成为纯粹的框架，真正的原因在于提供了一套灵活、健壮的组件框架。借助这套框架，可以轻松的将业务场景进行解耦、分层，并持续的进行改进。通过不断的实践，我们越发认为这是YUI3的精髓所在。</p>\n<p>从YUI3定义的开发范式和源代码中可以看出，YUI团队非常重视AOP（Aspect Oriented Programming）和OOP（Object Oriented Programming），这一点可以在接下来的介绍中有所体会。</p>\n<h3 id=\"EventTarget、Attribute和Base\"><a href=\"#EventTarget、Attribute和Base\" class=\"headerlink\" title=\"EventTarget、Attribute和Base\"></a>EventTarget、Attribute和Base</h3><p>在介绍组件框架之前，有必要首先了解下EventTarget。YUI3创建了一套类似DOM事件的自定义事件体系，支持冒泡传播、默认行为等功能。EventTarget提供了操作自定义事件的接口，可以让任意一个对象拥有定义、监听、触发、注销自定义事件的功能。YUI组件框架中的所有类，以及在此框架之上开发的所有组件，都继承了EventTarget。</p>\n<p>Attribute是组件框架中最底层的类，实现了数据和逻辑的完美解耦。为什么说是完美呢？存储在attribute（Attribute提供的数据存取接口）中的数据发生变化时，会触发相应的事件，为相关的逻辑处理提供了便捷的接口。从下面这个简单的例子可以感受到这一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在name属性变化时，触发nameChange事件</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.on(<span class=\"string\">&#x27;nameChange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(e.newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改name属性</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.set(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;meituan&#x27;</span>); <span class=\"comment\">// output &#x27;meituan&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>实践中发现，妥善处理属性的分类非常重要。供实例进行操作的属性适合作为attribute，例如表单验证组件FormChecker的fields属性，方便应用层进行表单项的增删改。在类方法内部使用的一些属性可以作为私有属性，例如计时器、监听器句柄。供所有类的实例使用的一些常量适合作为类的静态属性，例如一些模板、样式类。</p>\n<p>Base是组件框架的核心类。它模拟了C++、Java等语言的经典继承方式和生命周期管理，借助Attribute来实现数据与逻辑的分离，并提供扩展、插件支持，从而获得了良好的扩展性以及强大的可持续开发能力。YUI团队通过多年来对业务实践的抽象，最终演化而成一种开发范式，这，就是一切组件的基石——Base，实至名归。</p>\n<p>依照这种范式，我们开发了一系列组件，例如之前提到的FormChecker，以及延迟加载器LazyLoader、地图的封装Map等。最显著的体会是，开发思路更为清晰，代码结构更有条理，维护变得简单轻松。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">FormChecker.prototype.initializer = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> form = <span class=\"built_in\">this</span>.get(<span class=\"string\">&#x27;form&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>._handle = form.on(<span class=\"string\">&#x27;submit&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// check fields</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 析构方法</span></span><br><span class=\"line\">FormChecker.prototype.destructor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>._handle.detach();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建实例时，自动执行构造方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> checker = <span class=\"keyword\">new</span> FormChecker(&#123; <span class=\"attr\">form</span>: Y.one(<span class=\"string\">&#x27;#buy-form&#x27;</span>) &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 销毁实例时，自动执行析构方法</span></span><br><span class=\"line\">checker.destroy();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Extension和Plugin\"><a href=\"#Extension和Plugin\" class=\"headerlink\" title=\"Extension和Plugin\"></a>Extension和Plugin</h3><p>Extension（扩展）是为了解决多重继承，以一种类似组合的方式在类上添加功能的模式，它本身不能创建实例。这种设计非常像Ruby等语言中的Mixin。Plugin（插件）的作用是在对象上添加一些功能，这些功能也可以很方便的移除。</p>\n<p>它们有什么区别呢？简单来说，Extension是在类上加一些功能，所有类的实例都拥有这些功能。Plugin只是在某些类的实例中添加功能。举两个典型的例子：一些节点需要使用动画效果，这个功能适合作为Plugin。气泡提示控件需要支持多种对齐方式，所有实例都需要此功能，因此使用YUI3的WidgetPositionAlign扩展。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统的函数方式实现动画</span></span><br><span class=\"line\">Effect.fadeIn(nodeTip);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件方式实现动画</span></span><br><span class=\"line\">nodeTip.plug(NodeEffect);</span><br><span class=\"line\">nodeTip.effect.fadeIn();</span><br></pre></td></tr></table></figure>\n\n<p>Extension和Plugin很好的解决了我们遇到的诸多功能重用问题。我们开发了提供全屏功能的WidgetFullScreen、自动对齐对话框的DialogAutoAlign等扩展，以及进行异步查询的AsyncSearch、提供动画效果的NodeEffect等插件。将这些偏重OOP的编程思想应用在前端开发中，比较深刻的体会是：有更多的概念清晰、定位明确的开发模式可以选择。</p>\n<h3 id=\"Widget体系\"><a href=\"#Widget体系\" class=\"headerlink\" title=\"Widget体系\"></a>Widget体系</h3><p>Widget（控件）建立在Base之上，主要增加了UI层面的功能，例如<code>renderUI</code>、<code>bindUI</code>、<code>syncUI</code>等生命周期方法，<code>HTML_PARSER</code>等渐进增强功能，以及样式类、HTML结构和DOM事件的统一管理。Widget提供了控件开发的通用范式。</p>\n<p>由于前端资源相对紧张，我们倾向于大量使用控件，尤其在业务系统这样更注重功能的场景。主要出于两点考虑：</p>\n<ul>\n<li><strong>减少不必要的重复劳动，提高产出</strong>。通过将交互、业务逻辑合理抽象，一次解决一类问题，One Shot One Kill。</li>\n<li><strong>节约前端工程师资源</strong>。通过自动加载和初始化控件、封装简单易用的后端方法、制作Demo和使用手册等措施，降低使用门槛，后端工程师只需要知道参数的数据结构就可以轻松调用，提高了开发效率。</li>\n</ul>\n<p>以下是一个自动加载控件的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 页面初始化时，会扫描所有带有data-widget属性的节点，自动加载对应控件，并根据data-params数据进行初始化</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;…&quot;</span> <span class=\"attr\">data-widget</span>=<span class=\"string\">&quot;bubbleTip&quot;</span> <span class=\"attr\">data-params</span>=<span class=\"string\">&#x27;&#123; &quot;tip&quot;: &quot;全新改版，支持随时退款&quot; &#125;&#x27;</span>&gt;</span>下载手机版<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>目前，我们已经构建了一个包含近30个控件的Widget体系，为所有系统提供丰富、便捷、集成的解决方案。</p>\n<h2 id=\"行进中开火\"><a href=\"#行进中开火\" class=\"headerlink\" title=\"行进中开火\"></a>行进中开火</h2><p>在整个YUI3的实践中，我们犯过很多错误，例如全局只有一个YUI实例、Combo的CSS图片依赖等等，但这些并没有成为放弃的理由。从今天回过头来看，YUI3带给我们团队的，不只是更高的开发效率、更好的可持续开发能力，还有它本身的设计思路、源码书写、辅助工具等诸多方面潜移默化的影响。这些回报的价值，比起较高的使用门槛、犯过的一些错误，要贵重百倍。</p>\n<p>指导这一切的，是我们始终坚持的 <strong>“行进中开火”</strong>。在互联网这个高速发展的行业里，对于我们这种小规模的创业团队，一天不前进，就意味落后。做事不应该准备太多，一定要先做起来，然后发现不足并不断改进，宁可十年不将军，不可一日不拱卒。每天都做得更好一点，日积月累，我们才会在激烈的竞争中占据越来越大的优势。</p>\n<p>YUI3并非完美，存在着学习成本高、对社区不够开放等问题。我们所做的更远非完美，但经过不断的尝试和经验的积累，已经渐渐摸索出一条明确的路线，并会坚持不懈的继续走下去。</p>\n<p>关于YUI3和我们团队更多的信息请关注 <a href=\"http://fe.meituan.com/\">http://fe.meituan.com</a></p>"},{"layout":"post","title":"Fire Fast","date":"2022-05-03T01:28:25.000Z","status":"publish","_content":"\n[上篇文章](https://shangchun.net/hire-slow/)，我们谈过了“Hire slow，fire fast”的前半句，今天我们聊下后半句，也即“fire fast”。\n\n历经千辛万苦，新人终于到岗并开始适应新环境，大部分人都可以在两到三个月时间恢复战斗力，进而产出符合预期的价值。\n但也有少数例外情况，由于种种原因，新人并没有达成预期。应该怎么处理这样的情况呢？\n\n\n## 一定要 fire 吗？\n\n首先我们要界定这个人是不是达到了需要 fire 的标准，具体各团队可能都有些适合自身的判断。\n我个人比较偏向的标准是：\n\n1. 不能达成预期的预期是长期性的，短期内很难改观\n  <p style=\"margin: 0 0 0.2rem 0\">\n  如果新人只是因为对于当前技术栈不熟悉，或者因为外语、远程办公等工作环境的剧烈变化导致的不符合预期，那么我们是可以考虑多给些时间以进一步考察。\n  但如果新人是因为自身能力问题，譬如一个高级工程师无法产出合格的系统方案设计，或者总是用两倍甚至三倍以上的时间才能交付质量下乘的项目，\n  这类问题通常无法短时间内通过培训等助力方式快速提升\n  </p>\n2. 存在一些原则性的根源问题\n  <p style=\"margin: 0 0 0.2rem 0\">\n  每个团队可能都有一些”红线“，譬如一个非常分布式的基于信任构建的团队里，非常依赖高度自驱来推进各项目，如果新人无法自律，划水严重，\n  如果在管理者进行警告督促后仍无有效改正的话，可以认定存在原则性问题。类似的红线问题还有不诚信、泄露公司机密牟利等等\n  </p>\n\n其实第二点只是第一点的一种特例，本质上第一点这一标准就够了。\n\n<!--more-->\n\n\n## Fire 其实阻力重重\n\n即便我们内心的天平已经偏向于 fire，但实操层面，往往还有各种因素导致我们无法快速做出决断：\n\n- 这位工程师只是解决问题速度慢了点，其它例如沟通方面还是可以的\n- 代码写的虽然糙了点，但是也能如期交付\n- 自律比较差，但是多催一催也能出活\n\n从根本上来讲，本身这个世界就是复杂的，并不是非黑即白，我们往往要在灰色地带做取舍。\n大部分未达预期的新人既然能够通过层层筛选，肯定也有自己的相对优势。\n那么怎么权衡要不要 fire 就高度依赖团队管理者对于情势的判断，尤其是团队定位和个人定位的调和空间。\n如果他的某方面核心能力能够在未来一段时间提升团队的短板，那么即便管理者适当补位也可以接受的话，那可以先留任看看。\n相反，如果他的核心能力或者很弱或者并非团队将来所需的情况下，就没有必要继续。\n\n另外一个 fire 的阻力点是：这某种程度上证明了招聘流程存在疏漏。让人正面和解决问题需要高度自信，有的管理者可能由于这方面的疑虑，\n往往都优先选择再观察一段时间，直到很久之后迫不得已才动手。其实大可不必，即便是类似 Netflix 之类的优秀团队，\n也有可能遇到一些针对性比较强的候选人或者遗漏了一些要点。就像我们维护一个产品或者系统，逐步迭代查漏补缺就好。\n\n还有人担忧说如果新人愤愤不平，故意捣乱怎么办，譬如实名或匿名开始语言攻击或者诋毁团队，破坏团结等。\n其实我倒是觉得，这样的人越早暴露越说明我们做对了。\n\n\n## 容忍低绩效者是对大多数人的惩罚\n\n在上一篇文章里我们分享过平庸的工程师带来的一些负面影响，其中我认为最重要的一条是：\n\n- 向团队表明你接受平庸，从而使问题更加严重\n\n正如那篇文章开头的例子一样，低绩效者一旦在团队中被其他人显著地识别了出来，那么大家就会开始质疑团队是否还在一个健康发展之中。\n一旦他们做出了肯定的判断，那么高绩效者们的离开只是时间问题。因此我一向认为，容忍低绩效者实际是对大多数人的惩罚，是在向大家表明这个团队越来越平庸。\n\n对于管理者，我理解非常类似 Jon Snow 这样的守夜人，核心职能之一就是能够营造出一种让团队的大部分人充分发挥自己的聪明才智为公司贡献价值的氛围。\n当有一些噪音或者负面情况出现时，守夜人能够及时发现和干预，以保障团队主体免遭影响。\n\n也因此，即便困难重重，我依然建议管理者从整体利益出发，在负面影响扩大之前，早做决断。\n\n\n## 所有的底气来自于有能力招更好的人\n\n不少管理者在是否 fire 之间犹豫不决还有一个重要因素：招人不易。试问：如果一个月内就可以招到符合要求的候补成员，还用得着犹豫吗？当然不用！\n所以，类似我在[招聘驱动的组织建设](https://shangchun.net/recruitment-driven-organization/)中提到的\n\n> 工程师组织建设的核心就是招人，招足够优秀的人\n\n如果我们整个组织是优秀高效稳定的，辅以适当的面向招聘的各项举措，自然能够吸引到足够的候选人，从而实现自然可持续增长。\n\n## 结语\n\n”Hire slow, fire fast\" 看似简单，实则是大智慧，关乎高人才密度团队建设的一体两面。我自己在平时工作中受用良多，对于“做正确而不是容易的事情”也有了更深的理解。这两篇粗浅的思考也希望能给更多人提供参考。\n","source":"_posts/fire-fast.md","raw":"---\nlayout: post\ntitle: \"Fire Fast\"\ndate: 2022-05-03 09:28:25\nstatus: publish\ntags:\n  - Recruitment\n  - Organization\n---\n\n[上篇文章](https://shangchun.net/hire-slow/)，我们谈过了“Hire slow，fire fast”的前半句，今天我们聊下后半句，也即“fire fast”。\n\n历经千辛万苦，新人终于到岗并开始适应新环境，大部分人都可以在两到三个月时间恢复战斗力，进而产出符合预期的价值。\n但也有少数例外情况，由于种种原因，新人并没有达成预期。应该怎么处理这样的情况呢？\n\n\n## 一定要 fire 吗？\n\n首先我们要界定这个人是不是达到了需要 fire 的标准，具体各团队可能都有些适合自身的判断。\n我个人比较偏向的标准是：\n\n1. 不能达成预期的预期是长期性的，短期内很难改观\n  <p style=\"margin: 0 0 0.2rem 0\">\n  如果新人只是因为对于当前技术栈不熟悉，或者因为外语、远程办公等工作环境的剧烈变化导致的不符合预期，那么我们是可以考虑多给些时间以进一步考察。\n  但如果新人是因为自身能力问题，譬如一个高级工程师无法产出合格的系统方案设计，或者总是用两倍甚至三倍以上的时间才能交付质量下乘的项目，\n  这类问题通常无法短时间内通过培训等助力方式快速提升\n  </p>\n2. 存在一些原则性的根源问题\n  <p style=\"margin: 0 0 0.2rem 0\">\n  每个团队可能都有一些”红线“，譬如一个非常分布式的基于信任构建的团队里，非常依赖高度自驱来推进各项目，如果新人无法自律，划水严重，\n  如果在管理者进行警告督促后仍无有效改正的话，可以认定存在原则性问题。类似的红线问题还有不诚信、泄露公司机密牟利等等\n  </p>\n\n其实第二点只是第一点的一种特例，本质上第一点这一标准就够了。\n\n<!--more-->\n\n\n## Fire 其实阻力重重\n\n即便我们内心的天平已经偏向于 fire，但实操层面，往往还有各种因素导致我们无法快速做出决断：\n\n- 这位工程师只是解决问题速度慢了点，其它例如沟通方面还是可以的\n- 代码写的虽然糙了点，但是也能如期交付\n- 自律比较差，但是多催一催也能出活\n\n从根本上来讲，本身这个世界就是复杂的，并不是非黑即白，我们往往要在灰色地带做取舍。\n大部分未达预期的新人既然能够通过层层筛选，肯定也有自己的相对优势。\n那么怎么权衡要不要 fire 就高度依赖团队管理者对于情势的判断，尤其是团队定位和个人定位的调和空间。\n如果他的某方面核心能力能够在未来一段时间提升团队的短板，那么即便管理者适当补位也可以接受的话，那可以先留任看看。\n相反，如果他的核心能力或者很弱或者并非团队将来所需的情况下，就没有必要继续。\n\n另外一个 fire 的阻力点是：这某种程度上证明了招聘流程存在疏漏。让人正面和解决问题需要高度自信，有的管理者可能由于这方面的疑虑，\n往往都优先选择再观察一段时间，直到很久之后迫不得已才动手。其实大可不必，即便是类似 Netflix 之类的优秀团队，\n也有可能遇到一些针对性比较强的候选人或者遗漏了一些要点。就像我们维护一个产品或者系统，逐步迭代查漏补缺就好。\n\n还有人担忧说如果新人愤愤不平，故意捣乱怎么办，譬如实名或匿名开始语言攻击或者诋毁团队，破坏团结等。\n其实我倒是觉得，这样的人越早暴露越说明我们做对了。\n\n\n## 容忍低绩效者是对大多数人的惩罚\n\n在上一篇文章里我们分享过平庸的工程师带来的一些负面影响，其中我认为最重要的一条是：\n\n- 向团队表明你接受平庸，从而使问题更加严重\n\n正如那篇文章开头的例子一样，低绩效者一旦在团队中被其他人显著地识别了出来，那么大家就会开始质疑团队是否还在一个健康发展之中。\n一旦他们做出了肯定的判断，那么高绩效者们的离开只是时间问题。因此我一向认为，容忍低绩效者实际是对大多数人的惩罚，是在向大家表明这个团队越来越平庸。\n\n对于管理者，我理解非常类似 Jon Snow 这样的守夜人，核心职能之一就是能够营造出一种让团队的大部分人充分发挥自己的聪明才智为公司贡献价值的氛围。\n当有一些噪音或者负面情况出现时，守夜人能够及时发现和干预，以保障团队主体免遭影响。\n\n也因此，即便困难重重，我依然建议管理者从整体利益出发，在负面影响扩大之前，早做决断。\n\n\n## 所有的底气来自于有能力招更好的人\n\n不少管理者在是否 fire 之间犹豫不决还有一个重要因素：招人不易。试问：如果一个月内就可以招到符合要求的候补成员，还用得着犹豫吗？当然不用！\n所以，类似我在[招聘驱动的组织建设](https://shangchun.net/recruitment-driven-organization/)中提到的\n\n> 工程师组织建设的核心就是招人，招足够优秀的人\n\n如果我们整个组织是优秀高效稳定的，辅以适当的面向招聘的各项举措，自然能够吸引到足够的候选人，从而实现自然可持续增长。\n\n## 结语\n\n”Hire slow, fire fast\" 看似简单，实则是大智慧，关乎高人才密度团队建设的一体两面。我自己在平时工作中受用良多，对于“做正确而不是容易的事情”也有了更深的理解。这两篇粗浅的思考也希望能给更多人提供参考。\n","slug":"fire-fast","published":1,"updated":"2022-05-03T03:59:49.290Z","_id":"cl2plges60000x88551ie2r26","comments":1,"photos":[],"link":"","content":"<p><a href=\"https://shangchun.net/hire-slow/\">上篇文章</a>，我们谈过了“Hire slow，fire fast”的前半句，今天我们聊下后半句，也即“fire fast”。</p>\n<p>历经千辛万苦，新人终于到岗并开始适应新环境，大部分人都可以在两到三个月时间恢复战斗力，进而产出符合预期的价值。\n但也有少数例外情况，由于种种原因，新人并没有达成预期。应该怎么处理这样的情况呢？</p>\n<h2 id=\"一定要-fire-吗？\"><a href=\"#一定要-fire-吗？\" class=\"headerlink\" title=\"一定要 fire 吗？\"></a>一定要 fire 吗？</h2><p>首先我们要界定这个人是不是达到了需要 fire 的标准，具体各团队可能都有些适合自身的判断。\n我个人比较偏向的标准是：</p>\n<ol>\n<li>不能达成预期的预期是长期性的，短期内很难改观<p style=\"margin: 0 0 0.2rem 0\">\n如果新人只是因为对于当前技术栈不熟悉，或者因为外语、远程办公等工作环境的剧烈变化导致的不符合预期，那么我们是可以考虑多给些时间以进一步考察。\n但如果新人是因为自身能力问题，譬如一个高级工程师无法产出合格的系统方案设计，或者总是用两倍甚至三倍以上的时间才能交付质量下乘的项目，\n这类问题通常无法短时间内通过培训等助力方式快速提升\n</p></li>\n<li>存在一些原则性的根源问题<p style=\"margin: 0 0 0.2rem 0\">\n每个团队可能都有一些”红线“，譬如一个非常分布式的基于信任构建的团队里，非常依赖高度自驱来推进各项目，如果新人无法自律，划水严重，\n如果在管理者进行警告督促后仍无有效改正的话，可以认定存在原则性问题。类似的红线问题还有不诚信、泄露公司机密牟利等等\n</p></li>\n</ol>\n<p>其实第二点只是第一点的一种特例，本质上第一点这一标准就够了。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"Fire-其实阻力重重\"><a href=\"#Fire-其实阻力重重\" class=\"headerlink\" title=\"Fire 其实阻力重重\"></a>Fire 其实阻力重重</h2><p>即便我们内心的天平已经偏向于 fire，但实操层面，往往还有各种因素导致我们无法快速做出决断：</p>\n<ul>\n<li>这位工程师只是解决问题速度慢了点，其它例如沟通方面还是可以的</li>\n<li>代码写的虽然糙了点，但是也能如期交付</li>\n<li>自律比较差，但是多催一催也能出活</li>\n</ul>\n<p>从根本上来讲，本身这个世界就是复杂的，并不是非黑即白，我们往往要在灰色地带做取舍。\n大部分未达预期的新人既然能够通过层层筛选，肯定也有自己的相对优势。\n那么怎么权衡要不要 fire 就高度依赖团队管理者对于情势的判断，尤其是团队定位和个人定位的调和空间。\n如果他的某方面核心能力能够在未来一段时间提升团队的短板，那么即便管理者适当补位也可以接受的话，那可以先留任看看。\n相反，如果他的核心能力或者很弱或者并非团队将来所需的情况下，就没有必要继续。</p>\n<p>另外一个 fire 的阻力点是：这某种程度上证明了招聘流程存在疏漏。让人正面和解决问题需要高度自信，有的管理者可能由于这方面的疑虑，\n往往都优先选择再观察一段时间，直到很久之后迫不得已才动手。其实大可不必，即便是类似 Netflix 之类的优秀团队，\n也有可能遇到一些针对性比较强的候选人或者遗漏了一些要点。就像我们维护一个产品或者系统，逐步迭代查漏补缺就好。</p>\n<p>还有人担忧说如果新人愤愤不平，故意捣乱怎么办，譬如实名或匿名开始语言攻击或者诋毁团队，破坏团结等。\n其实我倒是觉得，这样的人越早暴露越说明我们做对了。</p>\n<h2 id=\"容忍低绩效者是对大多数人的惩罚\"><a href=\"#容忍低绩效者是对大多数人的惩罚\" class=\"headerlink\" title=\"容忍低绩效者是对大多数人的惩罚\"></a>容忍低绩效者是对大多数人的惩罚</h2><p>在上一篇文章里我们分享过平庸的工程师带来的一些负面影响，其中我认为最重要的一条是：</p>\n<ul>\n<li>向团队表明你接受平庸，从而使问题更加严重</li>\n</ul>\n<p>正如那篇文章开头的例子一样，低绩效者一旦在团队中被其他人显著地识别了出来，那么大家就会开始质疑团队是否还在一个健康发展之中。\n一旦他们做出了肯定的判断，那么高绩效者们的离开只是时间问题。因此我一向认为，容忍低绩效者实际是对大多数人的惩罚，是在向大家表明这个团队越来越平庸。</p>\n<p>对于管理者，我理解非常类似 Jon Snow 这样的守夜人，核心职能之一就是能够营造出一种让团队的大部分人充分发挥自己的聪明才智为公司贡献价值的氛围。\n当有一些噪音或者负面情况出现时，守夜人能够及时发现和干预，以保障团队主体免遭影响。</p>\n<p>也因此，即便困难重重，我依然建议管理者从整体利益出发，在负面影响扩大之前，早做决断。</p>\n<h2 id=\"所有的底气来自于有能力招更好的人\"><a href=\"#所有的底气来自于有能力招更好的人\" class=\"headerlink\" title=\"所有的底气来自于有能力招更好的人\"></a>所有的底气来自于有能力招更好的人</h2><p>不少管理者在是否 fire 之间犹豫不决还有一个重要因素：招人不易。试问：如果一个月内就可以招到符合要求的候补成员，还用得着犹豫吗？当然不用！\n所以，类似我在<a href=\"https://shangchun.net/recruitment-driven-organization/\">招聘驱动的组织建设</a>中提到的</p>\n<blockquote>\n<p>工程师组织建设的核心就是招人，招足够优秀的人</p>\n</blockquote>\n<p>如果我们整个组织是优秀高效稳定的，辅以适当的面向招聘的各项举措，自然能够吸引到足够的候选人，从而实现自然可持续增长。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>”Hire slow, fire fast” 看似简单，实则是大智慧，关乎高人才密度团队建设的一体两面。我自己在平时工作中受用良多，对于“做正确而不是容易的事情”也有了更深的理解。这两篇粗浅的思考也希望能给更多人提供参考。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://shangchun.net/hire-slow/\">上篇文章</a>，我们谈过了“Hire slow，fire fast”的前半句，今天我们聊下后半句，也即“fire fast”。</p>\n<p>历经千辛万苦，新人终于到岗并开始适应新环境，大部分人都可以在两到三个月时间恢复战斗力，进而产出符合预期的价值。\n但也有少数例外情况，由于种种原因，新人并没有达成预期。应该怎么处理这样的情况呢？</p>\n<h2 id=\"一定要-fire-吗？\"><a href=\"#一定要-fire-吗？\" class=\"headerlink\" title=\"一定要 fire 吗？\"></a>一定要 fire 吗？</h2><p>首先我们要界定这个人是不是达到了需要 fire 的标准，具体各团队可能都有些适合自身的判断。\n我个人比较偏向的标准是：</p>\n<ol>\n<li>不能达成预期的预期是长期性的，短期内很难改观<p style=\"margin: 0 0 0.2rem 0\">\n如果新人只是因为对于当前技术栈不熟悉，或者因为外语、远程办公等工作环境的剧烈变化导致的不符合预期，那么我们是可以考虑多给些时间以进一步考察。\n但如果新人是因为自身能力问题，譬如一个高级工程师无法产出合格的系统方案设计，或者总是用两倍甚至三倍以上的时间才能交付质量下乘的项目，\n这类问题通常无法短时间内通过培训等助力方式快速提升\n</p></li>\n<li>存在一些原则性的根源问题<p style=\"margin: 0 0 0.2rem 0\">\n每个团队可能都有一些”红线“，譬如一个非常分布式的基于信任构建的团队里，非常依赖高度自驱来推进各项目，如果新人无法自律，划水严重，\n如果在管理者进行警告督促后仍无有效改正的话，可以认定存在原则性问题。类似的红线问题还有不诚信、泄露公司机密牟利等等\n</p></li>\n</ol>\n<p>其实第二点只是第一点的一种特例，本质上第一点这一标准就够了。</p>","more":"<h2 id=\"Fire-其实阻力重重\"><a href=\"#Fire-其实阻力重重\" class=\"headerlink\" title=\"Fire 其实阻力重重\"></a>Fire 其实阻力重重</h2><p>即便我们内心的天平已经偏向于 fire，但实操层面，往往还有各种因素导致我们无法快速做出决断：</p>\n<ul>\n<li>这位工程师只是解决问题速度慢了点，其它例如沟通方面还是可以的</li>\n<li>代码写的虽然糙了点，但是也能如期交付</li>\n<li>自律比较差，但是多催一催也能出活</li>\n</ul>\n<p>从根本上来讲，本身这个世界就是复杂的，并不是非黑即白，我们往往要在灰色地带做取舍。\n大部分未达预期的新人既然能够通过层层筛选，肯定也有自己的相对优势。\n那么怎么权衡要不要 fire 就高度依赖团队管理者对于情势的判断，尤其是团队定位和个人定位的调和空间。\n如果他的某方面核心能力能够在未来一段时间提升团队的短板，那么即便管理者适当补位也可以接受的话，那可以先留任看看。\n相反，如果他的核心能力或者很弱或者并非团队将来所需的情况下，就没有必要继续。</p>\n<p>另外一个 fire 的阻力点是：这某种程度上证明了招聘流程存在疏漏。让人正面和解决问题需要高度自信，有的管理者可能由于这方面的疑虑，\n往往都优先选择再观察一段时间，直到很久之后迫不得已才动手。其实大可不必，即便是类似 Netflix 之类的优秀团队，\n也有可能遇到一些针对性比较强的候选人或者遗漏了一些要点。就像我们维护一个产品或者系统，逐步迭代查漏补缺就好。</p>\n<p>还有人担忧说如果新人愤愤不平，故意捣乱怎么办，譬如实名或匿名开始语言攻击或者诋毁团队，破坏团结等。\n其实我倒是觉得，这样的人越早暴露越说明我们做对了。</p>\n<h2 id=\"容忍低绩效者是对大多数人的惩罚\"><a href=\"#容忍低绩效者是对大多数人的惩罚\" class=\"headerlink\" title=\"容忍低绩效者是对大多数人的惩罚\"></a>容忍低绩效者是对大多数人的惩罚</h2><p>在上一篇文章里我们分享过平庸的工程师带来的一些负面影响，其中我认为最重要的一条是：</p>\n<ul>\n<li>向团队表明你接受平庸，从而使问题更加严重</li>\n</ul>\n<p>正如那篇文章开头的例子一样，低绩效者一旦在团队中被其他人显著地识别了出来，那么大家就会开始质疑团队是否还在一个健康发展之中。\n一旦他们做出了肯定的判断，那么高绩效者们的离开只是时间问题。因此我一向认为，容忍低绩效者实际是对大多数人的惩罚，是在向大家表明这个团队越来越平庸。</p>\n<p>对于管理者，我理解非常类似 Jon Snow 这样的守夜人，核心职能之一就是能够营造出一种让团队的大部分人充分发挥自己的聪明才智为公司贡献价值的氛围。\n当有一些噪音或者负面情况出现时，守夜人能够及时发现和干预，以保障团队主体免遭影响。</p>\n<p>也因此，即便困难重重，我依然建议管理者从整体利益出发，在负面影响扩大之前，早做决断。</p>\n<h2 id=\"所有的底气来自于有能力招更好的人\"><a href=\"#所有的底气来自于有能力招更好的人\" class=\"headerlink\" title=\"所有的底气来自于有能力招更好的人\"></a>所有的底气来自于有能力招更好的人</h2><p>不少管理者在是否 fire 之间犹豫不决还有一个重要因素：招人不易。试问：如果一个月内就可以招到符合要求的候补成员，还用得着犹豫吗？当然不用！\n所以，类似我在<a href=\"https://shangchun.net/recruitment-driven-organization/\">招聘驱动的组织建设</a>中提到的</p>\n<blockquote>\n<p>工程师组织建设的核心就是招人，招足够优秀的人</p>\n</blockquote>\n<p>如果我们整个组织是优秀高效稳定的，辅以适当的面向招聘的各项举措，自然能够吸引到足够的候选人，从而实现自然可持续增长。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>”Hire slow, fire fast” 看似简单，实则是大智慧，关乎高人才密度团队建设的一体两面。我自己在平时工作中受用良多，对于“做正确而不是容易的事情”也有了更深的理解。这两篇粗浅的思考也希望能给更多人提供参考。</p>"},{"layout":"post","title":"数据请求利器 React Query","date":"2022-06-05T08:25:19.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [数据请求利器 React Query](https://zhuanlan.zhihu.com/p/522609991) 查看全文。\n","source":"_posts/react-query.md","raw":"---\nlayout: post\ntitle: \"数据请求利器 React Query\"\ndate: 2022-06-05 16:25:19\nstatus: publish\ntags: [React Query, React]\n---\n\n请移步知乎“前端之美”专栏 [数据请求利器 React Query](https://zhuanlan.zhihu.com/p/522609991) 查看全文。\n","slug":"react-query","published":1,"updated":"2022-06-27T00:54:40.679Z","comments":1,"photos":[],"link":"","_id":"cl4w135nx0000od85cqwag3vt","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/522609991\">数据请求利器 React Query</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/522609991\">数据请求利器 React Query</a> 查看全文。</p>\n"},{"layout":"post","title":"管理的杠杆","date":"2022-07-05T13:06:17.000Z","status":"publish","_content":"\n最近听到有朋友说我比较善于使用管理的杠杆，顿觉旁观者清。坦白来说，我自己虽然在日常实践中有意无意地应用类似的思想，却还未有明确的这方面的总结和提炼。\n当时就萌生了写一篇文章来整理的想法。如今终于起笔，文中所言不一定对各位管理者有实际裨益，不过也权当是兼听则明吧。\n\n一位好的管理者，在我理解来看，应当是一个 Multiplier，能够将大家的优势有效地发挥出来，形成合力，进而完成整个组织不断进阶的目标。\n我一直相信群体的力量远胜于少数核心人物的智慧。为了更好地激发大家的主观能动性，用好管理的杠杆，下面介绍几点我自己的思考。\n\n## 注入使命\n\n> If you want to build a ship，don't drum up people to collect wood and don't assign them tasks and work, but rather long for the endless immensity of sea.\n> 如果你想造一艘船，先不要雇人收集木头，也不要给人分配任务，而是激发他们对海洋的渴望。\n\n当一个项目需要一群人来完成时，我们可以有不同的方式来进行项目的启动：\n\n1. 只介绍这个项目要做的具体事项\n2. 介绍项目的优先目标以及实施方案\n3. 介绍项目的背景、优先目标以及和公司整体战略的联系，并鼓励大家献计献策，通过沟通协作逐步确定具体方案\n \n<!--more-->\n\n第一种方式在很多公司都非常常见，大家都是公司雇员，拿钱办事，既然上面老板们决定要做那就没啥可讨论的，干就完了。\n第二种方式相较而言，会跟大家分享项目想要解决的核心问题，这样一个好处是大家有了更明确的方向，这样就为调动大家积极性、激发大家审视和改良现有的实施方案提供了很大空间，对于有效完成项目目标有非常正面的意义。\n第三种方案在两个点上做的更进一步：一方面会讲清楚项目对于公司的关键作用，有助于大家理解这一项目在哪些层面对于公司的进一步发展至关重要。另一方面也提高了大家的参与感，具体方案的确定是通过沟通协作来完成的，这样的方案也往往更接地气，在效率和成本方面都能做到非常出色。\n\n在平时的实践中，我非常有意识地在用第三种方式来为一个事情注入使命，并在前期沟通中不断和利益攸关方沟通以凝聚共识。\n\n以确立新人培训流程这个项目为例：\n\n- 项目的核心价值是帮助新人快速融入团队并为后续发挥战斗力打好基础，具体包括了解各团队的人和事，以及公司发展过程、产品演变历史、团队文化等内容\n- 跟相关老大们协调一致后，在和各个团队骨干讲师的沟通中，着重强调的是这件事对于新人和公司的重大价值：公司的发展最核心的动力在于人，而让源源不断的新人快速适应和融入团队，对于传承优秀的团队文化和打造一支精英团队至关重要\n- 后续的流程推进中，能够明显感觉到各位讲师在培训上投入很多，包括内容准备、讲解技巧等等方面，他们也通过培训更多地了解和认识了很多新人\n\n类似的例子还有很多，大到公司的一些核心项目，小到一次外出团建，我们都会竭尽所能地将其背后的重要意义跟大家阐释出来。\n\n我能明显感觉到具有使命感与否所产生的巨大差异，目标明确且有信念的人常常让你眼前一亮，他们不仅会主动找到更优的方案，而且在面对困难时也百折不挠，使命必达。\n这也让我深刻认识到另一个道理：**注入使命才会催发主人翁精神**，之后的事情就变得简单起来，不需要那么多的微观管理。\n\n\n## 盘活资源\n\n南水北调、西气东输、精准扶贫等祖国大地上发生的重大项目都体现出了盘活资源的重要意义。和国家治理类似，管理杠杆的另一个重点是合理地利用好手里的资源，这里的资源包括人、项目、资金、活动等等，当然最重要的还是人。\n\n盘活资源在我理解有以下几个点：\n\n- 首先要能够识别出能够在某方面能够有所作为的资源。就人而言，有人擅长社交，有人擅长分析，有人演讲特别有感染力，有人观察细致入微，这些都是他们的一些特质，将来可能能够为团队所用\n- 推进一个项目时，尽量从“能不能不做 -> 能不能以后做 -> 能不能别人做 -> 自己做”这一逻辑出发，优先选派有相对优势的同事而非自己亲力亲为，以此来秣马厉兵，培养和发展人才\n- 鉴于项目初期可能同事之间还没那么熟悉，同时也可能有一些重要决策需要有人来背书，可以“扶上马，送一程”，然后只做一些咨询类的支持\n\n以我们一个内部分享会 Tubi Talent Time 的组织为例，最初团队比较小的时候，还主要是我来具体负责协调。后来团队成长到一定规模，原来的模式频频出现各种问题，包括轮值主持人找不到讲师、讲师内容准备不够充分、缺乏反馈渠道等等。\n为了更好地解决这些问题，我们就从各个团队选了一些热衷于分享的同事，组建了一个新的委员会专门负责分享会的运作。大家勠力同心，不仅帮忙收集了很多潜在分享内容，而且在很多方面将分享活动的组织进一步优化，目前已经取得了超出我预期的进展。\n\n我有一个很深的体会是：**你能调动的资源往往比你想象的要多**。甚至不光所有下属，其实你的上级、平级和其他有合作的部门都是非常重要的潜在资源。在一个非常有价值的项目的串联下，这些资源都是可以争取到的。\n\n\n## 分享利益\n\n“无双赢，不合作”是我的一个信条，如果你让一个人做一件事，而他却从中毫无所得，那人家为啥有动力去把这个事情做好呢？！财聚人散，财散人聚，这是一个很简单的道理。\n\n因此想要最终实现管理的杠杆，让更多人有意愿发挥自己的比较优势，就应该想方设法让他们也能分到应得的利益。这里的利益并不一定是钱，也可以是荣誉、机会、人际关系等等。\n\n在推进导师制的过程中，我对新晋导师进行培训的时候就开门见山介绍了他们可能的一些获益：\n\n- 增强知识储备。能够做好一件事和能够传授一件事是有本质区别的，后者才能让你对这件事的理解再上一个层次，吃深吃透\n- 建立人际关系。我们招到的都是非常优秀的工程师，相对而言新人可能在经验方法上欠缺一些，但是都足够有智慧，相互的切磋和沟通，可以深化“亦师亦友”的良好关系\n- 培养管理能力。很多人走上管理岗的第一步都是从做导师开始的，通过指导新人帮助他们快速成长，能够实践和掌握诸如预期管理、沟通、激励反馈等基本的管理技能\n\n后来事实上因为团队发展很快，很大一部分早期的导师都慢慢开始带更大规模的团队，获得收入、成长、人脉上的多丰收。\n\n关于利益我的一个体会是：**更多着眼在能力成长这些本源上，它们并非物质利益但会带来物质利益**。一旦我们把合作关系庸俗化，弄成赤裸裸的金钱利益共同体，就可能会产生短视、腐败等问题。能力提升才是最根本的。\n\n\n## 小结\n\n教员曾经说过：所谓政治，就是把我们的人搞得多多的，把敌人搞得少少的。虽然管理并非政治，但有些思路是相通的。\n只有解放群众，发动群众，不断通过改造生产关系来释放和发展生产力，才能激发出团队的最大潜能，实现组织的可持续的成功。\n这其中，通过注入使命让大家有明确方向和一定灵活度，通过盘活资源让各类型要素流通协作，通过分享利益让大家真的有所得从而更有积极性和认同感，环环相扣，紧密联系，对于杠杆的有效发挥至关重要。\n管理方面我虽然不是新兵，但也还在摸索前进。如果你有更多的想法，欢迎约饭交流。\n","source":"_posts/management-lever.md","raw":"---\nlayout: post\ntitle: 管理的杠杆\ndate: 2022-07-05 21:06:17\nstatus: publish\ntags: [Management, Lever]\n---\n\n最近听到有朋友说我比较善于使用管理的杠杆，顿觉旁观者清。坦白来说，我自己虽然在日常实践中有意无意地应用类似的思想，却还未有明确的这方面的总结和提炼。\n当时就萌生了写一篇文章来整理的想法。如今终于起笔，文中所言不一定对各位管理者有实际裨益，不过也权当是兼听则明吧。\n\n一位好的管理者，在我理解来看，应当是一个 Multiplier，能够将大家的优势有效地发挥出来，形成合力，进而完成整个组织不断进阶的目标。\n我一直相信群体的力量远胜于少数核心人物的智慧。为了更好地激发大家的主观能动性，用好管理的杠杆，下面介绍几点我自己的思考。\n\n## 注入使命\n\n> If you want to build a ship，don't drum up people to collect wood and don't assign them tasks and work, but rather long for the endless immensity of sea.\n> 如果你想造一艘船，先不要雇人收集木头，也不要给人分配任务，而是激发他们对海洋的渴望。\n\n当一个项目需要一群人来完成时，我们可以有不同的方式来进行项目的启动：\n\n1. 只介绍这个项目要做的具体事项\n2. 介绍项目的优先目标以及实施方案\n3. 介绍项目的背景、优先目标以及和公司整体战略的联系，并鼓励大家献计献策，通过沟通协作逐步确定具体方案\n \n<!--more-->\n\n第一种方式在很多公司都非常常见，大家都是公司雇员，拿钱办事，既然上面老板们决定要做那就没啥可讨论的，干就完了。\n第二种方式相较而言，会跟大家分享项目想要解决的核心问题，这样一个好处是大家有了更明确的方向，这样就为调动大家积极性、激发大家审视和改良现有的实施方案提供了很大空间，对于有效完成项目目标有非常正面的意义。\n第三种方案在两个点上做的更进一步：一方面会讲清楚项目对于公司的关键作用，有助于大家理解这一项目在哪些层面对于公司的进一步发展至关重要。另一方面也提高了大家的参与感，具体方案的确定是通过沟通协作来完成的，这样的方案也往往更接地气，在效率和成本方面都能做到非常出色。\n\n在平时的实践中，我非常有意识地在用第三种方式来为一个事情注入使命，并在前期沟通中不断和利益攸关方沟通以凝聚共识。\n\n以确立新人培训流程这个项目为例：\n\n- 项目的核心价值是帮助新人快速融入团队并为后续发挥战斗力打好基础，具体包括了解各团队的人和事，以及公司发展过程、产品演变历史、团队文化等内容\n- 跟相关老大们协调一致后，在和各个团队骨干讲师的沟通中，着重强调的是这件事对于新人和公司的重大价值：公司的发展最核心的动力在于人，而让源源不断的新人快速适应和融入团队，对于传承优秀的团队文化和打造一支精英团队至关重要\n- 后续的流程推进中，能够明显感觉到各位讲师在培训上投入很多，包括内容准备、讲解技巧等等方面，他们也通过培训更多地了解和认识了很多新人\n\n类似的例子还有很多，大到公司的一些核心项目，小到一次外出团建，我们都会竭尽所能地将其背后的重要意义跟大家阐释出来。\n\n我能明显感觉到具有使命感与否所产生的巨大差异，目标明确且有信念的人常常让你眼前一亮，他们不仅会主动找到更优的方案，而且在面对困难时也百折不挠，使命必达。\n这也让我深刻认识到另一个道理：**注入使命才会催发主人翁精神**，之后的事情就变得简单起来，不需要那么多的微观管理。\n\n\n## 盘活资源\n\n南水北调、西气东输、精准扶贫等祖国大地上发生的重大项目都体现出了盘活资源的重要意义。和国家治理类似，管理杠杆的另一个重点是合理地利用好手里的资源，这里的资源包括人、项目、资金、活动等等，当然最重要的还是人。\n\n盘活资源在我理解有以下几个点：\n\n- 首先要能够识别出能够在某方面能够有所作为的资源。就人而言，有人擅长社交，有人擅长分析，有人演讲特别有感染力，有人观察细致入微，这些都是他们的一些特质，将来可能能够为团队所用\n- 推进一个项目时，尽量从“能不能不做 -> 能不能以后做 -> 能不能别人做 -> 自己做”这一逻辑出发，优先选派有相对优势的同事而非自己亲力亲为，以此来秣马厉兵，培养和发展人才\n- 鉴于项目初期可能同事之间还没那么熟悉，同时也可能有一些重要决策需要有人来背书，可以“扶上马，送一程”，然后只做一些咨询类的支持\n\n以我们一个内部分享会 Tubi Talent Time 的组织为例，最初团队比较小的时候，还主要是我来具体负责协调。后来团队成长到一定规模，原来的模式频频出现各种问题，包括轮值主持人找不到讲师、讲师内容准备不够充分、缺乏反馈渠道等等。\n为了更好地解决这些问题，我们就从各个团队选了一些热衷于分享的同事，组建了一个新的委员会专门负责分享会的运作。大家勠力同心，不仅帮忙收集了很多潜在分享内容，而且在很多方面将分享活动的组织进一步优化，目前已经取得了超出我预期的进展。\n\n我有一个很深的体会是：**你能调动的资源往往比你想象的要多**。甚至不光所有下属，其实你的上级、平级和其他有合作的部门都是非常重要的潜在资源。在一个非常有价值的项目的串联下，这些资源都是可以争取到的。\n\n\n## 分享利益\n\n“无双赢，不合作”是我的一个信条，如果你让一个人做一件事，而他却从中毫无所得，那人家为啥有动力去把这个事情做好呢？！财聚人散，财散人聚，这是一个很简单的道理。\n\n因此想要最终实现管理的杠杆，让更多人有意愿发挥自己的比较优势，就应该想方设法让他们也能分到应得的利益。这里的利益并不一定是钱，也可以是荣誉、机会、人际关系等等。\n\n在推进导师制的过程中，我对新晋导师进行培训的时候就开门见山介绍了他们可能的一些获益：\n\n- 增强知识储备。能够做好一件事和能够传授一件事是有本质区别的，后者才能让你对这件事的理解再上一个层次，吃深吃透\n- 建立人际关系。我们招到的都是非常优秀的工程师，相对而言新人可能在经验方法上欠缺一些，但是都足够有智慧，相互的切磋和沟通，可以深化“亦师亦友”的良好关系\n- 培养管理能力。很多人走上管理岗的第一步都是从做导师开始的，通过指导新人帮助他们快速成长，能够实践和掌握诸如预期管理、沟通、激励反馈等基本的管理技能\n\n后来事实上因为团队发展很快，很大一部分早期的导师都慢慢开始带更大规模的团队，获得收入、成长、人脉上的多丰收。\n\n关于利益我的一个体会是：**更多着眼在能力成长这些本源上，它们并非物质利益但会带来物质利益**。一旦我们把合作关系庸俗化，弄成赤裸裸的金钱利益共同体，就可能会产生短视、腐败等问题。能力提升才是最根本的。\n\n\n## 小结\n\n教员曾经说过：所谓政治，就是把我们的人搞得多多的，把敌人搞得少少的。虽然管理并非政治，但有些思路是相通的。\n只有解放群众，发动群众，不断通过改造生产关系来释放和发展生产力，才能激发出团队的最大潜能，实现组织的可持续的成功。\n这其中，通过注入使命让大家有明确方向和一定灵活度，通过盘活资源让各类型要素流通协作，通过分享利益让大家真的有所得从而更有积极性和认同感，环环相扣，紧密联系，对于杠杆的有效发挥至关重要。\n管理方面我虽然不是新兵，但也还在摸索前进。如果你有更多的想法，欢迎约饭交流。\n","slug":"management-lever","published":1,"updated":"2022-08-13T01:52:17.954Z","_id":"cl6r86mkw0000fcei7ptx3asi","comments":1,"photos":[],"link":"","content":"<p>最近听到有朋友说我比较善于使用管理的杠杆，顿觉旁观者清。坦白来说，我自己虽然在日常实践中有意无意地应用类似的思想，却还未有明确的这方面的总结和提炼。\n当时就萌生了写一篇文章来整理的想法。如今终于起笔，文中所言不一定对各位管理者有实际裨益，不过也权当是兼听则明吧。</p>\n<p>一位好的管理者，在我理解来看，应当是一个 Multiplier，能够将大家的优势有效地发挥出来，形成合力，进而完成整个组织不断进阶的目标。\n我一直相信群体的力量远胜于少数核心人物的智慧。为了更好地激发大家的主观能动性，用好管理的杠杆，下面介绍几点我自己的思考。</p>\n<h2 id=\"注入使命\"><a href=\"#注入使命\" class=\"headerlink\" title=\"注入使命\"></a>注入使命</h2><blockquote>\n<p>If you want to build a ship，don’t drum up people to collect wood and don’t assign them tasks and work, but rather long for the endless immensity of sea.\n如果你想造一艘船，先不要雇人收集木头，也不要给人分配任务，而是激发他们对海洋的渴望。</p>\n</blockquote>\n<p>当一个项目需要一群人来完成时，我们可以有不同的方式来进行项目的启动：</p>\n<ol>\n<li>只介绍这个项目要做的具体事项</li>\n<li>介绍项目的优先目标以及实施方案</li>\n<li>介绍项目的背景、优先目标以及和公司整体战略的联系，并鼓励大家献计献策，通过沟通协作逐步确定具体方案</li>\n</ol>\n<span id=\"more\"></span>\n\n<p>第一种方式在很多公司都非常常见，大家都是公司雇员，拿钱办事，既然上面老板们决定要做那就没啥可讨论的，干就完了。\n第二种方式相较而言，会跟大家分享项目想要解决的核心问题，这样一个好处是大家有了更明确的方向，这样就为调动大家积极性、激发大家审视和改良现有的实施方案提供了很大空间，对于有效完成项目目标有非常正面的意义。\n第三种方案在两个点上做的更进一步：一方面会讲清楚项目对于公司的关键作用，有助于大家理解这一项目在哪些层面对于公司的进一步发展至关重要。另一方面也提高了大家的参与感，具体方案的确定是通过沟通协作来完成的，这样的方案也往往更接地气，在效率和成本方面都能做到非常出色。</p>\n<p>在平时的实践中，我非常有意识地在用第三种方式来为一个事情注入使命，并在前期沟通中不断和利益攸关方沟通以凝聚共识。</p>\n<p>以确立新人培训流程这个项目为例：</p>\n<ul>\n<li>项目的核心价值是帮助新人快速融入团队并为后续发挥战斗力打好基础，具体包括了解各团队的人和事，以及公司发展过程、产品演变历史、团队文化等内容</li>\n<li>跟相关老大们协调一致后，在和各个团队骨干讲师的沟通中，着重强调的是这件事对于新人和公司的重大价值：公司的发展最核心的动力在于人，而让源源不断的新人快速适应和融入团队，对于传承优秀的团队文化和打造一支精英团队至关重要</li>\n<li>后续的流程推进中，能够明显感觉到各位讲师在培训上投入很多，包括内容准备、讲解技巧等等方面，他们也通过培训更多地了解和认识了很多新人</li>\n</ul>\n<p>类似的例子还有很多，大到公司的一些核心项目，小到一次外出团建，我们都会竭尽所能地将其背后的重要意义跟大家阐释出来。</p>\n<p>我能明显感觉到具有使命感与否所产生的巨大差异，目标明确且有信念的人常常让你眼前一亮，他们不仅会主动找到更优的方案，而且在面对困难时也百折不挠，使命必达。\n这也让我深刻认识到另一个道理：<strong>注入使命才会催发主人翁精神</strong>，之后的事情就变得简单起来，不需要那么多的微观管理。</p>\n<h2 id=\"盘活资源\"><a href=\"#盘活资源\" class=\"headerlink\" title=\"盘活资源\"></a>盘活资源</h2><p>南水北调、西气东输、精准扶贫等祖国大地上发生的重大项目都体现出了盘活资源的重要意义。和国家治理类似，管理杠杆的另一个重点是合理地利用好手里的资源，这里的资源包括人、项目、资金、活动等等，当然最重要的还是人。</p>\n<p>盘活资源在我理解有以下几个点：</p>\n<ul>\n<li>首先要能够识别出能够在某方面能够有所作为的资源。就人而言，有人擅长社交，有人擅长分析，有人演讲特别有感染力，有人观察细致入微，这些都是他们的一些特质，将来可能能够为团队所用</li>\n<li>推进一个项目时，尽量从“能不能不做 -&gt; 能不能以后做 -&gt; 能不能别人做 -&gt; 自己做”这一逻辑出发，优先选派有相对优势的同事而非自己亲力亲为，以此来秣马厉兵，培养和发展人才</li>\n<li>鉴于项目初期可能同事之间还没那么熟悉，同时也可能有一些重要决策需要有人来背书，可以“扶上马，送一程”，然后只做一些咨询类的支持</li>\n</ul>\n<p>以我们一个内部分享会 Tubi Talent Time 的组织为例，最初团队比较小的时候，还主要是我来具体负责协调。后来团队成长到一定规模，原来的模式频频出现各种问题，包括轮值主持人找不到讲师、讲师内容准备不够充分、缺乏反馈渠道等等。\n为了更好地解决这些问题，我们就从各个团队选了一些热衷于分享的同事，组建了一个新的委员会专门负责分享会的运作。大家勠力同心，不仅帮忙收集了很多潜在分享内容，而且在很多方面将分享活动的组织进一步优化，目前已经取得了超出我预期的进展。</p>\n<p>我有一个很深的体会是：<strong>你能调动的资源往往比你想象的要多</strong>。甚至不光所有下属，其实你的上级、平级和其他有合作的部门都是非常重要的潜在资源。在一个非常有价值的项目的串联下，这些资源都是可以争取到的。</p>\n<h2 id=\"分享利益\"><a href=\"#分享利益\" class=\"headerlink\" title=\"分享利益\"></a>分享利益</h2><p>“无双赢，不合作”是我的一个信条，如果你让一个人做一件事，而他却从中毫无所得，那人家为啥有动力去把这个事情做好呢？！财聚人散，财散人聚，这是一个很简单的道理。</p>\n<p>因此想要最终实现管理的杠杆，让更多人有意愿发挥自己的比较优势，就应该想方设法让他们也能分到应得的利益。这里的利益并不一定是钱，也可以是荣誉、机会、人际关系等等。</p>\n<p>在推进导师制的过程中，我对新晋导师进行培训的时候就开门见山介绍了他们可能的一些获益：</p>\n<ul>\n<li>增强知识储备。能够做好一件事和能够传授一件事是有本质区别的，后者才能让你对这件事的理解再上一个层次，吃深吃透</li>\n<li>建立人际关系。我们招到的都是非常优秀的工程师，相对而言新人可能在经验方法上欠缺一些，但是都足够有智慧，相互的切磋和沟通，可以深化“亦师亦友”的良好关系</li>\n<li>培养管理能力。很多人走上管理岗的第一步都是从做导师开始的，通过指导新人帮助他们快速成长，能够实践和掌握诸如预期管理、沟通、激励反馈等基本的管理技能</li>\n</ul>\n<p>后来事实上因为团队发展很快，很大一部分早期的导师都慢慢开始带更大规模的团队，获得收入、成长、人脉上的多丰收。</p>\n<p>关于利益我的一个体会是：<strong>更多着眼在能力成长这些本源上，它们并非物质利益但会带来物质利益</strong>。一旦我们把合作关系庸俗化，弄成赤裸裸的金钱利益共同体，就可能会产生短视、腐败等问题。能力提升才是最根本的。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>教员曾经说过：所谓政治，就是把我们的人搞得多多的，把敌人搞得少少的。虽然管理并非政治，但有些思路是相通的。\n只有解放群众，发动群众，不断通过改造生产关系来释放和发展生产力，才能激发出团队的最大潜能，实现组织的可持续的成功。\n这其中，通过注入使命让大家有明确方向和一定灵活度，通过盘活资源让各类型要素流通协作，通过分享利益让大家真的有所得从而更有积极性和认同感，环环相扣，紧密联系，对于杠杆的有效发挥至关重要。\n管理方面我虽然不是新兵，但也还在摸索前进。如果你有更多的想法，欢迎约饭交流。</p>\n","site":{"data":{}},"excerpt":"<p>最近听到有朋友说我比较善于使用管理的杠杆，顿觉旁观者清。坦白来说，我自己虽然在日常实践中有意无意地应用类似的思想，却还未有明确的这方面的总结和提炼。\n当时就萌生了写一篇文章来整理的想法。如今终于起笔，文中所言不一定对各位管理者有实际裨益，不过也权当是兼听则明吧。</p>\n<p>一位好的管理者，在我理解来看，应当是一个 Multiplier，能够将大家的优势有效地发挥出来，形成合力，进而完成整个组织不断进阶的目标。\n我一直相信群体的力量远胜于少数核心人物的智慧。为了更好地激发大家的主观能动性，用好管理的杠杆，下面介绍几点我自己的思考。</p>\n<h2 id=\"注入使命\"><a href=\"#注入使命\" class=\"headerlink\" title=\"注入使命\"></a>注入使命</h2><blockquote>\n<p>If you want to build a ship，don’t drum up people to collect wood and don’t assign them tasks and work, but rather long for the endless immensity of sea.\n如果你想造一艘船，先不要雇人收集木头，也不要给人分配任务，而是激发他们对海洋的渴望。</p>\n</blockquote>\n<p>当一个项目需要一群人来完成时，我们可以有不同的方式来进行项目的启动：</p>\n<ol>\n<li>只介绍这个项目要做的具体事项</li>\n<li>介绍项目的优先目标以及实施方案</li>\n<li>介绍项目的背景、优先目标以及和公司整体战略的联系，并鼓励大家献计献策，通过沟通协作逐步确定具体方案</li>\n</ol>","more":"<p>第一种方式在很多公司都非常常见，大家都是公司雇员，拿钱办事，既然上面老板们决定要做那就没啥可讨论的，干就完了。\n第二种方式相较而言，会跟大家分享项目想要解决的核心问题，这样一个好处是大家有了更明确的方向，这样就为调动大家积极性、激发大家审视和改良现有的实施方案提供了很大空间，对于有效完成项目目标有非常正面的意义。\n第三种方案在两个点上做的更进一步：一方面会讲清楚项目对于公司的关键作用，有助于大家理解这一项目在哪些层面对于公司的进一步发展至关重要。另一方面也提高了大家的参与感，具体方案的确定是通过沟通协作来完成的，这样的方案也往往更接地气，在效率和成本方面都能做到非常出色。</p>\n<p>在平时的实践中，我非常有意识地在用第三种方式来为一个事情注入使命，并在前期沟通中不断和利益攸关方沟通以凝聚共识。</p>\n<p>以确立新人培训流程这个项目为例：</p>\n<ul>\n<li>项目的核心价值是帮助新人快速融入团队并为后续发挥战斗力打好基础，具体包括了解各团队的人和事，以及公司发展过程、产品演变历史、团队文化等内容</li>\n<li>跟相关老大们协调一致后，在和各个团队骨干讲师的沟通中，着重强调的是这件事对于新人和公司的重大价值：公司的发展最核心的动力在于人，而让源源不断的新人快速适应和融入团队，对于传承优秀的团队文化和打造一支精英团队至关重要</li>\n<li>后续的流程推进中，能够明显感觉到各位讲师在培训上投入很多，包括内容准备、讲解技巧等等方面，他们也通过培训更多地了解和认识了很多新人</li>\n</ul>\n<p>类似的例子还有很多，大到公司的一些核心项目，小到一次外出团建，我们都会竭尽所能地将其背后的重要意义跟大家阐释出来。</p>\n<p>我能明显感觉到具有使命感与否所产生的巨大差异，目标明确且有信念的人常常让你眼前一亮，他们不仅会主动找到更优的方案，而且在面对困难时也百折不挠，使命必达。\n这也让我深刻认识到另一个道理：<strong>注入使命才会催发主人翁精神</strong>，之后的事情就变得简单起来，不需要那么多的微观管理。</p>\n<h2 id=\"盘活资源\"><a href=\"#盘活资源\" class=\"headerlink\" title=\"盘活资源\"></a>盘活资源</h2><p>南水北调、西气东输、精准扶贫等祖国大地上发生的重大项目都体现出了盘活资源的重要意义。和国家治理类似，管理杠杆的另一个重点是合理地利用好手里的资源，这里的资源包括人、项目、资金、活动等等，当然最重要的还是人。</p>\n<p>盘活资源在我理解有以下几个点：</p>\n<ul>\n<li>首先要能够识别出能够在某方面能够有所作为的资源。就人而言，有人擅长社交，有人擅长分析，有人演讲特别有感染力，有人观察细致入微，这些都是他们的一些特质，将来可能能够为团队所用</li>\n<li>推进一个项目时，尽量从“能不能不做 -&gt; 能不能以后做 -&gt; 能不能别人做 -&gt; 自己做”这一逻辑出发，优先选派有相对优势的同事而非自己亲力亲为，以此来秣马厉兵，培养和发展人才</li>\n<li>鉴于项目初期可能同事之间还没那么熟悉，同时也可能有一些重要决策需要有人来背书，可以“扶上马，送一程”，然后只做一些咨询类的支持</li>\n</ul>\n<p>以我们一个内部分享会 Tubi Talent Time 的组织为例，最初团队比较小的时候，还主要是我来具体负责协调。后来团队成长到一定规模，原来的模式频频出现各种问题，包括轮值主持人找不到讲师、讲师内容准备不够充分、缺乏反馈渠道等等。\n为了更好地解决这些问题，我们就从各个团队选了一些热衷于分享的同事，组建了一个新的委员会专门负责分享会的运作。大家勠力同心，不仅帮忙收集了很多潜在分享内容，而且在很多方面将分享活动的组织进一步优化，目前已经取得了超出我预期的进展。</p>\n<p>我有一个很深的体会是：<strong>你能调动的资源往往比你想象的要多</strong>。甚至不光所有下属，其实你的上级、平级和其他有合作的部门都是非常重要的潜在资源。在一个非常有价值的项目的串联下，这些资源都是可以争取到的。</p>\n<h2 id=\"分享利益\"><a href=\"#分享利益\" class=\"headerlink\" title=\"分享利益\"></a>分享利益</h2><p>“无双赢，不合作”是我的一个信条，如果你让一个人做一件事，而他却从中毫无所得，那人家为啥有动力去把这个事情做好呢？！财聚人散，财散人聚，这是一个很简单的道理。</p>\n<p>因此想要最终实现管理的杠杆，让更多人有意愿发挥自己的比较优势，就应该想方设法让他们也能分到应得的利益。这里的利益并不一定是钱，也可以是荣誉、机会、人际关系等等。</p>\n<p>在推进导师制的过程中，我对新晋导师进行培训的时候就开门见山介绍了他们可能的一些获益：</p>\n<ul>\n<li>增强知识储备。能够做好一件事和能够传授一件事是有本质区别的，后者才能让你对这件事的理解再上一个层次，吃深吃透</li>\n<li>建立人际关系。我们招到的都是非常优秀的工程师，相对而言新人可能在经验方法上欠缺一些，但是都足够有智慧，相互的切磋和沟通，可以深化“亦师亦友”的良好关系</li>\n<li>培养管理能力。很多人走上管理岗的第一步都是从做导师开始的，通过指导新人帮助他们快速成长，能够实践和掌握诸如预期管理、沟通、激励反馈等基本的管理技能</li>\n</ul>\n<p>后来事实上因为团队发展很快，很大一部分早期的导师都慢慢开始带更大规模的团队，获得收入、成长、人脉上的多丰收。</p>\n<p>关于利益我的一个体会是：<strong>更多着眼在能力成长这些本源上，它们并非物质利益但会带来物质利益</strong>。一旦我们把合作关系庸俗化，弄成赤裸裸的金钱利益共同体，就可能会产生短视、腐败等问题。能力提升才是最根本的。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>教员曾经说过：所谓政治，就是把我们的人搞得多多的，把敌人搞得少少的。虽然管理并非政治，但有些思路是相通的。\n只有解放群众，发动群众，不断通过改造生产关系来释放和发展生产力，才能激发出团队的最大潜能，实现组织的可持续的成功。\n这其中，通过注入使命让大家有明确方向和一定灵活度，通过盘活资源让各类型要素流通协作，通过分享利益让大家真的有所得从而更有积极性和认同感，环环相扣，紧密联系，对于杠杆的有效发挥至关重要。\n管理方面我虽然不是新兵，但也还在摸索前进。如果你有更多的想法，欢迎约饭交流。</p>"},{"layout":"post","title":"带着“答案”去提问","date":"2023-05-30T13:50:00.000Z","status":"publish","_content":"\n\n\n\n前几天，一位美国团队的负责人跟我谈到了他团队里的两位工程师。其中一个工程师每周和他一对一沟通的时候都提出了好几个技术性的问题，诸如：\n\n- 调试过程中发现本地环境遇到一个错误跑不起来\n- 在测试环境下面各种参数如何调节\n- 压力测试中发现的一些新的不及预期的现象\n\n如此等等。总结下来，他感觉这位高级工程师更像是一个 Problem Maker，在不断地需要他介入到特别细枝末节的地方，给出具体的意见后才能进一步开展工作。\n\n相比之下，另一位工程师则会在一对一沟通中除了汇报主要进展外，也会提出一两个接下来需要重点关注的问题。不同的是，那位工程师除了抛出问题外，还会提出几个他考虑到的可行性方案，并虚心跟他讨教。这位负责人笑着跟我说这样的团队成员才是他心目中称职的“高级”工程师，是典型的 Problem Solver。\n\n这个案例彰显出“带着答案去提问”的重要价值，尤其在远程协作或者大型组织等沟通渠道弥足珍贵的环境中，这种能力更值得重视和培养。接下来我们从几个方面阐释其中的内涵。\n\n\n## 答案让问题变得更完整\n\n在提问问题时，提供可能的答案可以帮助澄清问题的意图，并给出更为清晰的上下文。例如，假设你想问一个关于旅行目的地的问题：“我应该去哪里旅行？”如果你只问这个问题而没有提供任何上下文，对方可能会很难给出有用的建议。但如果你提供了一些可能的答案，如：“我正在考虑去巴黎、东京或者悉尼旅行”，那么回答者就可以更好地理解你的兴趣和偏好，并给出更具针对性的建议。\n\n在技术性问题中也是类似的，如果只是说“我们应不应该在这个项目中使用 React Query？”那么对方并不知道你是建议使用这个工具，还是看到一些现有方案的问题所以在考虑一些业界流行的方案，还是有什么其他意图。但如果换成“我们应不应该在这个项目中使用 React Query？我发现这个内部系统里其实主要的客户端状态都和服务器数据交互相关，这种场景 Redux 显得臃肿了，看起来 React Query 是一个更好的选择，另外一个我了解到的方案是比较轻量级的 SWR”，估计对方就会很快领会你的问题是觉得 React Query 以及 SWR 这类新兴工具可以更好地处理服务器数据交互类场景。\n\n\n## 抛砖引玉提升沟通效率\n\n在提问时准备的“答案”并不需要是最优的，它们更像是大海中的一座座灯塔，指明大致的方向即可，可以为对方提供一些参考，避免回答重复或不相关的信息，并促进进一步的讨论。\n\n举一个简单的例子：小张在开发一个新功能的时候，发现需要用到的一个工具函数已经有多个版本的实现了，它们有些略微差异但是本质上可以通过一个通用方法解决。然后他去组里跟大家说：“我们代码仓库 xxx、yyy、zzz 这几个方法重复了，我们能不能重构下？”\n\n在另外一个平行时空，面对同样的问题，小李做了一些简单的分析后，是这样跟大家沟通的：“最近我在开发一个新项目的时候，发现已经有 xxx、yyy、zzz 都用来处理数据分组问题了。我简单看了下它们各自的实现，其实是可以通过传递一些参数来整合为一个方法，重构完能减少上百行代码。或者也可以考虑直接使用一个流行的开源工具库里的 groupBy 方法。我目前想到这两个办法，权当抛砖引玉，大家一起看看怎么解决比较好呢？”\n\n对比两种方式，明显第二种信息量要多出很多。相信如果你是他们团队中的一员，看到小张的问题你会觉得这几个方法可能有问题，但是还得实际看一看。但看到小李的描述，你应该大概已经知道这几个方法大概率是不同人不同时期添加的，属于技术债务。而且看起来引入一个比较标准的工具库会是一个更好的方案。当然，进一步可以去分析为什么这些工具函数会出现如此多的重复，是不是因为缺乏文档、缺乏规范等等。\n\n除了提供更为丰富的信息，与问题相互印证之外，这些解决方案也提供了借鉴意义，让大家的讨论不再是天马行空，而是有了基本的“锚”，话题会围绕这几个方案的优缺点逐步展开，甚至往往能够引申出更加合理的新方案。这里其实是有一点心理学的概念的，做选择往往比给答案更容易，而且更有启发性。在《程序员修炼之道》中有一个“石头汤”的故事，本质也是类似的。\n\n抛砖引玉，有的放矢，最终达成的效果是大家可以更有效地沟通，进而更快地达成共识，促进产出。\n\n\n## 主动思考带来更多成长\n\n发现问题是第一步，能够主动思考并提出有效方案是更高能力的体现，是第二步。相比较而言，这种意识的培养比技术的提升更容易，但效果却出乎意料地好，可谓极具性价比。初期的“答案”可能有些初级，但你的沟通对象至少会认为你非常负责任，也对他们足够尊重，做了一些功课才来请教他们。随着这种思维模式的贯彻和深入，你会找到更多有效的办法去寻找更优的方案，例如先与团队里的领域专家沟通、使用 ChatGPT 咨询建议、进行 PoC 进行简单验证等等。日积月累，你可能就会进入第三步：给出各个方案的优缺点，并陈述你的推荐方案以及理由，这足以表明你已经具备了一定的判断力和决策能力。上级和同事们看到你积极参与和贡献解决问题的能力，会加强对你的信任和认可，从而获得更大的发展空间。\n\n换个角度来看，实际上带着答案去提问本质上是站在对方的角度去考虑问题，甚至是站在团队负责人或上级的角度去综合评估最优解。这种格局带来的提升动力非常强劲，对个人能力的全方面提升相当重要。\n\n\n## 小结\n\n在遇到一个新问题时，直接将问题抛出去既不专业也不负责。其他人可能会感到一头雾水，因为缺乏一些关键信息云里雾里。如果其他人发现这个问题其实行业内或团队内之前曾有过经验，或者认为提问者完全有足够能力搞定，也会降低对提问者的信任度。相反，如果每次遇到一个新问题都能够主动思考，准备一些初步的思路甚至解决方案，往往会给对方如遇春风的感觉，有助于快速达成共识。更重要的是，这种思维方式能够提升一个人的格局，为后续的发展进步奠定更为坚实的基础。\n\n\n## 参考资料\n\n- [在职场，有问题该怎么提问？](https://36kr.com/p/1953327724501128)\n- [这样提问，你不可能得到想要的答案！](https://www.woshipm.com/zhichang/4239783.html)\n- [有效提问 - 鸟哥笔记](https://www.niaogebiji.com/article-33854-1.html)\n- [提问的智慧](http://cripac.ia.ac.cn/people/wwang/post/how-to-ask-questions-the-smart-way/)\n- [带着答案问问题](https://wenku.baidu.com/view/a8de92b352e79b89680203d8ce2f0066f5336483.html)\n","source":"_posts/ask-with-answers.md","raw":"---\nlayout: post\ntitle: 带着“答案”去提问\ndate: 2023-05-30 21:50:00\nstatus: publish\ntags:\n  - Communication\n  - Asking\n---\n\n\n\n\n前几天，一位美国团队的负责人跟我谈到了他团队里的两位工程师。其中一个工程师每周和他一对一沟通的时候都提出了好几个技术性的问题，诸如：\n\n- 调试过程中发现本地环境遇到一个错误跑不起来\n- 在测试环境下面各种参数如何调节\n- 压力测试中发现的一些新的不及预期的现象\n\n如此等等。总结下来，他感觉这位高级工程师更像是一个 Problem Maker，在不断地需要他介入到特别细枝末节的地方，给出具体的意见后才能进一步开展工作。\n\n相比之下，另一位工程师则会在一对一沟通中除了汇报主要进展外，也会提出一两个接下来需要重点关注的问题。不同的是，那位工程师除了抛出问题外，还会提出几个他考虑到的可行性方案，并虚心跟他讨教。这位负责人笑着跟我说这样的团队成员才是他心目中称职的“高级”工程师，是典型的 Problem Solver。\n\n这个案例彰显出“带着答案去提问”的重要价值，尤其在远程协作或者大型组织等沟通渠道弥足珍贵的环境中，这种能力更值得重视和培养。接下来我们从几个方面阐释其中的内涵。\n\n\n## 答案让问题变得更完整\n\n在提问问题时，提供可能的答案可以帮助澄清问题的意图，并给出更为清晰的上下文。例如，假设你想问一个关于旅行目的地的问题：“我应该去哪里旅行？”如果你只问这个问题而没有提供任何上下文，对方可能会很难给出有用的建议。但如果你提供了一些可能的答案，如：“我正在考虑去巴黎、东京或者悉尼旅行”，那么回答者就可以更好地理解你的兴趣和偏好，并给出更具针对性的建议。\n\n在技术性问题中也是类似的，如果只是说“我们应不应该在这个项目中使用 React Query？”那么对方并不知道你是建议使用这个工具，还是看到一些现有方案的问题所以在考虑一些业界流行的方案，还是有什么其他意图。但如果换成“我们应不应该在这个项目中使用 React Query？我发现这个内部系统里其实主要的客户端状态都和服务器数据交互相关，这种场景 Redux 显得臃肿了，看起来 React Query 是一个更好的选择，另外一个我了解到的方案是比较轻量级的 SWR”，估计对方就会很快领会你的问题是觉得 React Query 以及 SWR 这类新兴工具可以更好地处理服务器数据交互类场景。\n\n\n## 抛砖引玉提升沟通效率\n\n在提问时准备的“答案”并不需要是最优的，它们更像是大海中的一座座灯塔，指明大致的方向即可，可以为对方提供一些参考，避免回答重复或不相关的信息，并促进进一步的讨论。\n\n举一个简单的例子：小张在开发一个新功能的时候，发现需要用到的一个工具函数已经有多个版本的实现了，它们有些略微差异但是本质上可以通过一个通用方法解决。然后他去组里跟大家说：“我们代码仓库 xxx、yyy、zzz 这几个方法重复了，我们能不能重构下？”\n\n在另外一个平行时空，面对同样的问题，小李做了一些简单的分析后，是这样跟大家沟通的：“最近我在开发一个新项目的时候，发现已经有 xxx、yyy、zzz 都用来处理数据分组问题了。我简单看了下它们各自的实现，其实是可以通过传递一些参数来整合为一个方法，重构完能减少上百行代码。或者也可以考虑直接使用一个流行的开源工具库里的 groupBy 方法。我目前想到这两个办法，权当抛砖引玉，大家一起看看怎么解决比较好呢？”\n\n对比两种方式，明显第二种信息量要多出很多。相信如果你是他们团队中的一员，看到小张的问题你会觉得这几个方法可能有问题，但是还得实际看一看。但看到小李的描述，你应该大概已经知道这几个方法大概率是不同人不同时期添加的，属于技术债务。而且看起来引入一个比较标准的工具库会是一个更好的方案。当然，进一步可以去分析为什么这些工具函数会出现如此多的重复，是不是因为缺乏文档、缺乏规范等等。\n\n除了提供更为丰富的信息，与问题相互印证之外，这些解决方案也提供了借鉴意义，让大家的讨论不再是天马行空，而是有了基本的“锚”，话题会围绕这几个方案的优缺点逐步展开，甚至往往能够引申出更加合理的新方案。这里其实是有一点心理学的概念的，做选择往往比给答案更容易，而且更有启发性。在《程序员修炼之道》中有一个“石头汤”的故事，本质也是类似的。\n\n抛砖引玉，有的放矢，最终达成的效果是大家可以更有效地沟通，进而更快地达成共识，促进产出。\n\n\n## 主动思考带来更多成长\n\n发现问题是第一步，能够主动思考并提出有效方案是更高能力的体现，是第二步。相比较而言，这种意识的培养比技术的提升更容易，但效果却出乎意料地好，可谓极具性价比。初期的“答案”可能有些初级，但你的沟通对象至少会认为你非常负责任，也对他们足够尊重，做了一些功课才来请教他们。随着这种思维模式的贯彻和深入，你会找到更多有效的办法去寻找更优的方案，例如先与团队里的领域专家沟通、使用 ChatGPT 咨询建议、进行 PoC 进行简单验证等等。日积月累，你可能就会进入第三步：给出各个方案的优缺点，并陈述你的推荐方案以及理由，这足以表明你已经具备了一定的判断力和决策能力。上级和同事们看到你积极参与和贡献解决问题的能力，会加强对你的信任和认可，从而获得更大的发展空间。\n\n换个角度来看，实际上带着答案去提问本质上是站在对方的角度去考虑问题，甚至是站在团队负责人或上级的角度去综合评估最优解。这种格局带来的提升动力非常强劲，对个人能力的全方面提升相当重要。\n\n\n## 小结\n\n在遇到一个新问题时，直接将问题抛出去既不专业也不负责。其他人可能会感到一头雾水，因为缺乏一些关键信息云里雾里。如果其他人发现这个问题其实行业内或团队内之前曾有过经验，或者认为提问者完全有足够能力搞定，也会降低对提问者的信任度。相反，如果每次遇到一个新问题都能够主动思考，准备一些初步的思路甚至解决方案，往往会给对方如遇春风的感觉，有助于快速达成共识。更重要的是，这种思维方式能够提升一个人的格局，为后续的发展进步奠定更为坚实的基础。\n\n\n## 参考资料\n\n- [在职场，有问题该怎么提问？](https://36kr.com/p/1953327724501128)\n- [这样提问，你不可能得到想要的答案！](https://www.woshipm.com/zhichang/4239783.html)\n- [有效提问 - 鸟哥笔记](https://www.niaogebiji.com/article-33854-1.html)\n- [提问的智慧](http://cripac.ia.ac.cn/people/wwang/post/how-to-ask-questions-the-smart-way/)\n- [带着答案问问题](https://wenku.baidu.com/view/a8de92b352e79b89680203d8ce2f0066f5336483.html)\n","slug":"ask-with-answers","published":1,"updated":"2023-05-30T14:16:57.616Z","_id":"clhgbdskr000059mael2ybdhi","comments":1,"photos":[],"link":"","content":"<p>前几天，一位美国团队的负责人跟我谈到了他团队里的两位工程师。其中一个工程师每周和他一对一沟通的时候都提出了好几个技术性的问题，诸如：</p>\n<ul>\n<li>调试过程中发现本地环境遇到一个错误跑不起来</li>\n<li>在测试环境下面各种参数如何调节</li>\n<li>压力测试中发现的一些新的不及预期的现象</li>\n</ul>\n<p>如此等等。总结下来，他感觉这位高级工程师更像是一个 Problem Maker，在不断地需要他介入到特别细枝末节的地方，给出具体的意见后才能进一步开展工作。</p>\n<p>相比之下，另一位工程师则会在一对一沟通中除了汇报主要进展外，也会提出一两个接下来需要重点关注的问题。不同的是，那位工程师除了抛出问题外，还会提出几个他考虑到的可行性方案，并虚心跟他讨教。这位负责人笑着跟我说这样的团队成员才是他心目中称职的“高级”工程师，是典型的 Problem Solver。</p>\n<p>这个案例彰显出“带着答案去提问”的重要价值，尤其在远程协作或者大型组织等沟通渠道弥足珍贵的环境中，这种能力更值得重视和培养。接下来我们从几个方面阐释其中的内涵。</p>\n<h2 id=\"答案让问题变得更完整\"><a href=\"#答案让问题变得更完整\" class=\"headerlink\" title=\"答案让问题变得更完整\"></a>答案让问题变得更完整</h2><p>在提问问题时，提供可能的答案可以帮助澄清问题的意图，并给出更为清晰的上下文。例如，假设你想问一个关于旅行目的地的问题：“我应该去哪里旅行？”如果你只问这个问题而没有提供任何上下文，对方可能会很难给出有用的建议。但如果你提供了一些可能的答案，如：“我正在考虑去巴黎、东京或者悉尼旅行”，那么回答者就可以更好地理解你的兴趣和偏好，并给出更具针对性的建议。</p>\n<p>在技术性问题中也是类似的，如果只是说“我们应不应该在这个项目中使用 React Query？”那么对方并不知道你是建议使用这个工具，还是看到一些现有方案的问题所以在考虑一些业界流行的方案，还是有什么其他意图。但如果换成“我们应不应该在这个项目中使用 React Query？我发现这个内部系统里其实主要的客户端状态都和服务器数据交互相关，这种场景 Redux 显得臃肿了，看起来 React Query 是一个更好的选择，另外一个我了解到的方案是比较轻量级的 SWR”，估计对方就会很快领会你的问题是觉得 React Query 以及 SWR 这类新兴工具可以更好地处理服务器数据交互类场景。</p>\n<h2 id=\"抛砖引玉提升沟通效率\"><a href=\"#抛砖引玉提升沟通效率\" class=\"headerlink\" title=\"抛砖引玉提升沟通效率\"></a>抛砖引玉提升沟通效率</h2><p>在提问时准备的“答案”并不需要是最优的，它们更像是大海中的一座座灯塔，指明大致的方向即可，可以为对方提供一些参考，避免回答重复或不相关的信息，并促进进一步的讨论。</p>\n<p>举一个简单的例子：小张在开发一个新功能的时候，发现需要用到的一个工具函数已经有多个版本的实现了，它们有些略微差异但是本质上可以通过一个通用方法解决。然后他去组里跟大家说：“我们代码仓库 xxx、yyy、zzz 这几个方法重复了，我们能不能重构下？”</p>\n<p>在另外一个平行时空，面对同样的问题，小李做了一些简单的分析后，是这样跟大家沟通的：“最近我在开发一个新项目的时候，发现已经有 xxx、yyy、zzz 都用来处理数据分组问题了。我简单看了下它们各自的实现，其实是可以通过传递一些参数来整合为一个方法，重构完能减少上百行代码。或者也可以考虑直接使用一个流行的开源工具库里的 groupBy 方法。我目前想到这两个办法，权当抛砖引玉，大家一起看看怎么解决比较好呢？”</p>\n<p>对比两种方式，明显第二种信息量要多出很多。相信如果你是他们团队中的一员，看到小张的问题你会觉得这几个方法可能有问题，但是还得实际看一看。但看到小李的描述，你应该大概已经知道这几个方法大概率是不同人不同时期添加的，属于技术债务。而且看起来引入一个比较标准的工具库会是一个更好的方案。当然，进一步可以去分析为什么这些工具函数会出现如此多的重复，是不是因为缺乏文档、缺乏规范等等。</p>\n<p>除了提供更为丰富的信息，与问题相互印证之外，这些解决方案也提供了借鉴意义，让大家的讨论不再是天马行空，而是有了基本的“锚”，话题会围绕这几个方案的优缺点逐步展开，甚至往往能够引申出更加合理的新方案。这里其实是有一点心理学的概念的，做选择往往比给答案更容易，而且更有启发性。在《程序员修炼之道》中有一个“石头汤”的故事，本质也是类似的。</p>\n<p>抛砖引玉，有的放矢，最终达成的效果是大家可以更有效地沟通，进而更快地达成共识，促进产出。</p>\n<h2 id=\"主动思考带来更多成长\"><a href=\"#主动思考带来更多成长\" class=\"headerlink\" title=\"主动思考带来更多成长\"></a>主动思考带来更多成长</h2><p>发现问题是第一步，能够主动思考并提出有效方案是更高能力的体现，是第二步。相比较而言，这种意识的培养比技术的提升更容易，但效果却出乎意料地好，可谓极具性价比。初期的“答案”可能有些初级，但你的沟通对象至少会认为你非常负责任，也对他们足够尊重，做了一些功课才来请教他们。随着这种思维模式的贯彻和深入，你会找到更多有效的办法去寻找更优的方案，例如先与团队里的领域专家沟通、使用 ChatGPT 咨询建议、进行 PoC 进行简单验证等等。日积月累，你可能就会进入第三步：给出各个方案的优缺点，并陈述你的推荐方案以及理由，这足以表明你已经具备了一定的判断力和决策能力。上级和同事们看到你积极参与和贡献解决问题的能力，会加强对你的信任和认可，从而获得更大的发展空间。</p>\n<p>换个角度来看，实际上带着答案去提问本质上是站在对方的角度去考虑问题，甚至是站在团队负责人或上级的角度去综合评估最优解。这种格局带来的提升动力非常强劲，对个人能力的全方面提升相当重要。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在遇到一个新问题时，直接将问题抛出去既不专业也不负责。其他人可能会感到一头雾水，因为缺乏一些关键信息云里雾里。如果其他人发现这个问题其实行业内或团队内之前曾有过经验，或者认为提问者完全有足够能力搞定，也会降低对提问者的信任度。相反，如果每次遇到一个新问题都能够主动思考，准备一些初步的思路甚至解决方案，往往会给对方如遇春风的感觉，有助于快速达成共识。更重要的是，这种思维方式能够提升一个人的格局，为后续的发展进步奠定更为坚实的基础。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://36kr.com/p/1953327724501128\">在职场，有问题该怎么提问？</a></li>\n<li><a href=\"https://www.woshipm.com/zhichang/4239783.html\">这样提问，你不可能得到想要的答案！</a></li>\n<li><a href=\"https://www.niaogebiji.com/article-33854-1.html\">有效提问 - 鸟哥笔记</a></li>\n<li><a href=\"http://cripac.ia.ac.cn/people/wwang/post/how-to-ask-questions-the-smart-way/\">提问的智慧</a></li>\n<li><a href=\"https://wenku.baidu.com/view/a8de92b352e79b89680203d8ce2f0066f5336483.html\">带着答案问问题</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天，一位美国团队的负责人跟我谈到了他团队里的两位工程师。其中一个工程师每周和他一对一沟通的时候都提出了好几个技术性的问题，诸如：</p>\n<ul>\n<li>调试过程中发现本地环境遇到一个错误跑不起来</li>\n<li>在测试环境下面各种参数如何调节</li>\n<li>压力测试中发现的一些新的不及预期的现象</li>\n</ul>\n<p>如此等等。总结下来，他感觉这位高级工程师更像是一个 Problem Maker，在不断地需要他介入到特别细枝末节的地方，给出具体的意见后才能进一步开展工作。</p>\n<p>相比之下，另一位工程师则会在一对一沟通中除了汇报主要进展外，也会提出一两个接下来需要重点关注的问题。不同的是，那位工程师除了抛出问题外，还会提出几个他考虑到的可行性方案，并虚心跟他讨教。这位负责人笑着跟我说这样的团队成员才是他心目中称职的“高级”工程师，是典型的 Problem Solver。</p>\n<p>这个案例彰显出“带着答案去提问”的重要价值，尤其在远程协作或者大型组织等沟通渠道弥足珍贵的环境中，这种能力更值得重视和培养。接下来我们从几个方面阐释其中的内涵。</p>\n<h2 id=\"答案让问题变得更完整\"><a href=\"#答案让问题变得更完整\" class=\"headerlink\" title=\"答案让问题变得更完整\"></a>答案让问题变得更完整</h2><p>在提问问题时，提供可能的答案可以帮助澄清问题的意图，并给出更为清晰的上下文。例如，假设你想问一个关于旅行目的地的问题：“我应该去哪里旅行？”如果你只问这个问题而没有提供任何上下文，对方可能会很难给出有用的建议。但如果你提供了一些可能的答案，如：“我正在考虑去巴黎、东京或者悉尼旅行”，那么回答者就可以更好地理解你的兴趣和偏好，并给出更具针对性的建议。</p>\n<p>在技术性问题中也是类似的，如果只是说“我们应不应该在这个项目中使用 React Query？”那么对方并不知道你是建议使用这个工具，还是看到一些现有方案的问题所以在考虑一些业界流行的方案，还是有什么其他意图。但如果换成“我们应不应该在这个项目中使用 React Query？我发现这个内部系统里其实主要的客户端状态都和服务器数据交互相关，这种场景 Redux 显得臃肿了，看起来 React Query 是一个更好的选择，另外一个我了解到的方案是比较轻量级的 SWR”，估计对方就会很快领会你的问题是觉得 React Query 以及 SWR 这类新兴工具可以更好地处理服务器数据交互类场景。</p>\n<h2 id=\"抛砖引玉提升沟通效率\"><a href=\"#抛砖引玉提升沟通效率\" class=\"headerlink\" title=\"抛砖引玉提升沟通效率\"></a>抛砖引玉提升沟通效率</h2><p>在提问时准备的“答案”并不需要是最优的，它们更像是大海中的一座座灯塔，指明大致的方向即可，可以为对方提供一些参考，避免回答重复或不相关的信息，并促进进一步的讨论。</p>\n<p>举一个简单的例子：小张在开发一个新功能的时候，发现需要用到的一个工具函数已经有多个版本的实现了，它们有些略微差异但是本质上可以通过一个通用方法解决。然后他去组里跟大家说：“我们代码仓库 xxx、yyy、zzz 这几个方法重复了，我们能不能重构下？”</p>\n<p>在另外一个平行时空，面对同样的问题，小李做了一些简单的分析后，是这样跟大家沟通的：“最近我在开发一个新项目的时候，发现已经有 xxx、yyy、zzz 都用来处理数据分组问题了。我简单看了下它们各自的实现，其实是可以通过传递一些参数来整合为一个方法，重构完能减少上百行代码。或者也可以考虑直接使用一个流行的开源工具库里的 groupBy 方法。我目前想到这两个办法，权当抛砖引玉，大家一起看看怎么解决比较好呢？”</p>\n<p>对比两种方式，明显第二种信息量要多出很多。相信如果你是他们团队中的一员，看到小张的问题你会觉得这几个方法可能有问题，但是还得实际看一看。但看到小李的描述，你应该大概已经知道这几个方法大概率是不同人不同时期添加的，属于技术债务。而且看起来引入一个比较标准的工具库会是一个更好的方案。当然，进一步可以去分析为什么这些工具函数会出现如此多的重复，是不是因为缺乏文档、缺乏规范等等。</p>\n<p>除了提供更为丰富的信息，与问题相互印证之外，这些解决方案也提供了借鉴意义，让大家的讨论不再是天马行空，而是有了基本的“锚”，话题会围绕这几个方案的优缺点逐步展开，甚至往往能够引申出更加合理的新方案。这里其实是有一点心理学的概念的，做选择往往比给答案更容易，而且更有启发性。在《程序员修炼之道》中有一个“石头汤”的故事，本质也是类似的。</p>\n<p>抛砖引玉，有的放矢，最终达成的效果是大家可以更有效地沟通，进而更快地达成共识，促进产出。</p>\n<h2 id=\"主动思考带来更多成长\"><a href=\"#主动思考带来更多成长\" class=\"headerlink\" title=\"主动思考带来更多成长\"></a>主动思考带来更多成长</h2><p>发现问题是第一步，能够主动思考并提出有效方案是更高能力的体现，是第二步。相比较而言，这种意识的培养比技术的提升更容易，但效果却出乎意料地好，可谓极具性价比。初期的“答案”可能有些初级，但你的沟通对象至少会认为你非常负责任，也对他们足够尊重，做了一些功课才来请教他们。随着这种思维模式的贯彻和深入，你会找到更多有效的办法去寻找更优的方案，例如先与团队里的领域专家沟通、使用 ChatGPT 咨询建议、进行 PoC 进行简单验证等等。日积月累，你可能就会进入第三步：给出各个方案的优缺点，并陈述你的推荐方案以及理由，这足以表明你已经具备了一定的判断力和决策能力。上级和同事们看到你积极参与和贡献解决问题的能力，会加强对你的信任和认可，从而获得更大的发展空间。</p>\n<p>换个角度来看，实际上带着答案去提问本质上是站在对方的角度去考虑问题，甚至是站在团队负责人或上级的角度去综合评估最优解。这种格局带来的提升动力非常强劲，对个人能力的全方面提升相当重要。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在遇到一个新问题时，直接将问题抛出去既不专业也不负责。其他人可能会感到一头雾水，因为缺乏一些关键信息云里雾里。如果其他人发现这个问题其实行业内或团队内之前曾有过经验，或者认为提问者完全有足够能力搞定，也会降低对提问者的信任度。相反，如果每次遇到一个新问题都能够主动思考，准备一些初步的思路甚至解决方案，往往会给对方如遇春风的感觉，有助于快速达成共识。更重要的是，这种思维方式能够提升一个人的格局，为后续的发展进步奠定更为坚实的基础。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://36kr.com/p/1953327724501128\">在职场，有问题该怎么提问？</a></li>\n<li><a href=\"https://www.woshipm.com/zhichang/4239783.html\">这样提问，你不可能得到想要的答案！</a></li>\n<li><a href=\"https://www.niaogebiji.com/article-33854-1.html\">有效提问 - 鸟哥笔记</a></li>\n<li><a href=\"http://cripac.ia.ac.cn/people/wwang/post/how-to-ask-questions-the-smart-way/\">提问的智慧</a></li>\n<li><a href=\"https://wenku.baidu.com/view/a8de92b352e79b89680203d8ce2f0066f5336483.html\">带着答案问问题</a></li>\n</ul>\n"},{"layout":"post","title":"基于 Context 做 React 状态管理","date":"2023-03-09T01:12:00.000Z","status":"publish","_content":"\n请移步知乎“前端之美”专栏 [基于 Context 做 React 状态管理](https://zhuanlan.zhihu.com/p/607970423) 查看全文。\n","source":"_posts/react-context.md","raw":"---\nlayout: post\ntitle: \"基于 Context 做 React 状态管理\"\ndate: 2023-03-09 09:12\nstatus: publish\ntags: [React, Context, useContextSelector]\n---\n\n请移步知乎“前端之美”专栏 [基于 Context 做 React 状态管理](https://zhuanlan.zhihu.com/p/607970423) 查看全文。\n","slug":"react-context","published":1,"updated":"2023-05-30T14:40:42.936Z","comments":1,"photos":[],"link":"","_id":"cliadyvpj0000qfmacexv5cnh","content":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/607970423\">基于 Context 做 React 状态管理</a> 查看全文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>请移步知乎“前端之美”专栏 <a href=\"https://zhuanlan.zhihu.com/p/607970423\">基于 Context 做 React 状态管理</a> 查看全文。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl1klgup100018e853wvtdzqz","tag_id":"cl1klgup600038e85d0jpagls","_id":"cl1klgupf000c8e85a0xjc85w"},{"post_id":"cl1klgup100018e853wvtdzqz","tag_id":"cl1klgup900078e85g8bzcbwn","_id":"cl1klguph000e8e856xwv36vl"},{"post_id":"cl1klgup400028e85bpac6xtr","tag_id":"cl1klgup600038e85d0jpagls","_id":"cl1klgupj000k8e85ctmcfuph"},{"post_id":"cl1klgup400028e85bpac6xtr","tag_id":"cl1klguph000f8e855bd99uii","_id":"cl1klgupk000m8e8523xm1p9o"},{"post_id":"cl1klgup700048e854aa60cuj","tag_id":"cl1klgupi000i8e85dl386jvy","_id":"cl1klgupp000w8e854jhqhbjx"},{"post_id":"cl1klgup700048e854aa60cuj","tag_id":"cl1klgupk000n8e85gtvc5fe9","_id":"cl1klgupp000y8e856fd95jub"},{"post_id":"cl1klgup700048e854aa60cuj","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klgupq00118e8515swhg8b"},{"post_id":"cl1klgup800058e8527pzb6at","tag_id":"cl1klgupo000u8e851ano4jd3","_id":"cl1klgupt00188e8577yge9ox"},{"post_id":"cl1klgup800058e8527pzb6at","tag_id":"cl1klgupp000z8e859zr03e53","_id":"cl1klgupt001a8e85f2ne4rcy"},{"post_id":"cl1klgup800058e8527pzb6at","tag_id":"cl1klgupq00138e853xck8oov","_id":"cl1klgupu001d8e85gsife0rg"},{"post_id":"cl1klgup900068e852o73d2x5","tag_id":"cl1klgupr00178e8581vwbpk6","_id":"cl1klgupu001f8e85clbh7rav"},{"post_id":"cl1klgupa00088e857bp81ncu","tag_id":"cl1klgupt001c8e8547fg8ojg","_id":"cl1klgupw001m8e858bs0cugm"},{"post_id":"cl1klgupa00088e857bp81ncu","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klgupw001o8e85gis07y6t"},{"post_id":"cl1klgupw001q8e850gz4dlzg","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klgupx001s8e851cucdrqg"},{"post_id":"cl1klgupx001r8e850b7ocwk7","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klgupx001v8e8537ir8cug"},{"post_id":"cl1klgupx001r8e850b7ocwk7","tag_id":"cl1klgupw001p8e855clb3uhu","_id":"cl1klgupy001w8e85bh0laerd"},{"post_id":"cl1klgupx001r8e850b7ocwk7","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klgupy001y8e85byf87zg2"},{"post_id":"cl1klgupb00098e85htfeay0o","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klgupy001z8e850xtvhjyu"},{"post_id":"cl1klgupb00098e85htfeay0o","tag_id":"cl1klgupw001p8e855clb3uhu","_id":"cl1klgupy00218e850ycc7ey5"},{"post_id":"cl1klgupb00098e85htfeay0o","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klgupy00228e85hkwr4xjo"},{"post_id":"cl1klgupe000b8e85bh9f4lyu","tag_id":"cl1klgupw001p8e855clb3uhu","_id":"cl1klgupy00248e859dz2bqeq"},{"post_id":"cl1klgupf000d8e85h32qf2h5","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klgupz00278e856sel550j"},{"post_id":"cl1klgupf000d8e85h32qf2h5","tag_id":"cl1klgupw001p8e855clb3uhu","_id":"cl1klgupz00288e857yj71sln"},{"post_id":"cl1klgupf000d8e85h32qf2h5","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klgupz002a8e85hrcy26f7"},{"post_id":"cl1klguph000g8e85er5e0m55","tag_id":"cl1klgupz00268e85ffk3hjy6","_id":"cl1klguq0002c8e8515csb0nj"},{"post_id":"cl1klguph000g8e85er5e0m55","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguq0002d8e850i659oco"},{"post_id":"cl1klgupi000h8e853bu5a8nf","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguq2002h8e85gguw3yv6"},{"post_id":"cl1klgupi000h8e853bu5a8nf","tag_id":"cl1klguq0002e8e853xgk3cma","_id":"cl1klguq2002i8e85er8fc0xe"},{"post_id":"cl1klgupi000h8e853bu5a8nf","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klguq2002k8e85cuaz3f3i"},{"post_id":"cl1klgupj000j8e855q0wfyai","tag_id":"cl1klguq2002g8e850t4h1jp4","_id":"cl1klguq3002p8e8509bl55rx"},{"post_id":"cl1klgupj000j8e855q0wfyai","tag_id":"cl1klguq2002j8e852g3r4jg1","_id":"cl1klguq3002q8e8573m1gxr1"},{"post_id":"cl1klgupj000j8e855q0wfyai","tag_id":"cl1klguq2002l8e8589qqfivq","_id":"cl1klguq3002s8e85h2xe8dav"},{"post_id":"cl1klgupj000j8e855q0wfyai","tag_id":"cl1klguq2002m8e85b29a9v4y","_id":"cl1klguq3002t8e85bvk6263b"},{"post_id":"cl1klgupj000j8e855q0wfyai","tag_id":"cl1klgupq00138e853xck8oov","_id":"cl1klguq3002v8e8530dk1s7z"},{"post_id":"cl1klgupj000l8e85b57860j0","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguq4002x8e853uv7gaqg"},{"post_id":"cl1klgupj000l8e85b57860j0","tag_id":"cl1klgupw001p8e855clb3uhu","_id":"cl1klguq4002y8e850gsj5gmm"},{"post_id":"cl1klgupj000l8e85b57860j0","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klguq400308e85h1ice128"},{"post_id":"cl1klgupk000o8e85gl3a7hsn","tag_id":"cl1klguq3002w8e85630bg24s","_id":"cl1klguq400348e858haw8g5h"},{"post_id":"cl1klgupk000o8e85gl3a7hsn","tag_id":"cl1klguq4002z8e8585xj2lmu","_id":"cl1klguq400358e853didhafc"},{"post_id":"cl1klgupk000o8e85gl3a7hsn","tag_id":"cl1klguq400318e8500a4cb90","_id":"cl1klguq400378e855ovpb7s8"},{"post_id":"cl1klgupk000o8e85gl3a7hsn","tag_id":"cl1klguq400328e851cl5blbm","_id":"cl1klguq500388e85c8720727"},{"post_id":"cl1klgupl000p8e854cfq5w0p","tag_id":"cl1klgupo000u8e851ano4jd3","_id":"cl1klguq5003b8e85ckaqg5u6"},{"post_id":"cl1klgupl000p8e854cfq5w0p","tag_id":"cl1klguq400368e854e8p8xqb","_id":"cl1klguq5003c8e859o7m12sj"},{"post_id":"cl1klgupl000p8e854cfq5w0p","tag_id":"cl1klguq500398e85c8yo8x3f","_id":"cl1klguq5003e8e8523j82atu"},{"post_id":"cl1klgupl000q8e85e1rk0lh1","tag_id":"cl1klguq5003a8e8540l2fcmr","_id":"cl1klguq6003g8e85bjibfjcz"},{"post_id":"cl1klgupl000q8e85e1rk0lh1","tag_id":"cl1klguq5003d8e85a1pn8swp","_id":"cl1klguq6003h8e85gwrtb3fg"},{"post_id":"cl1klgupm000s8e85doqv6ewz","tag_id":"cl1klgupo000u8e851ano4jd3","_id":"cl1klguq6003l8e85cizmb68x"},{"post_id":"cl1klgupm000s8e85doqv6ewz","tag_id":"cl1klguq400368e854e8p8xqb","_id":"cl1klguq6003m8e8537sdf337"},{"post_id":"cl1klgupm000s8e85doqv6ewz","tag_id":"cl1klguq500398e85c8yo8x3f","_id":"cl1klguq7003o8e854ii0f1ho"},{"post_id":"cl1klgupm000t8e85a5gwhkir","tag_id":"cl1klguq6003k8e85cx8fd55j","_id":"cl1klguq9003r8e852bio9mju"},{"post_id":"cl1klgupm000t8e85a5gwhkir","tag_id":"cl1klguq6003n8e855ik19woa","_id":"cl1klguq9003s8e85fert1sel"},{"post_id":"cl1klgupm000t8e85a5gwhkir","tag_id":"cl1klguq7003p8e8526j10oi5","_id":"cl1klguq9003u8e858c3z425w"},{"post_id":"cl1klgupo000v8e85ae5a4pdp","tag_id":"cl1klguq8003q8e85gm5q4jte","_id":"cl1klguq9003v8e85ghu3240j"},{"post_id":"cl1klgupp000x8e85efwm556p","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klguq9003z8e85humq5qqq"},{"post_id":"cl1klgupp000x8e85efwm556p","tag_id":"cl1klguq9003t8e85av6a7s5d","_id":"cl1klguq900408e853tms3be3"},{"post_id":"cl1klgupp000x8e85efwm556p","tag_id":"cl1klguq9003w8e8524yteb0g","_id":"cl1klguq900428e85fkuj28lx"},{"post_id":"cl1klgupp000x8e85efwm556p","tag_id":"cl1klguq9003x8e857geh6q6a","_id":"cl1klguq900438e854zssaggd"},{"post_id":"cl1klgupp00108e85ewfzblzj","tag_id":"cl1klguq9003y8e858zdk93dp","_id":"cl1klguqa00468e85f4rx0szp"},{"post_id":"cl1klgupp00108e85ewfzblzj","tag_id":"cl1klguq900418e8554va7w3l","_id":"cl1klguqa00478e851cvr32n4"},{"post_id":"cl1klgupp00108e85ewfzblzj","tag_id":"cl1klguq900448e85ehk62qwz","_id":"cl1klguqa00498e855w3s8553"},{"post_id":"cl1klgupq00128e85aocl9sif","tag_id":"cl1klgupo000u8e851ano4jd3","_id":"cl1klguqa004a8e85grvr93ur"},{"post_id":"cl1klgupq00128e85aocl9sif","tag_id":"cl1klguqa00458e855wor7vbl","_id":"cl1klguqb004c8e8512523o6o"},{"post_id":"cl1klgupq00148e85f3wr8c3b","tag_id":"cl1klgupq00138e853xck8oov","_id":"cl1klguqb004e8e851gdbb8wa"},{"post_id":"cl1klgupq00148e85f3wr8c3b","tag_id":"cl1klguqa00458e855wor7vbl","_id":"cl1klguqb004f8e85aesw8xmq"},{"post_id":"cl1klgupq00148e85f3wr8c3b","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klguqb004h8e85c6sw0gj9"},{"post_id":"cl1klgupr00158e85hfgo91we","tag_id":"cl1klguq9003y8e858zdk93dp","_id":"cl1klguqb004k8e85h5832lje"},{"post_id":"cl1klgupr00158e85hfgo91we","tag_id":"cl1klguqb004g8e850e501ofp","_id":"cl1klguqb004l8e85cij33qs3"},{"post_id":"cl1klgupr00158e85hfgo91we","tag_id":"cl1klguqb004i8e85eorshfsd","_id":"cl1klguqc004n8e858sz19maf"},{"post_id":"cl1klgupr00168e85a8sz2i4n","tag_id":"cl1klguqb004j8e850ils1dwk","_id":"cl1klguqc004p8e85c5o07yka"},{"post_id":"cl1klgupr00168e85a8sz2i4n","tag_id":"cl1klguqb004m8e851syxcs88","_id":"cl1klguqc004q8e85cln88j3d"},{"post_id":"cl1klgupt00198e8578wd71h8","tag_id":"cl1klguq5003a8e8540l2fcmr","_id":"cl1klguqd004t8e854oic91no"},{"post_id":"cl1klgupt00198e8578wd71h8","tag_id":"cl1klguq5003d8e85a1pn8swp","_id":"cl1klguqd004u8e855rgd2ve2"},{"post_id":"cl1klgupt001b8e85huarb063","tag_id":"cl1klguqc004s8e850pnz5m3n","_id":"cl1klguqf004x8e855x31h9tv"},{"post_id":"cl1klgupt001b8e85huarb063","tag_id":"cl1klguqd004v8e853w7wdeh3","_id":"cl1klguqf004y8e859dbm4j3e"},{"post_id":"cl1klgupu001e8e85dwqoh1hu","tag_id":"cl1klguqf004w8e85gy0l7kd3","_id":"cl1klguqg00518e854dhahbce"},{"post_id":"cl1klgupu001e8e85dwqoh1hu","tag_id":"cl1klguqf004z8e850uam12lb","_id":"cl1klguqg00528e857d74bz6n"},{"post_id":"cl1klgupu001g8e85ct009jv8","tag_id":"cl1klguqf004w8e85gy0l7kd3","_id":"cl1klguqg00558e85hhl4fw65"},{"post_id":"cl1klgupu001g8e85ct009jv8","tag_id":"cl1klguqf004z8e850uam12lb","_id":"cl1klguqg00568e85645n5hm5"},{"post_id":"cl1klgupu001i8e85brse155x","tag_id":"cl1klguqg00548e85a2xacjnl","_id":"cl1klguqh00598e855bd1heif"},{"post_id":"cl1klgupu001i8e85brse155x","tag_id":"cl1klguqg00578e85fbn1f5li","_id":"cl1klguqh005a8e85dekc707r"},{"post_id":"cl1klgupu001i8e85brse155x","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguqh005c8e854eno3g72"},{"post_id":"cl1klgupv001j8e85c5nwc2ok","tag_id":"cl1klguqg00588e8542125gak","_id":"cl1klguqh005d8e857sq83mz6"},{"post_id":"cl1klgupv001l8e857vjp6bv8","tag_id":"cl1klguqh005b8e85g9saay8v","_id":"cl1klguqi005g8e85dfmt25x1"},{"post_id":"cl1klgupv001l8e857vjp6bv8","tag_id":"cl1klguqh005e8e85gw598f9v","_id":"cl1klguqi005h8e85g8g2a8l2"},{"post_id":"cl1klgupw001n8e85elwqebpi","tag_id":"cl1klguqi005f8e85d8440555","_id":"cl1klguqi005l8e85d3bt0nt6"},{"post_id":"cl1klgupw001n8e85elwqebpi","tag_id":"cl1klguqi005i8e85aewpcn17","_id":"cl1klguqi005m8e8566tv6qq6"},{"post_id":"cl1klgupw001n8e85elwqebpi","tag_id":"cl1klguqi005j8e853zxl0umk","_id":"cl1klguqi005n8e85fqibe24w"},{"post_id":"cl1klgupx001t8e85crkb8vli","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguqi005o8e8503r0dvwk"},{"post_id":"cl1klgupx001t8e85crkb8vli","tag_id":"cl1klguqg00578e85fbn1f5li","_id":"cl1klguqj005p8e858we4hmg8"},{"post_id":"cl1klguqn005q8e8523wveq4y","tag_id":"cl1klgupu001h8e8540yjfdd0","_id":"cl1klguqp005s8e8565xqgff3"},{"post_id":"cl1klguqn005q8e8523wveq4y","tag_id":"cl1klguqp005r8e854o0jegap","_id":"cl1klguqp005t8e85a8f79alz"},{"post_id":"cl1klguqn005q8e8523wveq4y","tag_id":"cl1klgupl000r8e852zeobo2j","_id":"cl1klguqq005u8e852jcl42bi"},{"post_id":"cl2plges60000x88551ie2r26","tag_id":"cl1klguq5003a8e8540l2fcmr","_id":"cl2plgesb0001x8854n1q6zh2"},{"post_id":"cl2plges60000x88551ie2r26","tag_id":"cl1klguq5003d8e85a1pn8swp","_id":"cl2plgesb0002x885eh1l6o5k"},{"post_id":"cl4w135nx0000od85cqwag3vt","tag_id":"cl4w135o20001od85e0dz9fpx","_id":"cl4w135oa0002od856nf1dy6q"},{"post_id":"cl4w135nx0000od85cqwag3vt","tag_id":"cl1klguq9003y8e858zdk93dp","_id":"cl4w135oa0003od85ck1oh8rt"},{"post_id":"cl6r86mkw0000fcei7ptx3asi","tag_id":"cl6r86ml00001fcei6ahu1bdv","_id":"cl6r86ml90003fcei3ro33dgd"},{"post_id":"cl6r86mkw0000fcei7ptx3asi","tag_id":"cl6r86ml90002fceig5udh4t0","_id":"cl6r86mla0004fceibscf0yfs"},{"post_id":"clhgbdskr000059mael2ybdhi","tag_id":"cliace909000011ma2nf92bf9","_id":"cliace90j000211ma1jkc52lt"},{"post_id":"clhgbdskr000059mael2ybdhi","tag_id":"cliace90h000111ma6ot8fyx9","_id":"cliace90j000311ma7zoc22u9"},{"post_id":"cliadyvpj0000qfmacexv5cnh","tag_id":"cl1klguq9003y8e858zdk93dp","_id":"cliadyvpx0003qfma31ezgjdx"},{"post_id":"cliadyvpj0000qfmacexv5cnh","tag_id":"cliadyvpn0001qfma9tu8e02a","_id":"cliadyvpx0004qfmaay4g18yu"},{"post_id":"cliadyvpj0000qfmacexv5cnh","tag_id":"cliadyvpv0002qfma08kchyh3","_id":"cliadyvpx0005qfmahvz88tk0"}],"Tag":[{"name":"Self","_id":"cl1klgup600038e85d0jpagls"},{"name":"Life","_id":"cl1klgup900078e85g8bzcbwn"},{"name":"Metro","_id":"cl1klguph000f8e855bd99uii"},{"name":"BitwiseNOT","_id":"cl1klgupi000i8e85dl386jvy"},{"name":"LogicalNOT","_id":"cl1klgupk000n8e85gtvc5fe9"},{"name":"JavaScript","_id":"cl1klgupl000r8e852zeobo2j"},{"name":"Functional Programming","_id":"cl1klgupo000u8e851ano4jd3"},{"name":"Continuation","_id":"cl1klgupp000z8e859zr03e53"},{"name":"Promise","_id":"cl1klgupq00138e853xck8oov"},{"name":"Programming","_id":"cl1klgupr00178e8581vwbpk6"},{"name":"Y.delegate","_id":"cl1klgupt001c8e8547fg8ojg"},{"name":"YUI","_id":"cl1klgupu001h8e8540yjfdd0"},{"name":"Event","_id":"cl1klgupw001p8e855clb3uhu"},{"name":"Y.Event","_id":"cl1klgupz00268e85ffk3hjy6"},{"name":"OOP","_id":"cl1klguq0002e8e853xgk3cma"},{"name":"FrontEnd","_id":"cl1klguq2002g8e850t4h1jp4"},{"name":"Pipeline","_id":"cl1klguq2002j8e852g3r4jg1"},{"name":"Middleware","_id":"cl1klguq2002l8e8589qqfivq"},{"name":"Stream","_id":"cl1klguq2002m8e85b29a9v4y"},{"name":"front-end","_id":"cl1klguq3002w8e85630bg24s"},{"name":"component","_id":"cl1klguq4002z8e8585xj2lmu"},{"name":"reduce","_id":"cl1klguq400318e8500a4cb90"},{"name":"turbo","_id":"cl1klguq400328e851cl5blbm"},{"name":"Functional Reactive Programming","_id":"cl1klguq400368e854e8p8xqb"},{"name":"RxJS","_id":"cl1klguq500398e85c8yo8x3f"},{"name":"Recruitment","_id":"cl1klguq5003a8e8540l2fcmr"},{"name":"Organization","_id":"cl1klguq5003d8e85a1pn8swp"},{"name":"Closure","_id":"cl1klguq6003k8e85cx8fd55j"},{"name":"Execution Context","_id":"cl1klguq6003n8e855ik19woa"},{"name":"Prototype Chain","_id":"cl1klguq7003p8e8526j10oi5"},{"name":"Interview","_id":"cl1klguq8003q8e85gm5q4jte"},{"name":"Linter","_id":"cl1klguq9003t8e85av6a7s5d"},{"name":"ESLint","_id":"cl1klguq9003w8e8524yteb0g"},{"name":"JSLint","_id":"cl1klguq9003x8e857geh6q6a"},{"name":"React","_id":"cl1klguq9003y8e858zdk93dp"},{"name":"Virtual DOM","_id":"cl1klguq900418e8554va7w3l"},{"name":"Fiber","_id":"cl1klguq900448e85ehk62qwz"},{"name":"Monad","_id":"cl1klguqa00458e855wor7vbl"},{"name":"Hooks","_id":"cl1klguqb004g8e850e501ofp"},{"name":"Web","_id":"cl1klguqb004i8e85eorshfsd"},{"name":"try-cacth","_id":"cl1klguqb004j8e850ils1dwk"},{"name":"onerror","_id":"cl1klguqb004m8e851syxcs88"},{"name":"Series","_id":"cl1klguqc004s8e850pnz5m3n"},{"name":"Review","_id":"cl1klguqd004v8e853w7wdeh3"},{"name":"TypeScript","_id":"cl1klguqf004w8e85gy0l7kd3"},{"name":"Type System","_id":"cl1klguqf004z8e850uam12lb"},{"name":"W3CTech","_id":"cl1klguqg00548e85a2xacjnl"},{"name":"Meituan","_id":"cl1klguqg00578e85fbn1f5li"},{"name":"This","_id":"cl1klguqg00588e8542125gak"},{"name":"Instanceof","_id":"cl1klguqh005b8e85g9saay8v"},{"name":"Scope-safe Constructor","_id":"cl1klguqh005e8e85gw598f9v"},{"name":"YUI2","_id":"cl1klguqi005f8e85d8440555"},{"name":"domready","_id":"cl1klguqi005i8e85aewpcn17"},{"name":"load","_id":"cl1klguqi005j8e853zxl0umk"},{"name":"Framework","_id":"cl1klguqp005r8e854o0jegap"},{"name":"React Query","_id":"cl4w135o20001od85e0dz9fpx"},{"name":"Management","_id":"cl6r86ml00001fcei6ahu1bdv"},{"name":"Lever","_id":"cl6r86ml90002fceig5udh4t0"},{"name":"Communication","_id":"cliace909000011ma2nf92bf9"},{"name":"Asking","_id":"cliace90h000111ma6ot8fyx9"},{"name":"Context","_id":"cliadyvpn0001qfma9tu8e02a"},{"name":"useContextSelector","_id":"cliadyvpv0002qfma08kchyh3"}]}}