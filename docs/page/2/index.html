<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/atom.xml" title="Shang Chun" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://shangchun.net/page/2/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Shang Chun</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shang Chun</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shang Chun</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/bitwise-not-and-logical-not/">js 中的 !! 与 ~~</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-10-17
        </span></div>
    </header>

    <div class="post-content"><p>在各大 js 的开源项目中，时常见到 !! 和 ~~，偶有猜对，却总不得要领。本文旨在深入剖析下这两个运算符的原理，以及使用时的利弊。</p>
<h2 id=""><a href="#" class="headerlink" title="!"></a>!</h2><p>为了简化问题，我们首先了解下常见的逻辑非运算符 !，EcmaScript 中的定义是：</p>
<blockquote>
<p>产生式 <code>UnaryExpression : ! UnaryExpression</code> 按照下面的过程执行：</p>
<ul>
<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>
<li>令 <code>oldValue</code> 为 ToBoolean(GetValue(<code>expr</code>))</li>
<li>如果 <code>oldValue</code> 为 true, 返回 false</li>
<li>返回 true</li>
</ul>
</blockquote>
<p>GetValue 处理取值的细节，例如依附于对象的属性、执行 getter 等，不再深究。重点看下 ToBoolean，它能够将各种类型的值最终转化为布尔类型。具体的规则可参考 <a target="_blank" rel="noopener" href="http://es5.github.io/#x9.2">ES5#9.2 ToBoolean</a> 一节。</p>
<p>接下来的处理很简单，如果 ToBoolen 得到的结果 <code>oldValue</code> 是 true，那就返回 false，否则返回 true。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="!!"></a>!!</h2><p>了解了 ! 之后，!! 就很好解释了，简单来说就是：</p>
<blockquote>
<p>产生式 <code>UnaryExpression : !! UnaryExpression</code> 按照下面的过程执行：</p>
<ul>
<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>
<li>返回 ToBoolean(GetValue(<code>expr</code>))</li>
</ul>
</blockquote>
<p>是的，比 ! 的运算过程减少了两步，执行完 ToBoolean 后就直接返回了。这也是 !! 最主要的用途：<strong>将操作数转化为布尔类型</strong>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!! <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!! <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!! <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line">!! <span class="string">&#x27;hello&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!! <span class="number">5</span> <span class="comment">// true</span></span><br><span class="line">!! <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!! &#123;&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>值得提示的一点是，!! 实际上等效于 <code>Boolean</code> 被当做函数调用的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!(value) === <span class="built_in">Boolean</span>(value)</span><br></pre></td></tr></table></figure>

<h2 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h2><p>按位非操作符 ~ 比逻辑非操作符 ! 复杂一些，作用是将数值比特位中的 1 变成 0，0 变成 1。EcmaScript 中的定义为：</p>
<blockquote>
<p>产生式 <code>UnaryExpression : ~ UnaryExpression</code> 按照下面的过程执行：</p>
<ul>
<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>
<li>令 <code>oldValue</code> 为 ToInt32(GetValue(<code>expr</code>))</li>
<li>返回 <code>oldValue</code> 按位取反的结果</li>
</ul>
</blockquote>
<p>与逻辑非执行过程第二步不同，按位非调用的是 ToInt32 而不是 ToBoolean。ToInt32 的处理过程比较复杂，简化为以下四步：</p>
<ul>
<li>令 <code>number</code> 为调用 ToNumber 将输入参数转化为数值类型的结果</li>
<li>如果 <code>number</code> 是 NaN，+0，-0，+∞ 或者 -∞，返回 +0</li>
<li>令 <code>posInt</code> 为 sign(<code>number</code>) * floor(abs(<code>number</code>))</li>
<li>将 <code>posInt</code> 进行取模处理，转化为在 −2^31 到 2^31−1 之间的 32 位有符号整数并返回</li>
</ul>
<p>从效果上看，ToInt32 依次做了这样几件事：</p>
<ul>
<li>类型转换，非数值类型的需要转化为数值类型</li>
<li>特殊值处理，NaN 和 ∞ 都被转化为 0</li>
<li>取整，如果是浮点数，会损失小数点后面的精度</li>
<li>取模，将整数调整到 32 位有符号整数区间内，如果整数原本不在这个区间，会丧失精度</li>
</ul>
<p>执行完 ToInt32 之后，将得到的 32 位有符号整数进行按位取反，并将结果返回。</p>
<p>需要注意的是，所有的位操作都会先将操作数转化为 32 位有符号整数。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title="~~"></a>~~</h2><p>和 !! 与 ! 的关系类似，~~ 实际上是 ~ 的简化版：</p>
<blockquote>
<p>产生式 <code>UnaryExpression : ~~ UnaryExpression</code> 按照下面的过程执行：</p>
<ul>
<li>令 <code>expr</code> 为解析执行 <code>UnaryExpression</code> 的结果</li>
<li>返回 ToInt32(GetValue(<code>expr</code>))</li>
</ul>
</blockquote>
<p>因为第一次执行 ~ 时已经将操作数转化为 32 位有符号整数，第二次执行 ~ 时实际只是将按位取反的结果再次按位取反，相当于取消掉 ~ 处理过程中的第三步。那么 ~~ 的用途也就很明确了：<strong>将操作数转化为 32 位有符号整数</strong>。</p>
<p>下面来看一些具体例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~~ <span class="literal">null</span> <span class="comment">// 0</span></span><br><span class="line">~~ <span class="literal">undefined</span> <span class="comment">// 0</span></span><br><span class="line">~~ <span class="literal">NaN</span> <span class="comment">// 0</span></span><br><span class="line">~~ &#123;&#125; <span class="comment">// 0</span></span><br><span class="line">~~ <span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">~~ <span class="string">&#x27;&#x27;</span> <span class="comment">// 0</span></span><br><span class="line">~~ <span class="string">&#x27;string&#x27;</span> <span class="comment">// 0</span></span><br><span class="line">~~ <span class="string">&#x27;1&#x27;</span> <span class="comment">// 1</span></span><br><span class="line">~~ <span class="built_in">Number</span>.POSITIVE_INFINITY <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">~~ <span class="number">1.2</span> <span class="comment">// 1</span></span><br><span class="line">~~ -<span class="number">1.2</span> <span class="comment">// -1</span></span><br><span class="line">~~ <span class="number">1.6</span> <span class="comment">// 1</span></span><br><span class="line">~~ -<span class="number">1.6</span> <span class="comment">// -1</span></span><br><span class="line">~~ (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) <span class="comment">// 2147483647 = 2^31-1</span></span><br><span class="line">~~ (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) <span class="comment">// -2147483648 = -2^31</span></span><br><span class="line">~~ (-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) <span class="comment">// -2147483648 = -2^31</span></span><br><span class="line">~~ (-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) <span class="comment">// 2147483647 = 2^31-1</span></span><br><span class="line">~~ (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>如果你需要将一个参数转化为 32 位有符号整数，那么 ~~ 将是最简便的方式。不过要切记，它会损失精度，包括小数和整数部分。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">按位操作符-MDN</a></li>
<li><a target="_blank" rel="noopener" href="http://es5.github.io/#x9.2">ToBoolean - ES5</a></li>
<li><a target="_blank" rel="noopener" href="http://es5.github.io/#x9.5">ToInt32 - ES5</a></li>
<li><a target="_blank" rel="noopener" href="http://es5.github.io/#x11.4.8">Bitwise NOT Operator - ES5</a></li>
<li><a target="_blank" rel="noopener" href="http://es5.github.io/#x11.4.9">Logical NOT Operator - ES5</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/frontend-component-practice/">前端组件化开发实践</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-06-29
        </span><span class="post-author">
          / springuper@gmail.com
        </span>
        </div>
    </header>

    <div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一位计算机前辈曾说过：</p>
<pre><code>Controlling complexity is the essence of computer programming.
</code></pre>
<p>随着前端开发复杂度的日益提升，组件化开发应运而生，并随着 FIS、React 等优秀框架的出现遍地开花。这一过程同样发生在美团，面临业务规模的快速发展和工程师团队的不断扩张，我们历经引入组件化解决资源整合问题、逐步增强组件功能促进开发效率、重新打造新一代组件化方案适应全栈开发和共享共建等阶段，努力“controlling complexity”。本文将介绍我们组件化开发的实践过程。</p>
<h3 id="组件化-1-0：资源重组"><a href="#组件化-1-0：资源重组" class="headerlink" title="组件化 1.0：资源重组"></a>组件化 1.0：资源重组</h3><p>在美团早期，前端资源是按照页面或者类似业务页面集合的形式进行组织的。例如 order.js 对应订单相关页面的交互，account.css 对应账户相关页面的样式。这种方式在过去的较长一段时间内，持续支撑了整个项目的正常推进，功勋卓著。</p>
<center><img src="/images/frontend-component-practice/legacy-flow.png" alt="legacy-flow" width="500"></center>


<p>随着业务规模的增加和开发团队的扩张，这套机制逐渐显示出它的一些不足：</p>
<ol>
<li><strong>资源冗余</strong><br>页面的逐渐增加，交互的逐渐复杂化，导致对应的 css 和 js 都有大幅度增长，进而出现为了依赖某个 js 中的一个函数，需要加载整个模块，或者为了使用某个 css 中的部分样式依赖整个 css，冗余资源较多</li>
<li><strong>对应关系不直观</strong><br>没有显而易见的对应规则，导致的一个问题是修改某个业务模块的 css 或者 js 时，几乎只能依靠 grep。靠人来维护页面模块 html、css 和 js 之间的依赖关系，容易犯错，常常出现内容已经删除但是 css 或 js 还存在的问题</li>
<li><strong>难于单元测试</strong><br>以页面为最小粒度进行资源整合，不同功能的业务模块相互影响，复杂度太高，自动化测试难以推进</li>
</ol>
<p>2013 年开始，在调研了 FIS、BEM 等方案之后，结合美团开发框架的实际，我们初步实现了一套轻量级的组件化开发方案。主要的改进是：</p>
<ul>
<li>以页面功能组件为单位聚合前端资源</li>
<li>自动加载符合约定的 css、js 资源</li>
<li>将业务数据到渲染数据的转换过程独立出来</li>
</ul>
<center><img src="/images/frontend-component-practice/component-flow.png" alt="component-flow" width="500"></center>

<p>举例来说，美团顶部的搜索框就被实现为一个组件。</p>
<center><img src="/images/frontend-component-practice/smart-box.png" alt="smart-box" width="500"></center>

<p>代码构成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">www/component/smart-box/</span><br><span class="line">├── smart-box.js    <span class="comment"># 交互</span></span><br><span class="line">├── smart-box.php   <span class="comment"># 渲染数据生产、组件配置</span></span><br><span class="line">├── smart-box.scss  <span class="comment"># 样式</span></span><br><span class="line">├── smart-box.tpl   <span class="comment"># 内容</span></span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── default.js  <span class="comment"># 自动化测试</span></span><br><span class="line">    └── default.php <span class="comment"># 单测页面</span></span><br></pre></td></tr></table></figure>

<p>调用组件变得十足简单：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> View::useComponent(<span class="string">&#x27;smart-box&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;keyword&#x27;</span> =&gt; <span class="variable">$keyword</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>对比之前，可以看到组件化的一些特点：</p>
<ol>
<li><strong>按需加载</strong><br>只加载必要的前端资源</li>
<li><strong>对应关系非常清晰</strong><br>组件所需要的前端资源都在同一目录，职责明确且唯一，对应关系显著</li>
<li><strong>易于测试</strong><br>组件是具备独立展现和交互的最小单元，可利用 Phantom 等工具自动化测试</li>
</ol>
<p>此外，由于前端资源集中进行调度，组件化也为高阶性能优化提供了空间。例如实现组件级别的 BigRender、通过数据分析进行资源的合并加载等等。</p>
<h3 id="组件化-2-0：趋于成熟"><a href="#组件化-2-0：趋于成熟" class="headerlink" title="组件化 2.0：趋于成熟"></a>组件化 2.0：趋于成熟</h3><p>组件化 1.0 上线后，由于简单易用，很快得到工程师的认可，并开始在各项业务中应用起来。新的需求接踵而来，一直持续到 2014 年底，这个阶段我们称之为组件化 2.0。下面介绍下主要的几个改进。</p>
<h4 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h4><p>组件在高内聚的同时，往往需要暴露一些接口供外界调用，从而能够适应复杂的页面需求，例如提交订单页面需要在支付密码组件启动完成后绑定提交时的检查。Web Components、React 等都选择了生命周期事件/方法，我们也是一样。</p>
<p>组件的生命周期：</p>
<center><img src="/images/frontend-component-practice/component-lifecycle.png" alt="component-lifecycle" width="800"></center>

<p>一个组件的完整生命周期包括：</p>
<ul>
<li>init，初始化组件根节点和配置</li>
<li>fetch，加载 css 和 js 资源</li>
<li>render，内容渲染，默认的渲染内容方式是 BigRender</li>
<li>ready，进行数据绑定等操作</li>
<li>update，数据更新</li>
<li>destroy，解除所有事件监听，删除所有组件节点</li>
</ul>
<p>组件提供 pause、resume 方法以方便进行生命周期控制。各个阶段使用 Promise 串行进行，异步的管理更清晰。使用自定义语义事件，在修改默认行为、组件间通信上充分利用了 YUI 强大的自定义事件体系，有效降低了开发维护成本。</p>
<p>举个例子，页面初始化时组件的启动过程实际也是借助生命周期实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> afterLoadList = [];</span><br><span class="line">Y.all(<span class="string">&#x27;[data-component]&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> component = <span class="keyword">new</span> Y.mt.Component(node);</span><br><span class="line">    <span class="comment">// 绑定 init 生命周期事件，在 init 默认行为完成后执行回调</span></span><br><span class="line">    component.after(<span class="string">&#x27;init&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果配置了延迟启动</span></span><br><span class="line">        <span class="keyword">if</span> (e.config.afterLoad) &#123;</span><br><span class="line">            <span class="comment">// 暂停组件生命周期</span></span><br><span class="line">            e.component.pause();</span><br><span class="line">            <span class="comment">// 压入延迟启动数组</span></span><br><span class="line">            afterLoadList.push(e.component);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 开始进入生命周期</span></span><br><span class="line">    component.start();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">Y.on(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在页面 load 事件发生时恢复组件生命周期</span></span><br><span class="line">    afterLoadList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">        component.resume();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回过头来看，引入生命周期除了带来扩展性外，更重要的是理顺了组件的各个阶段，有助于更好的理解和运用。</p>
<h4 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h4><p>数据绑定是我们期盼已久的功能，将 View 和 ViewModel 之间的交互自动化无疑会节省工程师的大量时间。在组件化减少关注点和降低复杂度后，实现数据绑定变得更加可能。</p>
<p>我们最终实现的数据绑定方案主要参考了 Angular，通过在 html 节点上添加特定的属性声明绑定逻辑，js 扫描这些内容并进行相应的渲染和事件绑定。当数据发生变化时，对应的内容全部重新渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;addressList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">        <span class="attr">mt-bind-repeat</span>=<span class="string">&quot;addr in addrList&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">mt-bind-html</span>=<span class="string">&quot;addr.text&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">Y.use([<span class="string">&#x27;mt-bind&#x27;</span>, <span class="string">&#x27;mt-scope&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    Y.mt.bind.init(<span class="built_in">document</span>.body);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scope = Y.one(<span class="string">&#x27;.addressList&#x27;</span>).getScope();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 scope.addrList 设置为一个数组，DOM 上将自动渲染其内容   </span></span></span><br><span class="line"><span class="javascript">    scope.$set(<span class="string">&#x27;addrList&#x27;</span>, [</span></span><br><span class="line"><span class="javascript">        &#123; <span class="attr">text</span>: <span class="string">&quot;first address&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">        &#123; <span class="attr">text</span>: <span class="string">&quot;second address&quot;</span> &#125;</span></span><br><span class="line"><span class="javascript">    ]);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用属性声明绑定逻辑的好处是可以同时支持后端渲染，这对于美团团购这样的偏展现型业务是非常必要的，用户可以很快看到页面内容。</p>
<h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><p>实现数据绑定后，我们不得不面对另外一个问题：如何协同多个组件间的数据。因为某个组件的数据变化，很有可能引起其他组件的变化。例如当修改购买数量，总金额会变化，而总金额超过 500 后，还需要展示大额消费提醒。</p>
<p>为了解决这个问题，我们引入了 Flux，使用全局消息总线的思路进行跨组件交互。</p>
<p>例如因为交互复杂而一直让我们非常头疼的项目购买页，在应用组件 + Flux 重构后，各模块之间的互动更加清晰：</p>
<center><img src="/images/frontend-component-practice/component-flux.png" alt="component-flux" width="600"></center>

<p>其他方面的改进还有很多，包括引入模板引擎 LightnCandy 约束模板逻辑、支持组件任意嵌套、支持异步加载并自动初始化等。</p>
<p>随着组件化 2.0 的逐步完善，基本已经可以从容应对日常开发，在效率和质量方面都上了一个台阶。</p>
<h3 id="组件化-3-0：重启征程"><a href="#组件化-3-0：重启征程" class="headerlink" title="组件化 3.0：重启征程"></a>组件化 3.0：重启征程</h3><p>时间的车轮滚滚前行，2014 年底，我们遇到一些新的机遇和挑战：</p>
<ul>
<li>基于 Node 的全栈开发模式开始应用，前后端渲染有了更多的可能性</li>
<li>YUI 停止维护，需要一套新的资源管理方案</li>
<li>新业务不断增加，需要找到一种组件共享的方式，避免重复造轮子</li>
</ul>
<p>结合之前的实践，以及在这一过程中逐渐积累的对业内方案的认知，我们提出了新的组件化方案：</p>
<ul>
<li>基于 React 开发页面组件，使用 NPM 进行分发，方便共建共享</li>
<li>基于 Browserify 二次开发，建设资源打包工具 Reduce，方便浏览器加载</li>
<li>建设适应组件化开发模式的工程化开发方案 Turbo，方便工程师将组件应用于业务开发中</li>
</ul>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>在组件化 2.0 的过程中，我们发现很多功能和 React 重合，例如 Data Binding、Lifecycle、前后端渲染，甚至直接借鉴的 Flux。除此之外，React 的函数式编程思想、增量更新、兼容性良好的事件体系也让我们非常向往。借着前端全栈开发的契机，我们开始考虑基于 React 进行组件化 3.0 的建设。</p>
<h4 id="NPM-Reduce"><a href="#NPM-Reduce" class="headerlink" title="NPM + Reduce"></a>NPM + Reduce</h4><p>NPM + Reduce 构成了我们新的资源管理方案，其中：</p>
<ul>
<li>NPM 负责组件的发布和安装。可以认为是“分”的过程，粒度越小，重用的可能性越大</li>
<li>Reduce 负责将页面资源进行打包。可以认为是“合”的过程，让浏览器更快地加载</li>
</ul>
<p>一个典型的组件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">smart-box/</span><br><span class="line">├── package.json    <span class="comment"># 组件包元信息</span></span><br><span class="line">├── smart-box.jsx   <span class="comment"># React Component</span></span><br><span class="line">├── smart-box.scss  <span class="comment"># 样式</span></span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    └── main.js     <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>

<p>NPM 默认只支持 js 文件的管理，我们对 NPM 中的 package.json 进行了扩展，增加了 style 字段，以使打包工具 Reduce 也能够对 css 和 css 中引用的 image、font 进行识别和处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;style&quot;</span>: <span class="string">&quot;./smart-box.scss&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要在页面中 require 了 smart-box，经过 Reduce 打包后，js、css 甚至图片、字体，都会出现在浏览器中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SmartBox = <span class="built_in">require</span>(<span class="string">&#x27;@mtfe/smart-box&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面</span></span><br><span class="line"><span class="keyword">var</span> IndexPage = React.createClass(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">SmartBox</span> <span class="attr">keyword</span>=<span class="string">&#123;</span> <span class="attr">this.props.keyword</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line">            ...</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = IndexPage;</span><br></pre></td></tr></table></figure>

<p>整体思路和组件化 1.0 如出一辙，却又那么不同。</p>
<h4 id="Turbo"><a href="#Turbo" class="headerlink" title="Turbo"></a>Turbo</h4><p>单单解决分发和打包的问题还不够，业务开发过程如果变得繁琐、难以 Debug、性能低下的话，恐怕不会受到工程师欢迎。</p>
<p>为了解决这些问题，我们在 Node 框架的基础上，提供了一系列中间件和开发工具，逐步构建对组件友好的前端工程化方案 Turbo。主要有：</p>
<ul>
<li>支持前后端同构渲染，让用户更早看到内容</li>
<li>简化 Flux 流程，数据流更加清晰易维护</li>
<li>引入 ImmutableJS，保证 Store 以外的数据不可变</li>
<li>采用 cursor 机制，保证数据修改/获取同步</li>
<li>支持 Hot Module Replacement，改进开发流自动化</li>
</ul>
<p>通过这些改进，一线工程师可以方便的使用各种组件，专注在业务本身上。开发框架层面的支持也反过来促进了组件化的发展，大家更乐于使用一系列组件来构建页面功能。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>发现痛点、分析调研、应用改进的解决问题思路在组件化开发实践中不断运用。历经三个大版本的演进，组件化开发模式有效缓解了业务发展带来的复杂度提升的压力，并培养工程师具备小而美的工程思想，形成共建共享的良好氛围。毫无疑问，组件化这种“分而治之”的思想将会长久地影响和促进前端开发模式。我们现在已经准备好，迎接新的机遇和挑战，用技术的不断革新提升工程师的幸福感。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/promise-insight/">剖析 Promise 之基础篇</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2014-05-08
        </span></div>
    </header>

    <div class="post-content"><p>随着浏览器端异步操作的复杂程度日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了飞速发展。本文旨在剖析 Promise 的内部机制，从实现原理层面深入探讨，从而达到“知其然且知其所以然”，在使用 Promise 上更加熟练自如。如果你还不太了解 Promise，推荐阅读下 <a target="_blank" rel="noopener" href="https://www.promisejs.org/">promisejs.org</a> 的介绍。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 <a target="_blank" rel="noopener" href="http://promisesaplus.com/">Promises/A+</a>。</p>
<p>Promise 较通常的回调、事件/消息，在处理异步操作时具有显著的优势。其中最为重要的一点是：Promise 在语义上代表了异步操作的主体。这种准确、清晰的定位极大推动了它在编程中的普及，因为具有单一职责，而且将份内事做到极致的事物总是具有病毒式的传染力。分离输入输出参数、错误冒泡、串行/并行控制流等特性都成为 Promise 横扫异步操作编程领域的重要砝码，以至于 ES6 都将其收录，并已在 Chrome、Firefox 等现代浏览器中实现。</p>
<h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><p>自从看到 Promise 的 API，我对它的实现就充满了深深的好奇，一直有心窥其究竟。接下来，将首先从最简单的基础实现开始，由浅入深的逐步探索，剖析每一个 feature 后面的故事。</p>
<p>为了让语言上更加准确和简练，本文做如下约定：</p>
<ul>
<li>Promise：代表由 Promises/A+ 规范所定义的异步操作封装方式；</li>
<li>promise：代表一个 Promise 实例。</li>
</ul>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 异步请求</span></span><br><span class="line">		Y.io(<span class="string">&#x27;/userid&#x27;</span>, &#123;</span><br><span class="line">			<span class="attr">on</span>: &#123;</span><br><span class="line">				<span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">id, res</span>) </span>&#123;</span><br><span class="line">					resolve(<span class="built_in">JSON</span>.parse(res).id);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserId().then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do sth with id</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://jsbin.com/kebigicu/1/embed?js,console">JS Bin</a></p>
          <div class="read-more">
            <a href="/promise-insight/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/yui3-event-default-action/">YUI经验谈-自定义事件默认行为</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2014-02-14
        </span></div>
    </header>

    <div class="post-content"><p>纵观主流JS库和框架，YUI在自定义事件方面做的尤为出色。如果需要挑出一个代表性的feature，那么非<strong>事件默认行为</strong>莫属。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>YUI自定义事件在总体上模仿了DOM事件的设计思想。DOM中的一些事件是有默认行为的，详细见<a target="_blank" rel="noopener" href="https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-flow-default-cancel">DOM3 Event - Default actions and cancelable events</a>一节。简单来说，所谓默认行为，是指该事件在通常情况下所表现出来的动作，例如：</p>
<ul>
<li>一个链接节点的<code>click</code>事件，默认行为是转向该链接href属性对应的地址</li>
<li>表单的submit事件，默认行为是将表单包含的数据提交给表单的action</li>
</ul>
<p>说通常情况下，是因为有时开发者会在事件的回调函数中调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault();</span><br></pre></td></tr></table></figure>

<p>来阻止默认行为的发生。</p>
          <div class="read-more">
            <a href="/yui3-event-default-action/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/diff-great-software-engineer-from-a-good/">[译]优秀与伟大程序员的区别</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2013-10-19
        </span></div>
    </header>

    <div class="post-content"><div class="preface">
    <p>在程序员的职业生涯中，总有一些理念让你眼前一亮，犹如夜空中一颗颗明亮的星，指引你不断前行。Quora上Russel Simmons的这个答案就是曾让我深受触动的三个理念，翻译出来给E文一般的童鞋。E文好的童鞋请移步，原著更加准确生动些。</p>
    <em>原文链接：<a href="http://www.quora.com/Software-Engineering/What-distinguishes-a-good-software-engineer-from-a-great-one/answer/Russel-Simmons?srid=mo0" target="_blank">Software Engineering: What distinguishes a good software engineer from a great one?</a></em>
</div>

<p>我并不打算给出一个全面的答案，不过我已注意到几个伟大程序员具备却不常被提及的特质：</p>
<ul>
<li><strong>能够平衡实效与完美</strong>。伟大工程师具备进行娴熟、快速而粗略的hack，和设计优雅、精炼、健壮的解决方案的两种能力，以及，根据给定问题选择恰当方式的智慧。一些稍普通的程序员们看起来缺乏对问题关键细节的极致关注，另一些人则太过坚持完美主义。</li>
<li><strong>不排斥调试代码和修复bug</strong>。平庸的程序员害怕、厌恶调试，甚至对自己的代码也是如此。伟大程序员会以丘吉尔般顽强的精神潜心钻研。如果问题被证明不在他们的代码中，伟大程序员会有些不愉快，他们会最终找出问题所在。</li>
<li><strong>合理质疑</strong>。优秀程序员会找到看似可行的解决办法并一直沿用。伟大程序员则倾向于质疑自己的代码，直到测试完备。而这一过程往往需要大量的数据分析和系统管理。一般程序员可能看到一个似乎没什么危害的细微异常，然后忽略掉了它。如果换作伟大程序员，他们会怀疑这可能是一个更大问题的线索，并投入精力研究透彻。伟大程序员乐于做更多的交叉校验和完备性检查，通过这种方式发现隐含的问题。</li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/yui3-practice/">YUI3在美团的实践</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2013-05-10
        </span></div>
    </header>

    <div class="post-content"><p>美团网在2010年引爆了团购行业，并在2012年销售额超过55亿，实现了全面盈利。在业务规模不断增长的背后，作为研发队伍中和用户最接近的前端团队承担着非常大的压力，比如用户量急剧上升带来的产品多样化，业务运营系统的界面交互日益复杂，代码膨胀造成维护成本增加等等。面对这些挑战，我们持续改进前端技术架构，在提升用户体验和工作效率的同时，成功支撑了美团业务的快速发展，这一切都得益于构建在YUI3框架之上稳定高效的前端代码。在应用YUI3的过程中，我们团队积累了一些经验，这里总结成篇，分享给大家。</p>
<h2 id="为什么选择YUI3"><a href="#为什么选择YUI3" class="headerlink" title="为什么选择YUI3"></a>为什么选择YUI3</h2><p>使用什么前端基础框架是建立前端团队最重要的技术决策之一。美团项目初期因为要加快开发进度，选择了当时团队最熟悉的YUI2（前框架时代杰出的类库），保证美团能够更快更早地上线，抢占市场先机。不久由于前端技术发展很快，YUI2的缺点逐渐凸显，例如开发方式落后、影响工作效率等等，于是我们开始考虑基础库的迁移。</p>
<p>经过一段时间对主流前端库、框架的反复考量，我们认为YUI3是最适合我们团队使用的基础框架。</p>
<p>首先，国内的开源框架及其社区刚开始起步，在代码质量、架构设计和理念创新上还难以跟YUI3比肩，所以基本排除在外。其次，国外像YUI3这样面向用户产品、文档丰富、扩展性良好的成熟框架屈指可数，例如ExtJS和Dojo则更适合业务复杂的传统企业级开发。最后，使用jQuery这种类库构建同YUI3一样强大的框架对创业团队来说并不可取，美团快速发展、竞争多变的业务特点决定了我们必须把主要精力放在更高一层的业务开发上，而不是去重复发明一个蹩脚的YUI。</p>
<p>YUI3成为最终选择有以下几个直接的原因：</p>
<ul>
<li>非常优秀，是真正的框架，真正的重型武器，具有强劲的持续开发能力，可以应对业务的快速发展。不管是规模不断增长的用户产品，还是交互日趋复杂的业务系统（美团有超过100个业务系统作全电子化的运营支撑），YUI3都游刃有余。</li>
<li>代码整齐规范，容易维护，适合有洁癖的工程师，同时能够显著提高团队协作时的开发效率。因为人手紧缺，后端工程师也需要参与前端开发，一致的代码风格使前后端配合轻松简单。</li>
<li>有出色的架构设计，是很好的框架范本，通过研究学习可以帮助工程师成长，培养良好的工程思维。人是美团最重要的产品。</li>
</ul>
<p>随着团队成长，我们最后引入了YUI3，在迁移过程中，遇到了很多技术上的和工程上的挑战，但是我们一直在前进，一直在行进中开火。从结果来看，YUI3为我们团队提供了先进生产力，为快速开发、快速部署、快速迭代提供了源源不断的力量。</p>
<p>YUI3的优秀主要表现在模块和组件框架的出色设计，下面我们着重介绍这两方面的一些实践经验。</p>
          <div class="read-more">
            <a href="/yui3-practice/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/event-delegate/">YUI事件体系之Y.delegate</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2013-04-05
        </span></div>
    </header>

    <div class="post-content"><p><img src="/images/delegate.jpg" alt="relay baton"></p>
<p>在介绍了YUI自定义事件体系和对DOM事件的封装后，本篇文章重点阐述事件方面的一种常用技术——事件代理。事件代理（Event Delegation，又称事件委托）充分运用事件传播模型，用一种十分优雅的方式实现了批量节点事件监听。具体的原理和优点请移步zakas比较古老的一篇文章<a target="_blank" rel="noopener" href="http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/">Event delegation in JavaScript</a>。事件代理在YUI中的实现为<code>Y.delegate</code>。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>为方便讨论，约定以下名称：</p>
<ul>
<li>代理节点：实际监听事件的节点。在事件传播到此节点时判断是否符合代理条件，符合则执行回调函数。</li>
<li>被代理节点：希望监听事件的节点。如果不采用事件代理，那么应该直接监听这些节点的事件。</li>
<li>目标节点：事件发生的目标节点，即<code>event.target</code>。</li>
</ul>
<p>三者的层次关系从内到外依次为：目标节点 &lt;= 被代理节点 &lt;= 代理节点。</p>
          <div class="read-more">
            <a href="/event-delegate/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/event/">YUI事件体系之Y.Event</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2013-01-20
        </span></div>
    </header>

    <div class="post-content"><p><img src="/images/mouse.png" alt="mouse event"></p>
<p>在介绍了由<code>Y.Do</code>、<code>Y.CustomEvent</code>、<code>Y.EventTarget</code>构建的自定义事件体系后，本篇文章将为大家介绍建立在这一体系之上，YUI对DOM事件的封装——<code>Y.Event</code>。</p>
<h2 id="Y-DOMEventFacade"><a href="#Y-DOMEventFacade" class="headerlink" title="Y.DOMEventFacade"></a>Y.DOMEventFacade</h2><p>众所周知，浏览器之间存在大量的不兼容问题，在事件方面尤其如此。<code>Y.DOMEventFacade</code>主要用来处理DOM事件对象的浏览器兼容问题，提供跨浏览器的简洁接口。事实上，我们常在<code>Y.one(&#39;.selector&#39;).on(&#39;click&#39;, function (e) &#123;&#125;)</code>中使用的<code>e</code>就是<code>Y.DOMEventFacade</code>的实例。</p>
<p>具体来说，兼容处理的属性主要有：</p>
<ul>
<li>target，专门处理了target为文本节点的情况，统一为元素节点，方便操作</li>
<li>relativeTarget，关联目标节点，在mouseover/mouseout等事件中设置</li>
<li>keyCode/charCode等输入信息</li>
<li>pageX/clientX等位置信息</li>
</ul>
<p>兼容处理的方法主要有：</p>
<ul>
<li>stopPropagation/stopImmediatePropagation，不支持停止立即传播时，仅能在YUI层面模拟，不会阻止通过原生方法添加的同层回调，即，在YUI监听过el的click事件后，又通过<code>el.addEventListener(&#39;click&#39;, nativeCallback)</code>监听，如果在YUI的回调中调用<code>e.stopImmediatePropagation</code>的话，<code>nativeCallback</code>仍然会执行</li>
<li>preventDefault</li>
</ul>
<p>另外，为了方便同时停止传播和阻止默认行为，YUI还提供了<code>halt</code>方法。</p>
          <div class="read-more">
            <a href="/event/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/event-target/">YUI事件体系之Y.EventTarget</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2012-11-25
        </span></div>
    </header>

    <div class="post-content"><p><img src="/images/bubble-girl.jpg" alt="bubble girl"></p>
<p>上两篇文章<a href="/event-do/">YUI事件体系之Y.Do</a>、<a href="/event-custom/">YUI事件体系之Y.CustomEvent</a>中，分别介绍了YUI实现AOP的<code>Y.Do</code>对象，以及建立自定义事件机制的<code>Y.CustomEvent</code>对象。</p>
<p>本篇文章，将要介绍YUI事件体系集大成者、最为精华的部分——<code>Y.EventTarget</code>。</p>
<h2 id="Y-EventTarget"><a href="#Y-EventTarget" class="headerlink" title="Y.EventTarget"></a>Y.EventTarget</h2><p>DOM事件中的目标元素为<code>event.target</code>，这类元素可以触发、监听一些事件，例如input元素的click、focus等事件。这也正是<code>Y.EventTarget</code>的命名渊源，它提供了一种让任意对象定义、监听、触发自定义事件的实现方式。</p>
<p>从设计上看，<code>Y.EventTarget</code>通过内部维护一系列<code>Y.EventCustom</code>对象，提供了可以通过事件名称进行事件定义、监听和触发的便捷接口。另外，推荐使用<code>Y.augment</code>将它以组合的方式加载在其它类上，而不要使用继承。关于<code>Y.augment</code>和<code>Y.extend</code>之间的异同，可以参考我之前的一篇文章：<a href="/extend-and-augment/">Y.extend与Y.augment</a>。</p>
<p>YUI很多基础类都扩展了<code>Y.EventTarget</code>，重要的有<code>Y</code>（YUI instance，sandbox）、<code>Y.Global</code>、<code>Y.Node</code>、<code>Y.NodeList</code>、<code>Y.Base</code>等。</p>
<p>YUILibrary有专门一个章节介绍EventTarget，非常详尽，如果你对EventTarget的设计思路和使用方法感兴趣，请移步<a target="_blank" rel="noopener" href="http://yuilibrary.com/yui/docs/event-custom/">YUILibrary-EventTarget</a>。</p>
          <div class="read-more">
            <a href="/event-target/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/event-custom/">YUI事件体系之Y.CustomEvent</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2012-09-01
        </span></div>
    </header>

    <div class="post-content"><p><img src="/images/DIY.jpg" alt="DIY"></p>
<p>上一篇<a href="/2013/01/20/event-do/">文章</a>中，简要介绍了YUI实现AOP的<code>Y.Do</code>对象。</p>
<p>接下来，我们继续对YUI事件体系进行探索。本次要介绍的是<code>Y.CustomEvent</code>对象，从命名上就可以看出，这个对象在整个YUI事件体系中十分重要。它建立起整个自定义事件的体系，而且，DOM事件也构建在这个体系之上。</p>
<h2 id="Y-Subscriber"><a href="#Y-Subscriber" class="headerlink" title="Y.Subscriber"></a>Y.Subscriber</h2><p>Y.Subscriber的作用比较简单：执行回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Y.Subscriber = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn; <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.context = context; <span class="comment">// 上下文</span></span><br><span class="line">    <span class="built_in">this</span>.id = Y.stamp(<span class="built_in">this</span>); <span class="comment">// 设置唯一id</span></span><br><span class="line">&#125;;</span><br><span class="line">Y.Subscriber.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Y.Subscriber,</span><br><span class="line">    <span class="comment">// 执行回调函数</span></span><br><span class="line">    <span class="attr">notify</span>: <span class="function"><span class="keyword">function</span> (<span class="params">args, ce</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.deleted) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">this</span>.fn.apply(<span class="built_in">this</span>.context, args || []);</span><br><span class="line">        <span class="comment">// 只监听一次</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.once) &#123;</span><br><span class="line">            ce._delete(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Y-CustomEvent"><a href="#Y-CustomEvent" class="headerlink" title="Y.CustomEvent"></a>Y.CustomEvent</h2><p><code>Y.CustomEvent</code>主要作用是：建立自定义事件机制，为方便的进行事件创建、监听、触发提供良好基础。自定义事件机制，实际上是<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Observer Pattern</a>（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Observer_pattern">Publish–subscribe Pattern</a>的演化）的一种实现，这种机制能够方便的实现模块间解耦，增强模块的扩展性。</p>
<p>YUI的自定义事件较其它一些js库来说要强大一些，有这样一些好的features：</p>
<ul>
<li>支持事件接口(Event Facade)，在回调函数中可以进行调用</li>
<li>支持设置默认执行方法</li>
<li>支持停止/立即停止传播，并可设定停止传播时执行的方法</li>
<li>支持阻止默认行为(默认执行方法)，并可设定阻止默认行为时执行的方法</li>
<li>支持冒泡。指定冒泡目标序列，就可以顺序的触发事件(需要<code>Y.EventTarget</code>)</li>
<li>支持广播。每个自定义事件，都可以设置在当前YUI实例范围内和全局YUI内进行广播</li>
</ul>
<p>可以看出，YUI的自定义事件和DOM事件极其类似，这种设计自然到我们在用自定义事件时，丝毫感觉不到和DOM事件的差异。</p>
          <div class="read-more">
            <a href="/event-custom/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <nav class="pagination"><a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/3/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:springuper@gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://twitter.com/springuper" class="iconfont icon-twitter" title="twitter"></a>
        <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/chun-shang-45a41241/" class="iconfont icon-linkedin" title="linkedin"></a>
        <a target="_blank" rel="noopener" href="https://github.com/springuper" class="iconfont icon-github" title="github"></a>
        <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/shang-chun" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Chun Shang</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
