<!DOCTYPE html><html>  <head>    <title>Async Pattern in NodeJS</title>    <style type="text/css">      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);      body {        font-family: 'Helvetica';      }      h1, h2, h3 {        font-family: 'Yanone Kaffeesatz';        font-weight: 400;        margin: 0.3em auto;      }      .remark-slide-content {        padding-left: 3em;        padding-right: 3em;        text-align: left;        vertical-align: middle;        background: #212121;        color: #777872;        text-shadow: 0 0 20px #333;      }      .remark-slide-content h1 { font-size: 3.8em; }      .remark-slide-content h2 { font-size: 2.4em; }      .remark-slide-content h3 { font-size: 1.6em; }      .footnote {        position: absolute;        bottom: 3em;      }      li p { line-height: 1.25em; margin:8px 0; }      .red { color: #fa0000; }      .large { font-size: 2em; }      a, a > code {        color: rgb(249, 38, 114);        text-decoration: none;      }      code {        -moz-border-radius: 5px;        -web-border-radius: 5px;        border-radius: 5px;      }      .hljs-monokai .hljs {        background: #3D3D3D;      }      .remark-code, .remark-inline-code {        font-size: 20px;        font-family: 'Monaco';      }      .pull-left {        float: left;        width: 47%;      }      .pull-right {        float: right;        width: 47%;      }      .pull-right ~ p {        clear: both;      }      #slideshow .slide .content code {        font-size: 0.8em;      }      #slideshow .slide .content pre code {        font-size: 0.9em;        padding: 15px;      }      .remark-slide-content ul {        color: #cecece;      }      .remark-slide-content h1, .remark-slide-content h2 {        color: #f3f3f3;        line-height: 1.2em;      }      .remark-slide-content h3 {        color: #cecece;        line-height: 1.2em;      }      .cover {        padding-left: 0;        padding-right: 0;        background-image: url(./watchmaker-workshop.jpg);        background-size: cover !important;        background-repeat: no-repeat;        text-shadow: 0 0 10px #000;      }      .cover h1 {        margin: 0.2em 0 0;        font-size: 5em;      }      .cover p {        color: #CCC;        text-shadow: 0 0 3px #000;      }      .cover-content {        padding: 1em;        text-align: center;        background: rgba(0, 0, 0, 0.6);      }      .nobg {        background-image: none;      }      .center {        text-align: center;      }      .engineering-productivity {        margin-left: 9em;        font-size: 26px;        color: #cecece;      }      .swe-duty {        text-align: left;        margin: 2em 0 0 11em;        font-size: 26px;      }      .trigger-time {        text-align: left;        margin: 0;        font-size: 32px;      }      .trigger-time--small{        font-size: 1em;      }      .trigger-time--9em {        margin-left: 9em;      }      .trigger-time--5em {        margin-left: 5em;      }      .trigger-time--4em {        margin-left: 4em;      }      .trigger-time--2em {        margin-left: 2em;      }      .trigger-time--0em {        margin-left: 0;      }      .trigger-time li {        margin-bottom: 8px;      }      .code-block {        text-align: left;        margin: 0 3em;      }      .code-block--nomargin {        margin: 0;      }      .code-block--small .remark-code-line {        font-size: 0.8em;      }      .code-block--smallest .remark-code-line {        font-size: 0.6em;      }      .referrence {        text-align: left;        margin-left: 2em;        font-size: 26px;      }      /* Slide-specific styling */      #slide-inverse .footnote {        bottom: 12px;        left: 20px;      }      small {        font-size: 0.6em;        color: #999;      }    </style>  </head>  <body>    <textarea id="source">class: cover.cover-content[# NodeJS 中的异步尚春]---# 提纲.trigger-time[- 为异步而生- Event Loop- 异步模式    - Callback    - Promise    - Generator    - Async/Await]---# 为异步而生.code-block.code-block--nomargin.code-block--small[```javascript// NodeJSvar request = require('request');request('http://www.10101111.com', function (error, response, body) {  if (!error && response.statusCode == 200) {    console.log(body);  }});console.log('do other stuff');```].code-block.code-block--nomargin.code-block--small[```go// GoLangresponse, _ := http.Get("http://www.10101111.com")defer response.Body.Close()body, _ := ioutil.ReadAll(response.Body)fmt.Println(string(body))fmt.Println("do other stuff")```]---# 异步带来的.center[![perf-vs-java](perf.png)]---# Event Loop.center[![event loop](event-loop.jpg)### [Demo by Philip Roberts](http://latentflip.com/loupe/)]---# 问题### 找出给定目录中最大的文件---# A: Callback.code-block.code-block--nomargin.code-block--smallest[```javascriptfunction findMaxSizeFile(dir, cb) {  fs.readdir(dir, function (er, files) {    if (er) return cb(er);    var counter = files.length;    var errored = false;    var stats = [];     files.forEach(function (file, index) {      fs.stat(path.join(dir,file), function (er, stat) {        if (errored) return;        if (er) {          errored = true;          return cb(er);        }        stats[index] = stat;         if (--counter == 0) {          var largest = stats            .filter(function (stat) { return stat.isFile(); })             .reduce(function (prev, next) {              if (prev.size > next.size) return prev;              return next;            })          cb(null, files[stats.indexOf(largest)]);        }      });    });  });};```]---# 小结### 优势.trigger-time.trigger-time--small[- 简单- 符合 Node 中多数 API 设计]### 不足.trigger-time.trigger-time--small[- 难以控制嵌套层级，常常遭遇 Callback Hell- 需要自行控制回调协同- 错误处理较为复杂]---# B: Callback with Async.code-block.code-block--nomargin.code-block--smallest[```javascriptfunction findMaxSizeFile(dir, cb) {  async.waterfall([    function (next) {      fs.readdir(dir, next)    },    function (files, next) {      var paths = files.map(function (file) {        return path.join(dir, file);      });      async.map(paths, fs.stat, function (err, stats) {        next(err, files, stats);      });    },    function (files, stats, next) {      var largest = stats        .filter(function (stat) { return stat.isFile(); })        .reduce(function (prev, next) {          if (prev.size > next.size) return prev;          return next;        });      next(null, files[stats.indexOf(largest)]);    }  ], cb);}```]---# 小结.trigger-time.trigger-time--small[- 弥补了原生 Callback 的主要问题- 新的问题是：    - Async 是一个第三方库，API 有记忆成本    - 对外仍然通过 Callback，嵌套不可避免]---# C: Promise### A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future..center[![promise status flow](promise-states-flow.png)]---# Promise API.code-block.code-block--nomargin.code-block--small[```javascriptnew Promise(function (resolve, reject) {})Promise.all(iterable)Promise.race(iterable)Promise.resolve(value)Promise.reject(reason)Promise.prototype.then(onFulfilled, onRejected)Promise.prototype.catch(onRejected)```]---# Chaining & Error Bubbling.code-block.code-block--nomargin.code-block--small[```javascriptgetTweetsFor('domenic')  .then(function (tweets) {    var shortUrls = parseTweetsForUrls(tweets);    var mostRecentShortUrl = shortUrls[0];    return expandUrlUsingTwitterApi(mostRecentShortUrl);  })  .then(httpGet)  .then(    function (responseBody) {      console.log('Most recent link text:', responseBody);    },    function (error) {      console.error('Error with the twitterverse:', error);    }  );```]---# The Point of Promise### 对比下同步代码：.code-block.code-block--nomargin.code-block--small[```javascripttry {  var tweets = getTweetsFor("domenic");  var shortUrls = parseTweetsForUrls(tweets);  var mostRecentShortUrl = shortUrls[0];  var responseBody = httpGet(expandUrlUsingTwitterApi(mostRecentShortUrl));  console.log("Most recent link text:", responseBody);} catch (error) {  console.error("Error with the twitterverse: ", error);}```]### [Promise 获得了类似同步代码的顺序执行和错误处理能力](#)---# 第三方库 Bluebird.code-block.code-block--nomargin.code-block--small[```javascriptvar Promise = require('bluebird');// 集合Promise.map(iterable, mapper)Promise.filter(iterable, filterer)Promise.reduce(iterable, reducer, initialValue)// 原型Promise.prototype.finally(onFulfilled, onRejected)Promise.prototype.spread(onFulfilled)// 和 Generator 结合Promise.coroutine(generatorFunction)```]---# Promise 的解法.code-block.code-block--nomargin.code-block--smallest[```javascriptvar denodeify = require('denodeify');var fsReaddir = denodeify(fs.readdir);var fsStat = denodeify(fs.stat); function findMaxSizeFile(dir) {  return fsReaddir(dir)    .then(function (files) {      var promises = files.map(function (file) {        return fsStat(path.join(dir, file))      })      return Promise.all(promises).then(function (stats) {        return { files: files, stats: stats };      });    })    .then(function (data) {      var largest = data.stats        .filter(function (stat) { return stat.isFile(); })        .reduce(function (prev, next) {          if (prev.size > next.size) return prev;          return next;        });      return data.files[data.stats.indexOf(largest)]    });}```]---# 小结### 优势.trigger-time.trigger-time--small[- 为异步而设计- 原生- 可以获得类似同步代码的能力]### 不足.trigger-time.trigger-time--small[- 写法上和同步代码仍有差距- resolve 只接受一个参数，有时捉襟见肘]---# D: Generator### Generators are functions which can be exited and later re-entered. Their context (variable bindings) will be saved across re-entrances..code-block.code-block--nomargin.code-block--small[```javascriptfunction* idMaker() {  var index = 0;  while (index < 3) {    yield index++;  }}var gen = idMaker();console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2console.log(gen.next().value); // undefined```]---# Generator 的解法.code-block.code-block--nomargin.code-block--smallest[```javascriptvar co = require('co');var thunkify = require('thunkify');var readdir = thunkify(fs.readdir);var stat = thunkify(fs.stat); function findMaxSizeFile(dir) {  return co(function* () {    var files = yield readdir(dir);    var stats = yield files.map(function (file) {      return stat(path.join(dir, file));    });    var largest = stats      .filter(function (stat) { return stat.isFile(); })      .reduce(function (prev, next) {        if (prev.size > next.size) return prev;        return next;      });    return files[stats.indexOf(largest)];  });}```]---# 小结### 优势.trigger-time.trigger-time--small[- 和同步代码几乎一致]### 不足.trigger-time.trigger-time--small[- 一般依赖第三方库，例如 co- 设计本意是解决枚举问题，Hack 的味道比较浓]---# E: Async/Await### 异步编程的终极方案### The language-level model for writing asynchronous code in ECMAScript..code-block.code-block--nomargin.code-block--small[```javascriptconst f = () => {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve(123);    }, 2000);  });};const testAsync = async () => {  const t = await f();  console.log(t);};testAsync();```]---# Async/Await 的解法.code-block.code-block--nomargin.code-block--small[```javascriptconst denodeify = require('denodeify');const fsReaddir = denodeify(fs.readdir);const fsStat = denodeify(fs.stat); const findMaxSizeFile = async dir => {  const files = await fsReaddir(dir);  const stats = [];  for (const file of files) {    const stat = await fsStat(path.join(dir, file));    stats.push({ file: file, stat: stat });  }  const largest = stats    .filter(stat => stat.stat.isFile())    .reduce((prev, next) => {      if (prev.stat.size > next.stat.size) return prev;      return next;    });  return largest.file;};```]---# 小结### 优势.trigger-time.trigger-time--small[- 基于 Promise 和 Generator，原语级支持- 比 Promise 更简单，比 Generator 更面向异步]### 不足.trigger-time.trigger-time--small[- 尚在 Stage 3，即将成为 ES2017 标准，目前需要借助 Babel 等转译]---# 参考.trigger-time.trigger-time--small[- [Managing Node.js Callback Hell with Promises, Generators and Other Approaches](https://strongloop.com/strongblog/node-js-callback-hell-promises-generators/)- [You're Missing the Point of Promises](https://blog.domenic.me/youre-missing-the-point-of-promises/)- [Promisejs.org](https://www.promisejs.org/)- [Proposal: Async Functions for ECMAScript](https://tc39.github.io/ecmascript-asyncawait/)]---name: last-page# Thanks    </textarea>    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>    <script type="text/javascript">      var hljs = remark.highlighter.engine;    </script>    <script src="http://remarkjs.com/remark.language.js" type="text/javascript"></script>    <script type="text/javascript">      var slideshow = remark.create({          highlightStyle: 'monokai',          highlightLanguage: 'remark'        }) ;    </script>  </body></html>